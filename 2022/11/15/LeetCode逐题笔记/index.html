<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>LeetCode逐题笔记 | 阳阳小屋</title><meta name="author" content="火星架构师"><meta name="copyright" content="火星架构师"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="每日一题的思路与解法">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode逐题笔记">
<meta property="og:url" content="https://wryit.fun/2022/11/15/LeetCode%E9%80%90%E9%A2%98%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="阳阳小屋">
<meta property="og:description" content="每日一题的思路与解法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wryit.fun/img/%E5%B0%81%E9%9D%A2%E5%9B%BE2.jpg">
<meta property="article:published_time" content="2022-11-15T14:41:49.000Z">
<meta property="article:modified_time" content="2023-05-03T22:50:49.000Z">
<meta property="article:author" content="火星架构师">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wryit.fun/img/%E5%B0%81%E9%9D%A2%E5%9B%BE2.jpg"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://wryit.fun/2022/11/15/LeetCode%E9%80%90%E9%A2%98%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":250},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 火星架构师","link":"链接: ","source":"来源: 阳阳小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'LeetCode逐题笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-03 22:50:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3880675_w3xksiojrkh.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css"  media="defer" onload="this.media='all'"><span id="fps"></span><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true">   <use xlink:href="#icon-daxue"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wangye"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoji">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chuansong">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijie">                   </use></svg><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-nanshi"></use></svg><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-prompt">                   </use></svg><span> 恋爱</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-star">                   </use></svg><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/%E5%B0%81%E9%9D%A2%E5%9B%BE2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="阳阳小屋"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.jpg"/><span class="site-name">阳阳小屋</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="icon faa-tada" aria-hidden="true">   <use xlink:href="#icon-daxue"></use></svg><span> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-wangye"></use></svg><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-youxiang">                   </use></svg><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-biaoji">                   </use></svg><span> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-chuansong">                   </use></svg><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-shijie">                   </use></svg><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-nanshi"></use></svg><span> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-prompt">                   </use></svg><span> 恋爱</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-star">                   </use></svg><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">LeetCode逐题笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-15T14:41:49.000Z" title="发表于 2022-11-15 14:41:49">2022-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-03T22:50:49.000Z" title="更新于 2023-05-03 22:50:49">2023-05-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LeetCode/">LeetCode</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">52.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>228分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="LeetCode逐题笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="两数之和">1、两数之和</h1>
<h3 id="length的使用">length的使用</h3>
<ol type="1">
<li><p><code>length</code></p>
<p>length是属性，是<strong>数组</strong>的长度，使用时的形式是：数组<code>.length</code>不加括号</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] cp;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cpdomains.length;</span><br></pre></td></tr></table></figure></li>
<li><p><code>length()</code></p>
<p>length()是<strong>字符串</strong>自带的方法，是求字符串长度的，使用形式是：<code>str.length()</code></p></li>
<li><p><code>size()</code></p>
<p>size()是<strong>列表</strong>的自带方法，求的是列表的长度，使用形式是：<code>list.size()</code></p></li>
</ol>
<h1 id="两数相加">2. 两数相加</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303170957822.png" /></p>
<p>中等题，考察链表的操作和构造。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span> || l2!=<span class="literal">null</span> || add!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> add;</span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="literal">null</span>) &#123;</span><br><span class="line">                k += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="literal">null</span>) &#123;</span><br><span class="line">                k += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                k -= <span class="number">10</span>;</span><br><span class="line">                add = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                add = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(k);</span><br><span class="line">            p.next = temp;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="无重复字符的最长子串">3. 无重复字符的最长子串</h1>
<blockquote>
<p>考察： #滑动窗口 #双指针 #Set</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221737239.png" /></p>
<p>中等题。注意审题，因为 <code>s</code> 由英文字母、数字、符号和空格组成，所以不能使用位运算。这里使用 hashset。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i&lt;n &amp;&amp; j&lt;n) &#123;    <span class="comment">// j表示待判断的，i表示起点</span></span><br><span class="line">            <span class="keyword">if</span> (i == j &amp;&amp; i &lt; n-<span class="number">1</span>) &#123;</span><br><span class="line">                set.add(sc[i]);</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(sc[j])) &#123;    <span class="comment">// 表示过去没有</span></span><br><span class="line">                set.add(sc[j]);     <span class="comment">// 当前j可以加入</span></span><br><span class="line">                res = Math.max(res, j-i+<span class="number">1</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;     <span class="comment">// j下标的元素已经有了，不能继续处理了，需要删i</span></span><br><span class="line">                set.remove(sc[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="寻找两个正序数组的中位数">4、寻找两个正序数组的中位数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626674.png" alt="image-20220922220554936" /><figcaption aria-hidden="true">image-20220922220554936</figcaption>
</figure>
<h1 id="最长回文子串">5、最长回文子串</h1>
<h2 id="方法一中心扩张法">方法一、中心扩张法</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626675.png" alt="image-20220920211209159" /><figcaption aria-hidden="true">image-20220920211209159</figcaption>
</figure>
<h3 id="注意">注意</h3>
<ol type="1">
<li><p>注意出现“aaaa”、“aaa”这样相同字符的回文子串，因此需要在第一个while循环中判断从当前i开始左右是否相同。</p></li>
<li><p>在完成相同字符的判断后，进行left-1和right+1同时判断，查找回文数。</p></li>
<li><p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<p>时间换空间</p></li>
</ol>
<h3 id="替换">替换</h3>
<ol type="1">
<li><p>将字符串转为数组的方式有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br></pre></td></tr></table></figure></li>
<li><p>提取字符串中某一下标的字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">st</span> <span class="operator">=</span> s.charAt(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="方法二动态规划">方法二、动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626676.png" alt="image-20220920211102615" /><figcaption aria-hidden="true">image-20220920211102615</figcaption>
</figure>
<p>二维数组是动态规划最常用的方法</p>
<h3 id="注意-1">注意</h3>
<ol type="1">
<li><p>此方法核心在于按照子串长度进行遍历，判断l长度的子串是否为回文子串，即判断除去两个端点的子串是否为回文子串</p></li>
<li><p>1中至少要有三个元素。在只有1个元素时，回文子串就是它自己；有两个元素时，如果两个元素相等则为回文子串。</p></li>
<li><p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(n^2)</p></li>
</ol>
<h1 id="盛最多水的容器">11、盛最多水的容器</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626677.png" alt="image-20220924130921512" /><figcaption aria-hidden="true">image-20220924130921512</figcaption>
</figure>
<p>逻辑性很强的题目！！</p>
<p>双指针，一个指向最左边，一个指向最右边，这两个指针所指的相对长的板后面称为长板，相对短的板称为短板。</p>
<p>对于左右指针逼近，容器的底边长度一定是在减小。</p>
<p>容器的盛水量取决于底边长度和<strong>短板</strong>。</p>
<p>所以！如果移动短板，可能会遇到更短或者相等的板，那是不幸，容量变小；如果遇到长一些的板子，容量可能变小也可能不变也可能变大。</p>
<p>如果移动长板，底边长度一定减小，如果遇到的是长板，因为容器的高取决于短板，且底边变短，所以容量一定减小；如果遇到比自己短，比短板长的板子，和刚刚一样的道理，也是容量变小；如果遇到比短板还短的板子，那更不用说了，短边变成它自己了，容量一定减小。</p>
<p>因此！富贵险中求！如果移动长板，那容量是一定减少的！如果移动短板，有几率容量变大！</p>
<p>所以设置一个max值，每次移动都记录一下容量，当i与j相遇就说明遍历结束，最后返回max即可。</p>
<h1 id="三数之和">15、三数之和</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626678.png" alt="image-20220924125048130" /><figcaption aria-hidden="true">image-20220924125048130</figcaption>
</figure>
<ol type="1">
<li><p><code>Listconst&lt;List&lt;Integer&gt;&gt;</code> 的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p><code>List&lt;Integer&gt;</code>的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li>
<li><p>List的添加操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.add(r);    <span class="comment">//r必须是list的&lt;&gt;内的类型，在尾部插入</span></span><br></pre></td></tr></table></figure></li>
<li><p>List的搜索操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.get(index);    <span class="comment">//获取list下标为index的数值</span></span><br></pre></td></tr></table></figure></li>
<li><p>List查找某个元素是否在其中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(s);    <span class="comment">//查找s这个元素是否在list中</span></span><br></pre></td></tr></table></figure></li>
<li><p>int转为Integer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(a);</span><br></pre></td></tr></table></figure></li>
<li><p>数组的排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);     <span class="comment">//原地修改nums数组</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="有效的括号">20. 有效的括号</h1>
<blockquote>
<p>考察： #栈</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304210915708.png" /></p>
<p>简单题，利用栈即可。</p>
<h1 id="删除有序数组中的重复项">26、删除有序数组中的重复项</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626679.png" alt="image-20220924130553781" /><figcaption aria-hidden="true">image-20220924130553781</figcaption>
</figure>
<p>双指针思路</p>
<h1 id="下一个排列">31、下一个排列</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626680.png" alt="image-20220929222726483" /><figcaption aria-hidden="true">image-20220929222726483</figcaption>
</figure>
<p>思路很强，考验找规律的能力。</p>
<p>例：</p>
<p><strong>对于 123465：</strong></p>
<p>第一步，从后往前找到第一对升序的两个数，也就是46</p>
<p>第二步，从结尾开始到6，<strong>找到第一个大于4的数</strong>，也就是5</p>
<p>第三步，将4和5对换位置，变成123564</p>
<p>第四步，将6开始到结尾变成升序，变成123546</p>
<p><strong>简化：</strong></p>
<p>第一步，从后往前找到第一对升序的两个数，也就是46</p>
<p>第二步，从6开始到结尾，升序排列，变成123456</p>
<p>第三步，<strong>在刚刚升序的部分找到第一个大于4的数，即5</strong>，将4和5对换位置，变成123546</p>
<p><strong>其他：</strong></p>
<p>对于已经是最大的数，即从头到尾是越来越小的，它的下一个数是最小的，也就是从头到尾是越来越大的，因此只要对数组进行排序即可。</p>
<h1 id="搜索旋转排序数组">33、搜索旋转排序数组</h1>
<p>遇到时间复杂度<code>O(log n)</code>，二话不说，直接<strong>二分查找</strong>！</p>
<h2 id="方法一暴力不满足logn">方法一、暴力（不满足log(n)）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626681.png" alt="image-20221002171738960" /><figcaption aria-hidden="true">image-20221002171738960</figcaption>
</figure>
<h2 id="方法二二分法不完全满足logn">方法二、二分法（不完全满足log(n)）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626682.png" alt="image-20221002172037673" /><figcaption aria-hidden="true">image-20221002172037673</figcaption>
</figure>
<p>先求出向左移动的次数k，然后再用二分法判定，每次结果也便宜k。</p>
<h2 id="方法三二分法优化满足logn">方法三、二分法优化（满足log(n)）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626683.png" alt="image-20221002175004110" /><figcaption aria-hidden="true">image-20221002175004110</figcaption>
</figure>
<p>这个方法简单又巧妙。</p>
<p>正常二分后，先判断mid的值是不是target，再看左边和右边哪个是顺序的。</p>
<p>如果<code>nums[left] &lt;= nums[mid]</code>，说明左边是顺序的。再看target是不是再左边区间里，如果是则<code>right = mid-1</code>；<strong>否则，</strong><code>left = mid+1</code>，继续在右边找。</p>
<p>如果<code>nums[left] &gt; nums[mid]</code>，说明左边是不规则的，那么右边一定是顺序的。再看target是不是再右边区间里，如果是则<code>left = mid+1</code>；<strong>否则，</strong><code>right = mid-1</code>，继续在左边找。</p>
<h1 id="在排序数组中查找元素的第一个和最后一个位置">34、在排序数组中查找元素的第一个和最后一个位置</h1>
<p>遇到时间复杂度<code>O(log n)</code>，二话不说，直接<strong>二分查找</strong>！</p>
<h2 id="方法一二分扩张">方法一、二分+扩张</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626684.png" alt="image-20221002123506969" /><figcaption aria-hidden="true">image-20221002123506969</figcaption>
</figure>
<p>先找到值为target的数组的元素的位置，再向两边扩张，找到左右边界。</p>
<h2 id="方法二二分查找性质">方法二、二分查找性质</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626685.png" alt="image-20221002123926754" /><figcaption aria-hidden="true">image-20221002123926754</figcaption>
</figure>
<p>这种方法的思路很妙，要想找到数组中值为target的范围，只要找到数组中&gt;=target和target+1的第一个值的下标。</p>
<blockquote>
<p>例：</p>
<p>nums = [5,7,7,8,8,10], target = 8</p>
</blockquote>
<p>先找target=8的第一个位置：</p>
<ol type="1">
<li>left = 0，right = 6，mid = 3，找到了一个，往左边找</li>
<li>left = 0，right = 3，mid = 1，小了</li>
<li>left = 2，right = 3，mid = 2，小了</li>
<li>left = 3，right = 3，mid = 3，当left==right，结束，此时left就是第一个</li>
</ol>
<p>再找target=9的第一个位置：</p>
<ol type="1">
<li>left = 0，right = 6，mid = 3，小了</li>
<li>left = 4，right = 6，mid = 5，大了</li>
<li>left = 4，right = 5，mid = 4，小了</li>
<li>left = 5，right = 5，mid = 5，当left==right，结束，此时left就是第一个的位置</li>
</ol>
<p>除此之外，我们还需要判断target=8的时候到底有没有这个值哦~</p>
<p>注意：</p>
<p>本题的right初始值为n，后来right更新为mid，和我们过去使用的二分法略有不同，因为如果mid就是我需要的那个值，且它就是第一个出现的，按照过去的算法，right=mid-1，最后可能会丢失了这个mid。但是新的算法一直用right保存mid，<strong>只要一直在找左区间，就需要将我们的目标范围不停往左边移动</strong>，就应该用right保存mid，最后一定会出现left、right、mid相等的情况，也就是左区间。</p>
<h1 id="搜索插入位置">35. 搜索插入位置</h1>
<blockquote>
<p>考察： #二分查找</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201611658.png" /></p>
<p>简单题，相当于找&gt;=target 的第一个元素的下标。</p>
<h1 id="组合总和">39、组合总和⭐</h1>
<h2 id="方法一双端队列dfs">方法一、双端队列+DFS</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626686.png" alt="image-20221004214508995" /><figcaption aria-hidden="true">image-20221004214508995</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626687.png" alt="image-20221004211227805" /><figcaption aria-hidden="true">image-20221004211227805</figcaption>
</figure>
<p>候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合。同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。</p>
<h3 id="相关知识">相关知识</h3>
<h4 id="listlist">List&lt;List&gt;</h4>
<p>构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br></pre></td></tr></table></figure>
<h4 id="deque双端队列">Deque双端队列</h4>
<p>两端都可以进出，FIFO（先进先出）</p>
<p>构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>操作</p>
<p>端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>第一个元素 (头部)</th>
<th></th>
<th>最后一个元素 (尾部)</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>抛出异常</td>
<td>特殊值</td>
<td>抛出异常</td>
<td>特殊值</td>
</tr>
<tr class="even">
<td>插入</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr class="odd">
<td>删除</td>
<td>removeFirst()</td>
<td>pollFirst()</td>
<td>removeLast()</td>
<td>pollLast()</td>
</tr>
<tr class="even">
<td>检查</td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
<p>Deque与Queue的对照</p>
<table>
<thead>
<tr class="header">
<th>Queue方法</th>
<th>等效Deque方法</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>add(e)</td>
<td>addLast(e)</td>
</tr>
<tr class="even">
<td>offer(e)</td>
<td>offerLast(e)</td>
</tr>
<tr class="odd">
<td>remove()</td>
<td>removeFirst()</td>
</tr>
<tr class="even">
<td>poll()</td>
<td>pollFirst()</td>
</tr>
<tr class="odd">
<td>element()</td>
<td>getFirst()</td>
</tr>
<tr class="even">
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
<p>在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p>
<table>
<thead>
<tr class="header">
<th><strong>堆栈方法</strong></th>
<th><strong>等效Deque方法</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr class="even">
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr class="odd">
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin;i&lt;len;i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);     <span class="comment">//双端队列在结尾增加</span></span><br><span class="line">            DFS(candidates,i,len,target-candidates[i],path,res);</span><br><span class="line">            path.removeLast();    <span class="comment">//双端队列删去刚刚在上一个DFS中加入的值，继续进入循环，判断下一个分支</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//构造一个双端队列</span></span><br><span class="line"></span><br><span class="line">        DFS(candidates,<span class="number">0</span>,len,target,path,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二剪枝叶">方法二、剪枝叶</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626688.png" alt="image-20221004211040594" /><figcaption aria-hidden="true">image-20221004211040594</figcaption>
</figure>
<p>在一开始就对数组进行排序，因为在分支中，如果<code>target-candidates[i] &lt; 0</code>，那么这个分支之后的更大的i就更不可能了。直接break即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=begin;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-candidates[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.addLast(candidates[i]);     <span class="comment">//双端队列在结尾增加</span></span><br><span class="line">    DFS(candidates,i,len,target-candidates[i],path,res);</span><br><span class="line">    path.removeLast();    <span class="comment">//双端队列删去刚刚在上一个DFS中加入的值，继续进入循环，判断下一个分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合总和ii">40、组合总和II</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626689.png" alt="image-20221004222241402" /><figcaption aria-hidden="true">image-20221004222241402</figcaption>
</figure>
<p>和39题是同样的思路</p>
<p>唯一的不同是每次begin是从下一个更大的数开始。</p>
<p><strong>注意：</strong></p>
<p>在剪枝中，注意要两次剪枝。</p>
<p>第一次剪枝和39题一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次剪枝</span></span><br><span class="line"><span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二次剪枝是为了消除一样的结果，注意在<code>i&gt;begin</code>时，<code>candidates[i]==candidates[i-1]</code>表示是在同一级有相同元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二次剪枝</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;begin &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>]) &#123;</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="跳跃游戏ii">45、跳跃游戏II⭐</h1>
<h2 id="方法一动态规划数组">方法一、动态规划+数组</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626690.png" alt="image-20221018221627713" /><figcaption aria-hidden="true">image-20221018221627713</figcaption>
</figure>
<p>原理和 <code>55、跳跃游戏</code> 一致，但是是利用 dp 数组记录到达下标为 i 的节点的最短步数。</p>
<p>遍历数组，在遍历中，对下标为<code>i+nums[i]</code>进行判断，步数为<code>dp[i]+1</code>，取最小的dp存入。最后输出<code>dp[n-1]</code></p>
<h2 id="方法二优化">方法二、优化</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626691.png" alt="image-20221018221108378" /><figcaption aria-hidden="true">image-20221018221108378</figcaption>
</figure>
<p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p>
<p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p>
<p>思想是上面那样，但是操作起来需要一些技巧：</p>
<p>对于上面的第一个部分0~2，虽然我们可以通过max知道谁能跳多远，但是我们还是需要走到边界end，也就是下标为2的地方，在这里我们可以更新步数+1，同时将新的边界end更新为刚刚走完的那一段中能走的最远的max。再继续上面的步骤。</p>
<p><strong>代码真的很巧妙！！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;   </span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 上次跳跃可达范围右边界（下次的最右起跳点）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_border</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 目前能跳到的最远位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            max_border = Math.max(max_border,i+nums[i]);</span><br><span class="line">            <span class="comment">// 到达上次跳跃能到达的右边界了</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = max_border;    <span class="comment">// 目前能跳到的最远位置变成了下次起跳位置的有边界</span></span><br><span class="line">                step++;    <span class="comment">// 进入下一次跳跃</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="全排列">46、全排列</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626692.png" alt="image-20221008115241358" /><figcaption aria-hidden="true">image-20221008115241358</figcaption>
</figure>
<p>本题的思路来自<code>31、下一个排列</code>，找当前数组的下一个排列，<strong>对于 123465：</strong></p>
<ol type="1">
<li>从后向前找到第一对升序的相邻的两个数，即<code>46</code>；</li>
<li>从6开始到结尾升序排列，变成<code>123456</code>；</li>
<li>在刚刚升序的子序列中，即<code>56</code>中，从左到右找到一个大于<code>4</code>的数，即<code>5</code>，与<code>4</code>交换，变成<code>123546</code>。</li>
</ol>
<p>因此，本题的思路很简单了：</p>
<ol type="1">
<li>将数组升序排列</li>
<li>调用此方法</li>
<li>直到整个数组为逆序为止，也就是当i定位第一对升序组合的较小值时，已经定位到-1了，则退出。</li>
</ol>
<h2 id="拓展">拓展</h2>
<p><a href="LeetCode总结笔记.md#Stream流">Stream流</a></p>
<h1 id="字母异位词分组">49. 字母异位词分组</h1>
<blockquote>
<p>考察： #哈希</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304161118867.png" /></p>
<p>中等题，hash 存储即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,ArrayList&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] sc = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(sc);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sc);</span><br><span class="line">            ArrayList&lt;String&gt; temp = hash.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            hash.put(key, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;String&gt; v : hash.values()) &#123;</span><br><span class="line">            res.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大子数组和">53、最大子数组和</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626693.png" alt="image-20221019195142360" /><figcaption aria-hidden="true">image-20221019195142360</figcaption>
</figure>
<p>简单动态规划~写过很多次啦！</p>
<h1 id="跳跃游戏">55、跳跃游戏</h1>
<h2 id="方法一动态规划dp数组">方法一、动态规划+dp数组</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626694.png" alt="image-20221018222804356" /><figcaption aria-hidden="true">image-20221018222804356</figcaption>
</figure>
<p>利用dp数组记录某个点是否能到达，能到达记为1，随时判断下标为n-1即可。</p>
<h2 id="方法二优化动态更新最大长度">方法二、优化——动态更新最大长度</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626695.png" alt="image-20221018222935560" /><figcaption aria-hidden="true">image-20221018222935560</figcaption>
</figure>
<p>在能跳跃的区域内遍历，不断更新能跳跃的最大长度，如果能覆盖下标为n-1则为true。</p>
<p>只用遍历一遍即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//不断更新能跳的最大长度，这样只要遍历一次就行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;max) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max&gt;=n-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="合并区间">56. 合并区间</h1>
<blockquote>
<p>考察： #数组 #数组排序</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304210936639.png" /></p>
<p>中等题，但是简单。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a1[<span class="number">0</span>]!=a2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a1[<span class="number">0</span>]-a2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a1[<span class="number">1</span>]-a2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&lt;=end) &#123;</span><br><span class="line">                end = Math.max(end,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                temp.add(start);</span><br><span class="line">                temp.add(end);</span><br><span class="line">                al.add(temp);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        temp.add(start);</span><br><span class="line">        temp.add(end);</span><br><span class="line">        al.add(temp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[al.size()][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;al.size();i++) &#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = al.get(i).get(<span class="number">0</span>);</span><br><span class="line">            res[i][<span class="number">1</span>] = al.get(i).get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文本左右对齐">68、文本左右对齐</h1>
<h2 id="方法一枚举各种情况">方法一、枚举各种情况</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626696.png" alt="image-20220924200048680" /><figcaption aria-hidden="true">image-20220924200048680</figcaption>
</figure>
<p><code>_1.java</code>文件为精简版（将很多重复的代码放入函数）</p>
<p><code>_2.java</code>文件更容易理解</p>
<p><code>_3.java</code>文件思路一致，但是更加精简，且易懂⭐</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626697.png" alt="image-20220924202357372" /><figcaption aria-hidden="true">image-20220924202357372</figcaption>
</figure>
<h1 id="爬楼梯">70、爬楼梯</h1>
<h2 id="方法一动态规划">方法一、动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626698.png" alt="image-20221016215036802" /><figcaption aria-hidden="true">image-20221016215036802</figcaption>
</figure>
<p>如果使用递归——妥妥的时间超时！！！</p>
<p>所以只有正着推。可以得到规律：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<h3 id="简单优化">简单优化</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626699.png" alt="image-20221016220255962" /><figcaption aria-hidden="true">image-20221016220255962</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure>
<h1 id="搜索二维矩阵">74. 搜索二维矩阵</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211050065.png" /></p>
<p>中等题。两次二分查找，先查找行，再查找列。代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> findrow(matrix,target);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">        <span class="keyword">return</span> find(matrix[r],target);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findrow</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;    <span class="comment">// 找第一个小于等于target的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[m][<span class="number">0</span>]&lt;=target) &#123;</span><br><span class="line">                l = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[m]==target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子集">78. 子集⭐⭐</h1>
<blockquote>
<p>考察： #回溯</p>
</blockquote>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/solutions/2059409/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-8tkl/?languageTags=java">题解</a></p>
<h2 id="方法一">方法一</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304222043816.png" /></p>
<p>中等题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选nums[i]，直接进入下一个</span></span><br><span class="line">        find(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择nums[i]，添加进入ans，再进入下一个</span></span><br><span class="line">        ans.add(nums[i]);</span><br><span class="line">        find(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回退场景</span></span><br><span class="line">        ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二更通用的回溯框架">方法二、更通用的回溯⭐（框架）</h2>
<p>思路比较抽象，需要思考。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;nums.length;j++) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况：nums[j]在</span></span><br><span class="line">            ans.add(nums[j]);</span><br><span class="line">            find(j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二种情况：nums[i]-nums[j]都不在</span></span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="格雷编码">89. 格雷编码 ⭐</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/gray-code/solutions/1198173/dai-ma-jie-de-xiao-bai-javac-san-chong-f-iaxe/">题解</a></p>
<h2 id="方法一规律">方法一、规律</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230922343.png" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230849567.png" /></p>
<p>总结了如下规律：<br />
1. 0 位格雷码有 1 个码字；1 位格雷码有 2 个码字 2. (n+1) 位格雷码中的<strong>前 2^n</strong> 个码字（前一半）等于 n 位格雷码的全部码字，按顺序书写，加前缀 0（意味着如果 n 位的所有码字已经加入 res，就不用操作了） 3. (n+1) 位格雷码中的<strong>后 2^n</strong> 个码字 (后一半）等于 n 位格雷码的全部码字按逆序书写，并加前缀 1（相当于把 n 位的所有码字逆序遍历，并加上一个头 1） 4. n+1 位格雷码的集合 = n 位格雷码集合 (顺序) 加前缀 0 + n 位格雷码集合 (逆序) 加前缀 1</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;      <span class="comment">//表示从1位到n位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> res.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=l-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;      <span class="comment">//遍历在上一轮之后存的i-1位二进制码</span></span><br><span class="line">                res.add(res.get(j)+head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二格雷编码">方法二、格雷编码</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230924855.png" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230913159.png" /></p>
<p>实现公式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230913296.png" /></p>
<blockquote>
<p>举个🌰：n=4 时，当十进制为 7，现在最高位加个 0，所以其对应的二进制位 00111，可以通过上图的例子进行演算。<br />
从右往左推算 00111 对应的格雷码的每一位：<br />
1 ⊕ 1 = 0<br />
1 ⊕ 1 = 0<br />
0 ⊕ 1 = 1<br />
0 ⊕ 0 = 0<br />
所以其对应的格雷码为 0100</p>
</blockquote>
<blockquote>
<p>再举个🌰：n=4 时，当十进制为 12，现在最高位加个 0，所以其对应的二进制位 01100，可以通过上图的例子进行演算。<br />
从右往左推算 01100 对应的格雷码的每一位：<br />
0 ⊕ 0 = 0<br />
1 ⊕ 0 = 1<br />
1 ⊕ 1 = 0<br />
0 ⊕ 1 = 1<br />
所以其对应的格雷码为 1010</p>
</blockquote>
<p>不难发现，对于十进制为 i 的数，其格雷码就是 <strong>i ^ (i&gt;&gt;1)</strong>，根据这个思路很容易得到代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;  </span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子集-ii">90. 子集 II⭐</h1>
<blockquote>
<p>考察： #回溯</p>
</blockquote>
<blockquote>
<p>基础题/框架题：<strong>78（子集）</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304222133401.png" /></p>
<p>中等题，在 78 题的基础上多了一步去重。需要先对 nums 进行排序，将相同的聚在一起。在 find 函数中，如果遇到连续的相同的数，只取其中的第一个。因为在同一个 find 下的 for 循环内是属于同一级别的，比如：<code>[1, 2, 2]</code> 分解为 <code>[1, 2]</code> 和 <code>[1, 2]</code> 是一样的，同级别的相同的去重即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i &amp;&amp; nums[j]==nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(nums[j]);</span><br><span class="line">            find(j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的中序遍历">94. 二叉树的中序遍历</h1>
<blockquote>
<p>考察： #树</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181704002.png" /></p>
<p>简单题，考察树的中序遍历，模板如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midfind</span><span class="params">(TreeNode r)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	midfind(r.left);</span><br><span class="line">	res.add(r.val);</span><br><span class="line">	midfind(r.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="对称二叉树">101. 对称二叉树😭</h1>
<blockquote>
<p>考察： #树</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191457105.png" /></p>
<p>简单题，但是思路很妙。</p>
<p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。如果同时满足下面的条件，两个树互为镜像： - 它们的两个根结点具有相同的值 - 每个树的右子树都与另一个树的左子树镜像对称</p>
<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode r1, TreeNode r2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> &amp;&amp; r2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> || r2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1.val == r2.val &amp;&amp; check(r1.left, r2.right) &amp;&amp; check(r1.right, r2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的层序遍历">102. 二叉树的层序遍历</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181725335.png" /></p>
<p>简单题。但是要注意 <code>List&lt;List&lt;Integer&gt;&gt;</code> 对象的构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的最大深度">104. 二叉树的最大深度</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181713334.png" /></p>
<p>简单题，遍历即可，同步 level 层级。</p>
<h1 id="杨辉三角">118. 杨辉三角</h1>
<blockquote>
<p>考察： #动态数组</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181807228.png" /></p>
<p>简单题。但是需要注意，对于同一个 arraylist 对象，如果之前已经加入了嵌套的外层 list 中，之后再改变这个对象，嵌套在里面的也会改变，类似于一个指针。</p>
<h1 id="买卖股票的最佳时机">121、买卖股票的最佳时机</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626700.png" alt="image-20221021185552910" /><figcaption aria-hidden="true">image-20221021185552910</figcaption>
</figure>
<p>思路与<code>1014、最佳观光组合</code>相同。</p>
<h1 id="买卖股票的最佳时机-ii">122、买卖股票的最佳时机 II</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626701.png" alt="image-20221021194731667" /><figcaption aria-hidden="true">image-20221021194731667</figcaption>
</figure>
<p>这题很容易想复杂了，其实这题的目的就是为了始终不亏钱。所以只要是相邻两个升序的就买了就卖，一定能赚一笔！</p>
<h1 id="最长连续序列">128. 最长连续序列⭐</h1>
<blockquote>
<p>考察： #Set</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181636880.png" /></p>
<p>中等题。题目要求在 <span class="math inline">\(O(n)\)</span> 的时间内找到最长的连续序列，思路是找到每个连续序列的第一个数，然后再一直++，就能找到这个长度。那么问题是如何找到第一个数，或者说会不会出现中间的数重复判断。第一个数有一个特性是非第一个数没有的，就是 num-1 是不存在数组中。现在问题是如何快速判断一个数在不在数组中，这里选择使用 HashSet，它是 <span class="math inline">\(O(n)\)</span> 的时间复杂度。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s-<span class="number">1</span>)) &#123;    <span class="comment">// 我们要找的就是一个连续序列的开头数字，它的特征就是没有s-1这个值</span></span><br><span class="line">                <span class="comment">// s就是连续序列的开头数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(s+<span class="number">1</span>)) &#123;    <span class="comment">// 判断下一个在不在set中</span></span><br><span class="line">                    k++;    <span class="comment">// 计数</span></span><br><span class="line">                    s++;    <span class="comment">// 判断下一个数，这里++的结果是存在与set的</span></span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分发糖果">135、分发糖果</h1>
<h2 id="方法一递归">方法一、递归</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626702.png" alt="image-20220924183620852" /><figcaption aria-hidden="true">image-20220924183620852</figcaption>
</figure>
<p>思想：相邻的两个值中，更大的糖果=更小的糖果+1，如果比左右都大则取其max。如果比左右都小，则糖果数为1。用数组记录数值，可以提高时间效率（如果不设置数组，则会超时）。</p>
<h2 id="方法二左右遍历">方法二、左右遍历</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626703.png" alt="image-20220924182743805" /><figcaption aria-hidden="true">image-20220924182743805</figcaption>
</figure>
<p>思想：从左向右遍历一遍，设置第一个值为1，如果当前值比上一个值大，则糖果数=上一个的糖果数+1，反之将其置为1。此时从左到右的糖果大小关系已经明确。再从右往左遍历一遍，此时只需要一个temp变量记录即可，设置第一个的temp为1，如果当前值比上一个值大，则糖果数=temp+1，对于每一个小朋友都会对他从左遍历和从右遍历取最大值，也就是他最后得到的糖果值。</p>
<blockquote>
<p>对于 <code>[1,2,87,87,87,2,1]</code></p>
<p>从左向右：1，2，3，1，1，1，1</p>
<p>从右向左：1，1，1，1，3，2，1</p>
<p>综合：1，2，3，1，3，2，1</p>
</blockquote>
<h1 id="只出现一次的数字">136. 只出现一次的数字</h1>
<h2 id="方法一hashset">方法一、HashSet</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211955850.png" /></p>
<p>简单题，利用 set 记录，最后遍历。注意 set 的删除为 <code>remove()</code>。</p>
<h2 id="方法二位运算">方法二、位运算👍</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211957312.png" /></p>
<p>思路：元素只出现两次，而相同元素异或为 0。0 和某个只出现一次的元素异或为这个元素。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            res = res ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="乘积最大子数组">152、乘积最大子数组⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626704.png" alt="image-20221020111954135" /><figcaption aria-hidden="true">image-20221020111954135</figcaption>
</figure>
<p>动态规划经典题</p>
<p>本题和<code>53、最大子数组和</code>有异曲同工之处。但是值得注意的是乘法中，两个负数相乘就会得到正数。</p>
<p>所以我们不能只用一个last记录以当前元素结尾的最大值，我们需要用lastmax记录当前元素结尾的最大值、用lastmin记录当前元素结尾的最小值。</p>
<p>最大值和最小值实时动态更新。如果当前元素&lt;0，那么最大值就是上一个元素的最小值*nums[i]和它自身判断，最小值就是上一个元素的最大值*nums[i]和它自身判断。nums[i]&gt;0就很简单了。</p>
<p>为了更广泛操作（装逼），我们可以提前计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> lastmax*nums[i];</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> lastmin*nums[i];</span><br></pre></td></tr></table></figure>
<p>那么每次更新的时候只需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lastmax = Math.max(Math.max(a,b),nums[i]);</span><br><span class="line">lastmin = Math.min(Math.min(a,b),nums[i]);</span><br></pre></td></tr></table></figure>
<p>其实不难理解，如果nums[i]&lt;0，如果上一个值的max&gt;0、min&lt;0，那么取的是b；如果max&lt;0、min&lt;0，那么取的也还是b；如果max&gt;0、min&gt;0，那么取得还是b。但是如果nums[i]&gt;0，那么一切都恰恰相反，都取a。所以我们只需要用a、b得最大值和它自身比较就能得到新的lastmax。</p>
<p>lastmin同理。</p>
<p>每次循环都用变量min找到最大值。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastmax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastmin</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> lastmax*nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> lastmin*nums[i];</span><br><span class="line"></span><br><span class="line">            lastmax = Math.max(Math.max(a,b),nums[i]);</span><br><span class="line">            lastmin = Math.min(Math.min(a,b),nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (nums[i]&lt;0) &#123;</span></span><br><span class="line">            <span class="comment">//     lastmax = Math.max(b,nums[i]);</span></span><br><span class="line">            <span class="comment">//     lastmin = Math.min(a,nums[i]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">            <span class="comment">//     lastmax = Math.max(a,nums[i]);</span></span><br><span class="line">            <span class="comment">//     lastmin = Math.min(b,nums[i]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            max = Math.max(max,lastmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301641982.png" /></p>
<p>中等题，但是很简单。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="轮转数组">189. 轮转数组</h1>
<h2 id="方法一开辟额外空间">方法一、开辟额外空间</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211003068.png" /></p>
<p>中等题。最后利用了<a href="LeetCode总结笔记.md#数组#拷贝#深拷贝">深拷贝</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        k = k % n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=n-k;j&lt;n;j++,i++) &#123;</span><br><span class="line">            res[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-k;j++,i++) &#123;</span><br><span class="line">            res[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(res[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        System.arraycopy(res, <span class="number">0</span>, nums, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二原地翻转">方法二、原地翻转👍</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211009794.png" /></p>
<p>思路：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211010551.png" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % n;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,n-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;    <span class="comment">// 将nums数组的[start,end]原地逆置</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="打家劫舍模板题">198、打家劫舍（模板题）⭐⭐</h1>
<p>典型的动态规划入门题</p>
<p>思路<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/">198. 打家劫舍 - 力扣（Leetcode）</a></p>
<h3 id="优化前">优化前</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626705.png" alt="image-20221013224043773" /><figcaption aria-hidden="true">image-20221013224043773</figcaption>
</figure>
<h4 id="注意-2">注意：</h4>
<p><code>dp[0]</code>表示没有房间，不对应<code>nums</code>中任何值</p>
<p><code>dp[i]</code>对应的应该是第<code>i-1</code>个屋子的最大收益。</p>
<h3 id="优化后理论上更优的">优化后（理论上更优的）</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626706.png" alt="image-20221013224912862" /><figcaption aria-hidden="true">image-20221013224912862</figcaption>
</figure>
<h1 id="实现-trie-前缀树">208. 实现 Trie (前缀树)⭐</h1>
<blockquote>
<p>考察： #前缀树</p>
<p>拓展：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/stream-of-characters/description/">1032. 字符流</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303240925830.png" /></p>
<p><strong>前缀和介绍思路：<a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46202073/article/details/107253959">【图解算法】字典树</a></strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    TreeNode[] Children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        Children = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    TreeNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] sc = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        r.isEnd = <span class="literal">true</span>;    <span class="comment">// 表示这是单词的结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] sc = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r.isEnd;     <span class="comment">// 需要完整搜索，如果单词都有，需要判断最后一个是不是结尾</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] sc = prefix.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;prefix.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="打家劫舍-ii">213、打家劫舍 II⭐</h1>
<h2 id="动态规划">动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626707.png" alt="image-20221017165225803" /><figcaption aria-hidden="true">image-20221017165225803</figcaption>
</figure>
<p>相比<code>198、打家劫舍</code>，我们可以将题目拆解为：</p>
<p><strong>n (0~n-1) 个屋子分别在 0~n-2 和 1~n-1 中取最大值，这样就能保证首位不会同时出现</strong></p>
<h1 id="翻转二叉树">226. 翻转二叉树</h1>
<blockquote>
<p>考察： #树</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191133002.png" /></p>
<p>简答题，只要类似后序遍历，每次返回更改过左右节点的根即可。</p>
<h1 id="移动零">283. 移动零</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181652975.png" /></p>
<p>简单题。使用双指针，i 指向第一个 0，j 指向 i+1 位置。之后遍历 j，每次如果 j 位置的元素不是 0，则将其赋值到 i 的位置，i 再++。最后将 i 及其之后的元素置为 0 即可。</p>
<h1 id="最长递增子序列">300. 最长递增子序列⭐</h1>
<blockquote>
<p>考察： #动态规划 #最长递增子序列</p>
<p>拓展：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-team-with-no-conflicts/">1626. 无矛盾的最佳球队</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303221016803.png" /></p>
<p>中等题。这是最长递增子序列的最基础的题目！dp 保存的是以当前数组结尾的最长的个数。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    m = Math.max(m,dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h1>
<blockquote>
<p>考察： #滑动窗口</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221815270.png" /></p>
<p>中等题。因为可能会出现重复单词，所以不能使用位运算。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pn</span> <span class="operator">=</span> p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] test = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n&lt;pn) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : pc) &#123;</span><br><span class="line">            map[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;pn;i++) &#123;</span><br><span class="line">            test[sc[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(map,test)) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-pn;i++) &#123;</span><br><span class="line">            test[sc[i-<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            test[sc[i+pn-<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(map,test)) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小操作次数使数组元素相等">453. 最小操作次数使数组元素相等</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303101155994.png" /></p>
<p>思路：<strong>n-1 个小的加 1，相当于最大的减 1</strong>。详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            mi = Math.min(mi,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            res += (nums[i]-mi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小操作次数使数组元素相等-ii">462. 最小操作次数使数组元素相等 II</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303101453063.png" /></p>
<p>先对 nums 排序，只要选择的相等数 <code>x ∈ [nums[i], nums[j]]</code>，对于左右指针所指向的数，其操作数是固定的，即 <code>nums[j]</code> - <code>nums[i]</code>，指针所指向数的差值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 最终大家汇集的点一定在这些数之间的</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j) &#123;</span><br><span class="line">            res += (nums[j]-nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="目标和">494. 目标和⭐</h1>
<h2 id="方法一二维数组-纯暴力">方法一、二维数组 （纯暴力）</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303140943028.png" /></p>
<p>类似于树的递归调用，很愚蠢。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span>&lt;&lt;n];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;i);j++) &#123;</span><br><span class="line">                res[i][j*<span class="number">2</span>] = res[i-<span class="number">1</span>][j] - nums[i];</span><br><span class="line">                res[i][j*<span class="number">2</span>+<span class="number">1</span>] = res[i-<span class="number">1</span>][j] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[n-<span class="number">1</span>][i]==target) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;(1&lt;&lt;n);j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(res[i][j]);</span></span><br><span class="line">        <span class="comment">//         System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二数学动态规划">方法二、数学+动态规划</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303141032788.png" /></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303141035069.png" /></p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/target-sum/solutions/816361/mu-biao-he-by-leetcode-solution-o0cp/">题解</a></p>
<blockquote>
<p>注意：不能添加以下的代码段，可能有多个 0，+0 和-0 效果一样，所以不一定是 1。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum == target) &#123;    </span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target || (sum-target)%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> (sum-target)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于nums的每一个数，我选或者不选，使得最后的结果为target的搭配数量</span></span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>][neg+<span class="number">1</span>];    <span class="comment">//我们要找到就是最终neg的数量，即dp[n][neg]的值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;     <span class="comment">//表示初始状态没有任何元素选取，和为0，有1种方案。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;neg+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j&lt;num) &#123;       <span class="comment">// 如果加上num得到的结果j还比num小，这是不可能的，所以不能加</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-num];     <span class="comment">// 结果应该是不加num的个数+加上num的个数之和</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][neg];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化用一维数组进行动态规划">优化、用一维数组进行动态规划</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303141041573.png" /></p>
<blockquote>
<p>需要注意：如果正向操作可能在 <code>j&gt;=num</code> 时将原本的 <code>dp[j]</code>覆盖，在之后的调用原本的<code>dp[j]</code>时会出错，所以<strong>一维的动态规划需要从后向前逆序进行</strong>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target || (sum-target)%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> (sum-target)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于nums的每一个数，我选或者不选，使得最后的结果为target的搭配数量</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[neg+<span class="number">1</span>];   </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=neg;j&gt;=num;j--) &#123;</span><br><span class="line">                dp[j] += dp[j-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他">其他</h2>
<h3 id="栈">栈</h3>
<p><strong>超时</strong>，理论上不应该，已经进行了小优化了，但是还是会超时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dq.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">//轮数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                dq.addLast(k-nums[i]);</span><br><span class="line">                dq.addLast(k+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dq.pollFirst()==target) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="斐波那契数">509、斐波那契数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626708.png" alt="image-20221015213246525" /><figcaption aria-hidden="true">image-20221015213246525</figcaption>
</figure>
<p>简单哦~</p>
<h1 id="通过删除字母匹配到字典里最长单词">524、通过删除字母匹配到字典里最长单词</h1>
<h2 id="方法一排序后操作">方法一：排序后操作</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626709.png" alt="image-20221009174042475" /><figcaption aria-hidden="true">image-20221009174042475</figcaption>
</figure>
<p>先对List进行排序，重写排序规则：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(dictionary,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() == s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.compareTo(s2)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先对字符串List进行排序操作，根据题目要求，需要找到最长的且字典序最小的结果，所以依次遍历每一个字符串，如果当前字符串成立，则与它相同长度的字符串无需验证。</p>
<h2 id="方法二不排序操作">方法二、不排序操作</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626710.png" alt="image-20221009174019047" /><figcaption aria-hidden="true">image-20221009174019047</figcaption>
</figure>
<p>这种思路无需先排序，只要记录已经匹配成功的字符串的长度，如果在接下来的字符串长度比它小，那就无需验证；如果长度更长，则进行验证，如果验证成功，更新匹配成功的字符串长度；如果字符串长度和记录的相同，将当前字符串和这个已经匹配成功的字符串比较，只有字典序更小才进行验证。</p>
<h3 id="注意-3">注意</h3>
<p>字符串的比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.compareTo(s2);    <span class="comment">//如果s1&gt;s2，返回1；如果s1&lt;s2，返回-1；如果相等，返回0</span></span><br></pre></td></tr></table></figure>
<h1 id="二叉树的直径">543. 二叉树的直径</h1>
<blockquote>
<p>考察： #树</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201607248.png" /></p>
<p>简单题，但是思路很重要。</p>
<ul>
<li><code>root</code> 的直径 = <code>root.left</code> 的高度 + <code>root.right</code> 的高度</li>
<li><code>root</code> 的高度 = <code>Math.max(root.left的高度, root.right的高度)</code> + 1</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;   </span><br><span class="line">        findd(root);    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root为根的最大直径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findd</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, height(root.left)+height(root.right));</span><br><span class="line">        findd(root.left);</span><br><span class="line">        findd(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(root.left),height(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="和为-k-的子数组">560. 和为 K 的子数组</h1>
<blockquote>
<p>考察：前缀和</p>
</blockquote>
<h2 id="方法一前缀和">方法一、前缀和</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301746343.png" /></p>
<p>利用前缀和+两层 for 循环，比较简单易想。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">// map[i]表示nums[0~i-1]</span></span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            map[i] = map[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[i]-map[j]==k) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二前缀和hash-优化">方法二、前缀和+hash 优化⭐</h2>
<p><strong>思路：</strong> 同样先构造一个 map 数组记录前缀和，再构造一个 hash，在遍历 map 时，记录当前 map[i]-k 的值 d，也就是我们需要在 map[0, i) 找到下标为 j，满足 map[j]为 d，那么 map[i]-map[j]和就是 k。</p>
<p><strong>注意：</strong> 在下面代码实现中，一定要先更新 res，再更新 hash。举个例子：如果 k 是 0，那么 d 就是 map[i]，如果我先更新 hash，假设 key 为 d 的开始没有，那么就在 hash 中加入的 <code>&#123;d, 1&#125;</code>，再更新 res 即为 res+1。但是这样是对的吗？显然不对！我要找的 k 是 0，但是我再 i 之前的 map 没有任何值是和 map[i]相等，理论上以 map[i]结尾是构造不了符合条件的子串，但是这里却+1，这是不对的。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">// map[i]表示nums[0~i-1]</span></span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            map[i] = map[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();     </span><br><span class="line">        hash.put(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 表示和为k的本身就有1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> map[i]-k;    <span class="comment">// 当前值和k之间的差距，现在就看在[0,i]之间有没有和为d的，已经存进去的都是有端下标小于i的</span></span><br><span class="line">            res += hash.getOrDefault(d, <span class="number">0</span>);      <span class="comment">// hash中key为d的val：表示[0,i)中前缀和为d的数量。如果map[j]=d，那么意思是(j,i]的和为k</span></span><br><span class="line">            hash.put(map[i], hash.getOrDefault(map[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="任务调度器">621. 任务调度器⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303170922304.png" /></p>
<p>中等题，思路很妙！<strong>思路：</strong></p>
<ol type="1">
<li>将任务按类型分组，正好 A-Z 用一个 int[26]保存任务类型个数</li>
<li>对数组进行排序（因为我们实际上对到底是 A5 个还是 B5 个不感兴趣，我们只需要有某个单词出现 5 次即可），优先排列个数（count）最大的任务，如题得到的时间至少为 res =（count-1）* (n+1) + 1 ==&gt; <code>A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A</code> (X 为其他任务或者待命)。</li>
<li>再排序下一个任务，如果下一个任务 B 个数和最大任务数一致，则 res++ ==&gt; <code>A-&gt;B-&gt;X-&gt;A-&gt;B-&gt;X-&gt;A-&gt;B</code></li>
<li>对于空位还满足的，直接插进去即可。（你可能会觉得，如果剩下的空位不能满足 n 的条件怎么办，就像在 n=2 的情况下，在 <code>ABCABCABCAxxA</code> 时候还有 2 个 D，但是剩下的空间不能满足，这时候只需要稍微调整已经排序的位置即可，也就是变成 <code>ABCBACBABxACx</code>，那么两个 D 就能顺利插进去）</li>
<li><strong>如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于 n，在这种情况下就是任务的总数是最小所需时间</strong></li>
<li>最后返回的实际上就是 res 和所有单词的个数的最大值，所有单词个数实际上就是 tasks 的长度。</li>
</ol>
<p><strong>代码如下：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] words = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tasks) &#123;</span><br><span class="line">            words[c-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(words);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (words[<span class="number">25</span>] - <span class="number">1</span>) * (n+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; words[j]==words[<span class="number">25</span>]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res,tasks.length); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="回文子串">647. 回文子串⭐</h1>
<h2 id="中心扩张法">中心扩张法</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303151020749.png" />.</p>
<p>中等题，其实思路很简单，就是确定一个中间，两边同时扩张。</p>
<p>中心需要分类讨论，如果中心是 1 个元素，那么扩张后的元素个数都是奇数；如果中心是 2 个元素，那么扩张后的元素个数都是偶数。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//中心</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i, end = i;</span><br><span class="line">            <span class="keyword">while</span> (start&gt;=<span class="number">0</span> &amp;&amp; end&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[start] == sc[end]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    start--;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i, end = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start&gt;=<span class="number">0</span> &amp;&amp; end&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[start] == sc[end]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    start--;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数组中的-k-diff-数对">532、数组中的 k-diff 数对</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626711.png" alt="image-20221009161302609" /><figcaption aria-hidden="true">image-20221009161302609</figcaption>
</figure>
<p>本题思路，先将数组升序。</p>
<p>设置一个i和j，注意 i 如果遇到重复的就跳过，j是找 nums[i]+k 的值，对于越来越大的i，如果他的j存在，那么一定再前一个i的j的后面。</p>
<p>但是需要注意的是i可能会跑到j后面，所以每次要对j做判断是否需要更新位置。</p>
<h1 id="二叉树中第二小的节点">671、二叉树中第二小的节点</h1>
<h2 id="方法一替换法">方法一、替换法</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626712.png" alt="image-20221008121811267" /><figcaption aria-hidden="true">image-20221008121811267</figcaption>
</figure>
<p>更新新的最小值，实际上也是遍历整个数，逻辑相对复杂一些。</p>
<p>核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLeaf(root)) &#123;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == temp &amp;&amp; b == temp) &#123;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == temp) &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == temp) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二dfs">方法二、DFS</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626713.png" alt="image-20221008121848938" /><figcaption aria-hidden="true">image-20221008121848938</figcaption>
</figure>
<p>利用DFS深度优先搜索，提前设置好全局变量记录最小和第二小的值，DFS遍历整个树，找到第二小的值。</p>
<p><strong>DFS的使用方法：void函数，当root==null时return;，否则调用dfs(root.left)和dfs(root.right)，当全部遍历完后，全局变量也被修改了</strong></p>
<h1 id="设计链表">707、设计链表</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626714.png" alt="image-20220923102230396" /><figcaption aria-hidden="true">image-20220923102230396</figcaption>
</figure>
<p>Java语言使用链表格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = head;</span><br><span class="line">        head.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">MyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">linkedList.get(<span class="number">1</span>);    </span><br></pre></td></tr></table></figure>
<h1 id="买卖股票的最佳时机含手续费">714、买卖股票的最佳时机含手续费⭐</h1>
<h2 id="方法一贪心">方法一、贪心</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626715.png" alt="image-20221027164450020" /><figcaption aria-hidden="true">image-20221027164450020</figcaption>
</figure>
<p>比较晦涩难懂，对left的定义很重要，特别是在<code>prices[i]&gt;left+fee</code>情况的left改变比较难。看代码理解吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&lt;left) &#123;   <span class="comment">// prices[i]+fee &lt; left+fee</span></span><br><span class="line">                left = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i]&gt;left+fee) &#123;    <span class="comment">//如果后面的减去left和fee依然有收益，那就可以尝试将股票卖出</span></span><br><span class="line">                sum += prices[i]-left-fee;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//但是为了防止遇到的是局部最优：</span></span><br><span class="line">                <span class="comment">// left       prices[i]          prices[i+1]</span></span><br><span class="line">                <span class="comment">//实际上的真实收益应该是：prices[i+1]-left-free</span></span><br><span class="line">                <span class="comment">// prices[i]-left-free    + 一个收益   =   prices[i+1]-left-free</span></span><br><span class="line">                <span class="comment">// 解得这个收益为：prices[i+1]-prices[i]</span></span><br><span class="line">                <span class="comment">// 但是 sum += prices[i+1]-prices[i]-fee;，所以left应该设定为prices[i]-fee</span></span><br><span class="line"></span><br><span class="line">                left = prices[i]-fee;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划-1">方法二、动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626716.png" alt="image-20221027164704099" /><figcaption aria-hidden="true">image-20221027164704099</figcaption>
</figure>
<p>唉，动态规划，容易理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][0]表示i天结束后手上没有股票的最大收益</span></span><br><span class="line">        <span class="comment">//dp[i][1]表示i天结束后手上有一张股票的最大收益</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];    </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化">优化</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626717.png" alt="image-20221027165234692" /><figcaption aria-hidden="true">image-20221027165234692</figcaption>
</figure>
<p>动态规划常规优化喽~</p>
<h1 id="每日温度">739. 每日温度</h1>
<h2 id="方法一单调栈">方法一、单调栈⭐</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303150918217.png" /></p>
<p>如果本题使用从后往前进行遍历，每次循环内嵌套循环，必然会超出时间复杂度，因此不能只用简单得线性查找，需要使用新的查找技术——<strong>单调栈</strong>。</p>
<p><strong>应用场景：</strong> 在一个一维数组中，找到某个数得左边或者右边第一个最小或者最大得元素位置。</p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">题解</a></p>
<p>本题需要找右边第一个大于它的元素与它的距离。如果栈为空，则直接放入当前元素的下标；如果不为空，我们需要拿当前元素依次与栈顶元素的进行比较，如果当前元素比栈顶元素大，表示它是栈顶元素之后第一个大于栈顶元素的值，那么栈顶元素出栈，他们俩之间的距离就是栈顶元素下标的结果，再继续循环上述步骤，直到当前元素比栈顶元素小，则表示栈顶元素之后的都更小，那么直接将当前元素下标入栈。当全部遍历完后，如果栈内还有元素，表示这些元素没有遇到比他们更大的，那么依次出栈，并在对应值上设置为 0。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> temperatures[i];</span><br><span class="line">            <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dq.peekLast();</span><br><span class="line">                <span class="keyword">if</span> (temperatures[j] &lt; k) &#123;</span><br><span class="line">                    res[j] = i - j;</span><br><span class="line">                    dq.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            res[dq.pollLast()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除并获得点数">740、删除并获得点数⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626718.png" alt="image-20221017202842714" /><figcaption aria-hidden="true">image-20221017202842714</figcaption>
</figure>
<p>题目中说的是如果选取i值，就不能选取所有的i-1和i+1。</p>
<p>这看似是涉及到左右，但是实际上只要考虑左边就行了。</p>
<p>考虑每个值选还是不选即可（变成了<code>198、打家劫舍</code>小偷问题）。</p>
<h1 id="使用最小花费爬楼梯">746、使用最小花费爬楼梯</h1>
<h2 id="方法一动态规划-1">方法一、动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626719.png" alt="image-20221016212056771" /><figcaption aria-hidden="true">image-20221016212056771</figcaption>
</figure>
<p>注意找到规律：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dp[i] = Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<h3 id="尝试优化空间">尝试优化空间</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626720.png" alt="image-20221016214807512" /><figcaption aria-hidden="true">image-20221016214807512</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    temp = Math.min(b+cost[i-<span class="number">1</span>],a+cost[i-<span class="number">2</span>]);</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure>
<p>但是奇怪的是更慢了</p>
<h1 id="最多能完成排序的块">769、最多能完成排序的块⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626721.png" alt="image-20221014091237039" /><figcaption aria-hidden="true">image-20221014091237039</figcaption>
</figure>
<p>思路：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-chunks-to-make-sorted/solutions/1888391/by-ac_oier-4uny/">769. 最多能完成排序的块 - 力扣（Leetcode）</a></p>
<p>注意题干：它表示在 <code>[0, n - 1]</code> 范围内的整数的排列，表示这n个数是0~n-1。</p>
<p>思路：所以这个数组的下标就是整体排序好的数值。</p>
<p>因此我们可以从头到尾遍历，记录最左边的值和最右边的值，记录在这一段中的max和min，当且仅当max==当前块的最右边值的下标且min==当前块的最左值的下标时，这一块结束。</p>
<p>此时最左边的下标更新为max的值+1，再将min和max都初始化。</p>
<h1 id="在lr字符串中交换相邻字符">777、在LR字符串中交换相邻字符⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626722.png" alt="image-20221002122050879" /><figcaption aria-hidden="true">image-20221002122050879</figcaption>
</figure>
<p>思路：</p>
<p>由题意可以知道，L是可以穿过X向左移动，R可以穿过X向右移动，但是L和R都无法互相穿过。因此，单纯地觉得只要将start和end去掉所有的X只要相等就返回true，像下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canTransform</span><span class="params">(String start, String end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start.length() != end.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> start.length();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(i) != <span class="string">&#x27;X&#x27;</span> ) &#123;</span><br><span class="line">                sb1.append(start.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end.charAt(i) != <span class="string">&#x27;X&#x27;</span> ) &#123;</span><br><span class="line">                sb2.append(end.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb1.toString().equals(sb2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而出现了一个不可忽略的错误：</p>
<blockquote>
<p>例：</p>
<p>"LXXLXRLXXL"</p>
<p>"XLLXRXLXLX"</p>
</blockquote>
<p>题意是：<code>XL ==&gt; LX；RX ==&gt; XR</code> 。</p>
<p>按照上面代码所述，不仅可以XL变为LX，也可以LX变为XL，这是不合题意的！</p>
<p>因此需要增加一个限定条件，即<strong>start中的L要比end中对应的L的下标要大，start中的R要比end中对应的R的下标要小。</strong></p>
<p>所以，不能使用一次循环，需要使用双指针进行判断。</p>
<p>新代码思路是：</p>
<p>对于i和j分别指向start和end字符串，每次分别找一个非X字符，如果相同且满足i和j的关系的，则i++和j++；如果不满足直接返回false。这样的匹配规则，如果是可以完成匹配的，应该是i和j在某一次循环内同时到达终点，<strong>不会存在i卡在某个非X字符，j已经到了终点</strong>，如果是这种情况（即只有一个到了终点的），则之间判断i和j是否相等，如果相等，则返回true，不相等则返回false。</p>
<h1 id="第k个语法符号">779、第K个语法符号</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626724.png" alt="image-20221020103345966" /><figcaption aria-hidden="true">image-20221020103345966</figcaption>
</figure>
<p>本题使用递归思想，不算很难，但是需要找到规律。</p>
<blockquote>
<p>第一行：0</p>
<p>第二行：<strong>0</strong>1</p>
<p>第三行：<strong>01</strong>10</p>
<p>第四行：<strong>0110</strong>1001</p>
<p>第五行：<strong>01101001</strong>10010110</p>
</blockquote>
<p>发现什么了！</p>
<p><strong>每一行的前一半字符是上一行的完整字符。</strong></p>
<p><strong>每一行的后一半字符是前一半字符的取反，也就是上一行的完整字符取反。</strong></p>
<p>那结果很明显了！</p>
<p>使用递归的思想，找到k在这一行的位置，用位运算轻松得到每一行的len。在前半段，它的值就等于上一行的k的位置；在后半段，那它的值就等于上一行的(k-len/2)的位置的值的<strong>取反</strong>。当然这里不是二进制，取反有风险，if判断一下喽！</p>
<p>完美解决~</p>
<h1 id="旋转数字">788、旋转数字</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626725.png" alt="image-20220925165535500" /><figcaption aria-hidden="true">image-20220925165535500</figcaption>
</figure>
<h1 id="匹配子序列的单词数">792、匹配子序列的单词数</h1>
<h2 id="方法一暴力微优化">方法一、暴力+微优化</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626789.png" alt="Screenshot_20221117_093435_com.huawei.browser" /> 对words中的每个字符进行判断，加入一定的提前跳出判断，勉强不超时（不推荐）。</p>
<h2 id="方法二首字母队列">方法二、首字母+队列</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626790.png" alt="Screenshot_20221117_094650_com.huawei.browser" /><figcaption aria-hidden="true">Screenshot_20221117_094650_com.huawei.browser</figcaption>
</figure>
<p>很妙！直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">	<span class="comment">// 将words中的每个word根据首字母进行分类 </span></span><br><span class="line">	<span class="comment">// 设计一个容器，存储以26个字母开头的字符串，这里选择用队列 </span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String s, String[] words)</span> &#123; </span><br><span class="line">		Deque&lt;String&gt;[] dq = <span class="keyword">new</span> <span class="title class_">Deque</span>[<span class="number">26</span>]; </span><br><span class="line">		<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 初始化 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123; </span><br><span class="line">			dq[i] = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 初始化加入，将所有字符串根据首字母分类 </span></span><br><span class="line">		<span class="keyword">for</span> (String word : words) &#123; </span><br><span class="line">			dq[word.charAt(<span class="number">0</span>)-<span class="string">&#x27;a&#x27;</span>].addLast(word); </span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> sc : s.toCharArray()) &#123; <span class="comment">// 顺序遍历s的每个字母 </span></span><br><span class="line">			<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> dq[sc-<span class="string">&#x27;a&#x27;</span>].size(); </span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123; </span><br><span class="line">				<span class="comment">// 对以当前字母开头的字符串判断 </span></span><br><span class="line">				<span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> dq[sc-<span class="string">&#x27;a&#x27;</span>].pollFirst(); </span><br><span class="line">				<span class="keyword">if</span> (p.length()==<span class="number">1</span>) &#123; <span class="comment">// 表示只有它本身 </span></span><br><span class="line">					sum++; </span><br><span class="line">				&#125; </span><br><span class="line">				<span class="keyword">else</span> &#123; </span><br><span class="line">					dq[p.charAt(<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>].addLast(p.substring(<span class="number">1</span>)); <span class="comment">//将除去第一个字符的剩下的字符串再次根据首字母加入 </span></span><br><span class="line">				&#125; </span><br><span class="line">			&#125; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">return</span> sum; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="旋转字符串">796、旋转字符串</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626726.png" alt="image-20221014092503892" /><figcaption aria-hidden="true">image-20221014092503892</figcaption>
</figure>
<p>最长对的思路就是：两个字符串合并，如果在其中<code>contains()</code>，那么就存在。</p>
<h1 id="香槟塔">799、香槟塔</h1>
<h2 id="方法一动态规划模拟">方法一、动态规划（模拟）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626791.png" alt="Pasted image 20221120093751" /><figcaption aria-hidden="true">Pasted image 20221120093751</figcaption>
</figure>
<p>虽然是动态规划，确实不好想，但是想通了很简单。</p>
<p>我们可以假设第一次<strong>将所有的香槟都倒在第一层的杯里，然后从第一层开始遍历，对于每一个多出来的部分，分给它下面的两个杯子</strong>。</p>
<p>直接构建一个二维数组即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = (<span class="type">double</span>)poured;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=query_row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i; j++) &#123;       <span class="comment">//i行j列（都是从0开始）</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">half</span> <span class="operator">=</span> (dp[i][j]-<span class="number">1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    dp[i][j] = <span class="number">1.0</span>;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j] += half;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] += half;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> dp[query_row][query_glass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化-1">优化</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626792.png" alt="Pasted image 20221120100619" /><figcaption aria-hidden="true">Pasted image 20221120100619</figcaption>
</figure>
<p>也就是将二维数组变成一维数组。</p>
<p>我们可以发现每一层的结构都是依赖上层的结果，所以可以直接设置一维数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[] dp = &#123;poured&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=query_row; i++) &#123;</span><br><span class="line">            <span class="type">double</span>[] temp = <span class="keyword">new</span> <span class="title class_">double</span>[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;       <span class="comment">//i行j列（都是从0开始）</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">half</span> <span class="operator">=</span> (dp[j]-<span class="number">1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    temp[j] += half;</span><br><span class="line">                    temp[j+<span class="number">1</span>] += half;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = temp;              <span class="comment">// 直接指针指向</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(<span class="number">1</span>, dp[query_glass]);     <span class="comment">//可能要求输出的不是最后一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使序列递增的最小交换次数">801、使序列递增的最小交换次数⭐⭐</h1>
<p>难题！</p>
<h2 id="方法一分类讨论动态规划">方法一、分类讨论+动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626727.png" alt="image-20221014093122666" /><figcaption aria-hidden="true">image-20221014093122666</figcaption>
</figure>
<p>本题题目是问要使得两边都是递增，且<strong>同下标交换</strong>需要的最小的次数。</p>
<p>所以一共有三种情况： <strong>第一种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; !(nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>第二种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>]) &amp;&amp; !(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>第三种情况：</strong>下标为i的nums1和nums2的值，比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大，且比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; (nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>构建dp数组：<code>int[][] dp = new int[n][2];</code></p>
<p>第一列对应的是如果这一组不交换所需要的最小次数，第二列对应的是这一组交换所对应的最小次数。</p>
<p>根据这三种情况分别分析对应的操作：</p>
<p><strong>第一种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大。如果选择不交换，那么万事大吉，直接<code>dp[i][0] = dp[i-1][0];</code>；如果要交换，为了满足题目的要求，i-1下标的两个值也要交换，所以<code>dp[i][1] = dp[i-1][1] + 1;</code>。</p>
<p><strong>第二种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。如果选择不交换，为了满足题目意思，需要将i-1下标的两个值交换，所以<code>dp[i][0] = dp[i-1][1];</code>；如果要交换，为了满足题目的要求，i-1下标的就不用交换，所以<code>dp[i][1] = dp[i-1][0] + 1;</code>。</p>
<p><strong>第三种情况：</strong>下标为i的nums1和nums2的值，比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大，且比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。如果选择不交换，只需要取i-1下标交换或者不交换的更小值即可，即<code>dp[i][0] = Math.min(dp[i-1][0],dp[i-1][1]);</code>；如果要交换，取i-1下标交换或者不交换的更小值，再+1即可，即<code>dp[i][1] = Math.min(dp[i-1][0],dp[i-1][1]) + 1;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; (nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; !(nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; (nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二方法一dp数组改变">方法二、方法一dp数组改变</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626728.png" alt="image-20221014104859252" /><figcaption aria-hidden="true">image-20221014104859252</figcaption>
</figure>
<p>将方法一的<code>int[][] dp = new int[n][2];</code>变成<code>int[][] dp = new int[2][n];</code>，其他思路一致。</p>
<p>空间换时间的操作。</p>
<h2 id="方法三优化">方法三、优化</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626729.png" alt="image-20221014105138512" /><figcaption aria-hidden="true">image-20221014105138512</figcaption>
</figure>
<p>只保存i-1状态的两个值即可。</p>
<h1 id="分汤">808、分汤⭐</h1>
<h2 id="方法一dfs记忆化">方法一、DFS+记忆化</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626793.png" alt="Pasted image 20221121112857" /><figcaption aria-hidden="true">Pasted image 20221121112857</figcaption>
</figure>
<p>注意到四种分汤情况都是25的倍数，所以可以先对n进行简化</p>
<p>然后进行dfs， 当<code>i≤0 &amp;&amp; j≤0</code>时，表示两种汤都分配完了，此时应该返回 <code>0.5</code>； 当 <code>i≤0</code> 时，表示汤 A 先分配完了，此时应该返回 <code>1</code>； 当 <code>j≤0</code> 时，表示汤 B 先分配完了，此时应该返回 <code>0</code>。</p>
<p><code>double ans = 0.25 * (dfs(i - 4, j) + dfs(i - 3, j - 1) + dfs(i - 2, j - 2) + dfs(i - 1, j - 3));</code></p>
<p>但是需要注意，之这样写一定会显示时间超出</p>
<h3 id="优化1">优化1</h3>
<p>加入记忆化方式，也就是加入一个数组，记录在A有i和B有j的情况下的概率信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (memo[i][j]==<span class="number">0</span>) &#123;</span><br><span class="line">	<span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.25</span> * (dfs(i-<span class="number">4</span>,j) + dfs(i-<span class="number">3</span>,j-<span class="number">1</span>) + dfs(i-<span class="number">2</span>,j-<span class="number">2</span>) + dfs(i-<span class="number">1</span>,j-<span class="number">3</span>));</span><br><span class="line">	memo[i][j] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是仍然会出现空间超出</p>
<h3 id="优化2">优化2</h3>
<p>借助数学的方式，在<code>n=4800</code>时，结果为0.999994994426，而题目要求的精度为<span class="math inline">\(10^{-5}\)</span>，并且随着n的增大，结果越来越接近1，因此，当<code>n&gt;4800</code>时，直接返回1即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n&gt;=<span class="number">4800</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整代码">完整代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">double</span>[][] memo;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">0</span> &amp;&amp; j&lt;=<span class="number">0</span>) &#123;    <span class="comment">//表示都分配完了  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (j&lt;=<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//记忆化（否则会超出时间）  </span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j]==<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.25</span> * (dfs(i-<span class="number">4</span>,j) + dfs(i-<span class="number">3</span>,j-<span class="number">1</span>) + dfs(i-<span class="number">2</span>,j-<span class="number">2</span>) + dfs(i-<span class="number">1</span>,j-<span class="number">3</span>));  </span><br><span class="line">            memo[i][j] = sum;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> memo[i][j];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 在 10-5 下接近1，所以直接输出1即可（否则会超出空间）  </span></span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">4800</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        n = (n+<span class="number">24</span>)/<span class="number">25</span>;     <span class="comment">//如果一开始给的汤不是25的倍数，就向上取整（多出来的一部分也可以分配）  </span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">return</span> dfs(n,n);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划-2">方法二、动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626794.png" alt="Pasted image 20221121115908" /><figcaption aria-hidden="true">Pasted image 20221121115908</figcaption>
</figure>
<p>动态规划难在初始化。本题需要一个二维数组进行动态规划。</p>
<ol type="1">
<li><p>表示A和B都没有了</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.5</span>;     </span><br></pre></td></tr></table></figure></p></li>
<li><p>表示A没有了</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">	dp[<span class="number">0</span>][i] = <span class="number">1</span>;     <span class="comment">//表示A没有 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>表示B没有了（B没有返回0，所以根据初始化自动为0）</p></li>
</ol>
<h3 id="完整代码-1">完整代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">4800</span>) &#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = (n+<span class="number">24</span>)/<span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.5</span>;     <span class="comment">//表示A和B都没有了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;     <span class="comment">//表示A没有 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;      <span class="comment">//当j=0时就是0，而数组初始化时自动为0</span></span><br><span class="line">                dp[i][j] = <span class="number">0.25</span> * (dp[Math.max(<span class="number">0</span>,i-<span class="number">4</span>)][j] + dp[Math.max(<span class="number">0</span>,i-<span class="number">3</span>)][Math.max(<span class="number">0</span>,j-<span class="number">1</span>)] + dp[Math.max(<span class="number">0</span>,i-<span class="number">2</span>)][Math.max(<span class="number">0</span>,j-<span class="number">2</span>)] + dp[Math.max(<span class="number">0</span>,i-<span class="number">1</span>)][Math.max(<span class="number">0</span>,j-<span class="number">3</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="情感丰富的文字">809、情感丰富的文字</h1>
<h2 id="方法一逐字对比长度加速">方法一、逐字对比+长度加速</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626795.png" alt="Pasted image 20221126195121" /><figcaption aria-hidden="true">Pasted image 20221126195121</figcaption>
</figure>
<p>对每个字符串进行检索，找到当前字符连续的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expressiveWords</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.length() &gt; s.length()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] wc = w.toCharArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;s.length() &amp;&amp; j&lt;w.length()) &#123;    <span class="comment">// i定位s，j定位w</span></span><br><span class="line">                <span class="keyword">if</span> (sc[i] == wc[j]) &#123;    <span class="comment">//如果字符相等</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> sc[i];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i+<span class="number">1</span>)&lt;s.length() &amp;&amp; sc[i+<span class="number">1</span>]==t) &#123;</span><br><span class="line">                        l1++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ((j+<span class="number">1</span>)&lt;w.length() &amp;&amp; wc[j+<span class="number">1</span>]==t) &#123;</span><br><span class="line">                        l2++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l1==l2 || (l1 &gt; l2 &amp;&amp; l1 &gt;= <span class="number">3</span>)) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isFind = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isFind = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==s.length() &amp;&amp; j == w.length() &amp;&amp; isFind) &#123;</span><br><span class="line">                sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子域名访问计数">811、子域名访问计数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626730.png" alt="image-20221005111235484" /><figcaption aria-hidden="true">image-20221005111235484</figcaption>
</figure>
<p>本题逻辑简单，但是涉及很多java语法知识。</p>
<h3 id="hashmap散列表">HashMap（散列表）</h3>
<p>创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line">添加键值对</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">hash.put(<span class="string">&quot;abc&quot;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>查找值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.get(<span class="string">&quot;abc&quot;</span>);    <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure>
<p>更新值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.replace(<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>);    <span class="comment">//以后hash里面&quot;abc&quot;对应的value就是3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.replace(<span class="string">&quot;abc&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">//只对hash键值对为&quot;abc&quot;-2的修改value为3，如果键值对不符合则返回false</span></span><br></pre></td></tr></table></figure>
<p>查找键值对数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.size()</span><br></pre></td></tr></table></figure>
<p>判断是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.isEmpty()    <span class="comment">//如果为空返回true</span></span><br></pre></td></tr></table></figure>
<p>判断是否有某个key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.containsKey(<span class="string">&quot;abc&quot;</span>)    <span class="comment">//如果有则返回true</span></span><br></pre></td></tr></table></figure>
<p>判断是否有某个value</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.containsValue(<span class="number">3</span>)    <span class="comment">//如果有则返回true</span></span><br></pre></td></tr></table></figure>
<p>遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一、forEach</span></span><br><span class="line">hash.forEach((key,value)-&gt; &#123;</span><br><span class="line">    <span class="comment">//对于每一组key和value的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> value.toString() + key;</span><br><span class="line">    res.add(s);</span><br><span class="line">&#125;);    <span class="comment">//不要忘记分号</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二、最推荐，遍历entey获取key和value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;  <span class="comment">//entrySet()返回hashMap中所有映射项的集合集合视图。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三、单独取出key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : hash.KeySet()) &#123;    <span class="comment">//keySet()返回hashMap中所有key组成的集合视图。</span></span><br><span class="line">    <span class="comment">//对key操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String value : hash.values()) &#123;    <span class="comment">//values()返回hashMap中所有value组成的集合视图。</span></span><br><span class="line">    <span class="comment">//对key操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除所有键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.clear();</span><br></pre></td></tr></table></figure>
<h3 id="字符串按空格分割">字符串按空格分割</h3>
<p>对于<code>String s = "a  b     c  d e f      g"</code></p>
<p>分割单个空格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//遍历输出后：</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="comment">//e</span></span><br><span class="line"><span class="comment">//f</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//g</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>分割多个连续空格</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = s.split(<span class="string">&quot;\\s+&quot;</span>);    <span class="comment">//正则</span></span><br><span class="line"><span class="comment">//遍历后：</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="comment">//e</span></span><br><span class="line"><span class="comment">//f</span></span><br><span class="line"><span class="comment">//g</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串转为整数">字符串转为整数</h3>
<p>使用<code>Integer.parseInt(s)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(s);</span><br></pre></td></tr></table></figure>
<h3 id="长度函数">长度函数</h3>
<ol type="1">
<li><p><code>length</code>：<strong>数组</strong>长度</p></li>
<li><p><code>length()</code>：<strong>字符串</strong>长度</p></li>
<li><p><code>size()</code>：<strong>列表</strong>长度</p></li>
</ol>
<h3 id="list的构建">List的构建</h3>
<p>对于单个List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>对于嵌套List</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; ll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="链表组件">817、链表组件</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626731.png" alt="image-20221009164428565" /><figcaption aria-hidden="true">image-20221009164428565</figcaption>
</figure>
<p>先用一个容器将nums里的所有数值全都存储起来，之后在遍历链表判断当前值是否在nums数组中。</p>
<p>什么样的容器具有这样的功能呢？String？Map？对！Map最合适！</p>
<p>所以我们选择HashMap,和他的containsKey（也可以使用containsValue）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Boolean&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Boolean&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    hash.put(num,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (hash.containsKey(p.val)) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再判断有多少个组件，常规思路。</p>
<h1 id="隐藏个人信息">831. 隐藏个人信息</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304011156916.png" /></p>
<p>中等题，简单构造题。</p>
<h1 id="考场就座">855. 考场就座⭐</h1>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/exam-room/solutions/2037441/liang-chong-jie-fa-you-xu-ji-he-you-xian-bjrv/">题解</a></p>
<h2 id="方法一有序集合">方法一、有序集合</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626796.png" alt="Pasted image 20221230231503" /><figcaption aria-hidden="true">Pasted image 20221230231503</figcaption>
</figure>
<p>考察<a href="LeetCode总结笔记.md#有序集合TreeSet">有序集合 TreeSet</a> 的应用。</p>
<p>思路其实并不复杂，对于 leave 其实就是 remove () 函数；对于 seat 其实就是判断<strong>每一段之间的距离的一半</strong>和<strong>最左边与左端点的距离</strong>和<strong>最右边与右端点的距离</strong>的最大值。如果是段之间的距离更大，那么点就在段中点；如果左边的距离更大，那么点就在 0；如果右边距离更大，那么点就在 n-1。</p>
<p>此外还需要注意局部变量和全局变量之间的转换。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExamRoom</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义全局变量</span></span><br><span class="line">    TreeSet&lt;Integer&gt; ts;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExamRoom</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.n = n;      <span class="comment">//将局部变量转为全局变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">seat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ts.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            ts.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当有一个时，第二个需要放在最后</span></span><br><span class="line">        <span class="comment">//但是需要考虑如果一开始放了两个，但是把第一个leave，只有最后一个了，应该怎么处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从左向右遍历每一段之间的最短（暂时不考虑两端）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ts.first();</span><br><span class="line">        <span class="type">int</span> <span class="variable">disl</span> <span class="operator">=</span> ts.first()-<span class="number">0</span>;           <span class="comment">//初始为最左边离左端点的距离，变量表示两个向量之间的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">inx</span> <span class="operator">=</span> <span class="number">0</span>;                     <span class="comment">//要放置的位置，初始是0，是考虑到端点没有放，但是中间有值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : ts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disl &lt; (x-left)/<span class="number">2</span>) &#123;</span><br><span class="line">                disl = (x-left)/<span class="number">2</span>;</span><br><span class="line">                inx = (x+left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时得到的disl表示 左边距离左端点 和 每一段之间若放置的两边的距离的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">disr</span> <span class="operator">=</span> n-<span class="number">1</span>-ts.last();        <span class="comment">//表示最右边距离右端点的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (disl &lt; disr) &#123;    <span class="comment">//表示最右边距离右端点的距离最大，应该放置在右端点处</span></span><br><span class="line">            inx = n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.add(inx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leave</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        ts.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二有序集合优先队列">方法二、有序集合+优先队列</h2>
<p>见题解。</p>
<h1 id="括号的分数">856、括号的分数</h1>
<h2 id="方法一栈">方法一、栈</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626732.png" alt="image-20221009165925676" /><figcaption aria-hidden="true">image-20221009165925676</figcaption>
</figure>
<p>遇到括号匹配，第一时间想到什么？——栈！！</p>
<p><strong>但是Java没有栈，只能用Deque双端队列代替。</strong></p>
<p>需要多次使用的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line">Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">dq.addLast(st);</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出并返回</span></span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> dq.pollLast();</span><br></pre></td></tr></table></figure>
<h3 id="拓展-1">拓展：</h3>
<p>String的相等操作： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2);</span><br></pre></td></tr></table></figure></p>
<p>char的相等操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 == c2;</span><br></pre></td></tr></table></figure>
<p>char转为String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> String.valueOf(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>char转为int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>String转为int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = Integer.parseInt(<span class="string">&#x27;23&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="方法二一次遍历">方法二、一次遍历⭐</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626733.png" alt="image-20221009170918190" /><figcaption aria-hidden="true">image-20221009170918190</figcaption>
</figure>
<p>这个方法思路真的很妙！</p>
<ol type="1">
<li><p>首先，所有的<code>()</code>都是<code>1</code>，所以用replace将<code>()</code>换成<code>1</code></p></li>
<li><p>对s进行遍历，遇到1个<code>(</code>，则对于后面的1乘以2，遇到<code>)</code>，则对后面的1除以2</p>
<blockquote>
<p><strong>例子：((())(())())</strong></p>
<p>可以看出这题的结果时：(1*2 + 1*2 + 1)*2 = 1*2*2 + 1*2*2 + 1*2</p>
<ol type="1">
<li><p>替换：((1)(1)1)</p></li>
<li><p>从左遍历，第一个1左边有2个(、0个)，所以对于1*2*2</p>
<p>第二个1左边有3个(、1个)，所以对于1*2*2*2/2 = 1*2*2</p>
<p>第三个1左边有3个(、2个)，所以对于1*2*2*2/2/2 = 1*2</p></li>
</ol>
</blockquote></li>
</ol>
<p>注意：<code>连续乘以n个2</code>的操作，可以用<code>number &lt;&lt; n</code>表示。</p>
<h1 id="和至少为k的最短子数组">862、和至少为K的最短子数组⭐⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626734.png" alt="image-20221026215844261" /><figcaption aria-hidden="true">image-20221026215844261</figcaption>
</figure>
<p>很难且恶心人的一题。</p>
<p>贴上我的心路历程：</p>
<p>一开始我是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>]&gt;=k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;=k) &#123;</span><br><span class="line">                    min = Math.min(min,step);</span><br><span class="line">                    temp -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                    step--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp += nums[j];</span><br><span class="line">                    step++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;=k) &#123;</span><br><span class="line">                    min = Math.min(min,step);</span><br><span class="line">                    temp -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                    step--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                    step--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==<span class="number">100001</span> ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后来发现，如果出现 k=5， 1, -2, 2, 7这种情况就没法找到真正的最短。</p>
<p>然后我使用双层for循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] preadd = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];    <span class="comment">//记录当前i以前的元素的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            preadd[i] = preadd[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j-i&gt;=min) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (preadd[j]-preadd[i]&gt;=k) &#123;</span><br><span class="line">                    min = Math.min(min,j-i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==<span class="number">100001</span> ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，根据题解……我转换了思路。⭐</p>
<p>以每个元素为开始的最短的长度是一定的</p>
<p>preadd的作用看代码能懂吧，所以以i为开始的满足条件的数组的长度就是<code>preadd[j]-preadd[i]</code>，长度就是<code>j-i</code>。</p>
<p>利用一个for循环控制结束的字符，用一个队列控制开始的字符。（其实数组也可，但是会慢些）</p>
<p>第一个while是确定结束位置，依次更新初始位置。</p>
<p>第二个while是对结束位置的左边进行筛选，为了减少复杂度，如果它的相邻左边的preadd比它的preadd要大，根据<code>preadd[j]-preadd[i]</code>，如果preadd[i]要比preadd[i-1]小，那么以某个j结尾的，一定会选择i而不会以i-1开头，所以在这里可以删掉i-1了。</p>
<p>每次都将当前j加入队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[] preadd = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];    <span class="comment">//记录当前i以前的元素的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            preadd[i] = preadd[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];     <span class="comment">//存的是当前值之前的所有的和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> n+<span class="number">1</span>;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();    <span class="comment">//dq存的是需要查询的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n+<span class="number">1</span>;j++) &#123;     <span class="comment">//以i为结尾，以dq.pollFirst()为开始</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; preadd[j]-preadd[dq.peekFirst()]&gt;=k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                min = Math.min(min,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; preadd[dq.peekLast()]&gt;=preadd[j]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==n+<span class="number">1</span> ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优势洗牌">870、优势洗牌⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626735.png" alt="image-20221009202231681" /><figcaption aria-hidden="true">image-20221009202231681</figcaption>
</figure>
<p>本题思路简单，但是操作困难，需要知道如何保证不动nums2的前提下，根据其值对其下标进行排序的方法</p>
<p>这里涉及到sort的匿名函数表达式的知识点： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] index = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    index[i] = i;     <span class="comment">//此时index的值对应nums2的每个值的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点：对index排序，排序的规则是对于index的值a和b，如果nums2[a]&gt;nums2[b]，则a在b后面</span></span><br><span class="line">Arrays.sort(index,(a,b)-&gt;nums2[a]-nums[b]);</span><br><span class="line"><span class="comment">//这里的意思是，如果nums[a]-nums[b]&gt;0，返回的是1，表示前者更大，按照我们的约定，应该将b放在a前面</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是：</p>
<ol type="1">
<li>使用匿名表达式的数组必须是原始数组，也就在这里index数组是不能是int，只能是Integer</li>
<li><code>Arrays.sort(index,(a,b)-&gt;function);</code>表示的是对于<code>index数组</code>而言，只有当<code>function&gt;0</code>时，会将<code>(a,b)</code>变成<code>(b,a)</code></li>
</ol>
<p>关于sort函数复写排序规则，还有一种更加常规的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(index, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;       <span class="comment">//注意index一定要是Integer（不能是int）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;       <span class="comment">//注意是和上面的In&#x27;te&#x27;g</span></span><br><span class="line">        <span class="keyword">if</span> (nums2[a] &gt; nums2[b]) &#123;    <span class="comment">//按照要求，a应该在b后面，也就是要从(a,b)变成(b,a)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;         <span class="comment">//return 1表示调换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;       <span class="comment">//return -1表示保持不变</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="第n个神奇数字">878、第N个神奇数字⭐🌟</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626736.png" alt="image-20221009172307797" /><figcaption aria-hidden="true">image-20221009172307797</figcaption>
</figure>
<p>这题思路很巧妙，我们会第一时间想到找到所有的满足条件的数，直到第ｎ个，但是这样的工作量真的太大了，应为涉及到加法和乘法。</p>
<p>所以我们不妨换个思路，在很大的范围内，找到这个符合条件的数。</p>
<ol type="1">
<li><p>首先确定搜索方法，一般查找都会选择<strong>二分查找</strong>，效率高。</p></li>
<li><p>再确定范围，起点范围0，终点范围呢？其实用<code>max(a,b)*n</code>或者<code>min(a,b)*n</code>都可以。但是通过测试，我们的目标值其实更接近<code>min(a,b)*n</code>，但是正因为这样，如果使用<code>min(a,b)*n</code>，需要更多步骤才能找到，所以我们选择<code>max(a,b)*n</code>。</p></li>
<li><p>那判断是否为目标数值的条件呢？</p>
<p>我们通过小数找规律，可以发现，第n个符合规则的数一定是</p>
<p><code>num/a + num/b - num/gbs(a,b) == n</code>，可以好好揣摩一下这个规则。</p>
<p>但是并不是只有我们目标的那个第n个符合规则的数满足，第n和第n+1个数之间的数都满足，所以我们需要找到符合这个条件的最左值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心代码，判断一个数是不是我们要的第n个数</span></span><br><span class="line">    <span class="keyword">if</span> (mid/a + mid/b - mid/gbs_num &lt; n) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">//注意：当在第n~n+1个数之间的所有数都满足这个条件（因为/只保留了商），因此我们需要找到第一个满足这个条件的数</span></span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>最后返回<code>left%MOD</code>即可。</p></li>
</ol>
<p>（找最小公倍数，需要找到最小公因数，这个很简单。）</p>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gys</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gys(b,a%b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gbs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a*b/gys(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里使用max或者min都行，但是max内存消耗更少，因为右边界越大，目标就月靠近中间，能更快找到。如果使用min，反而目标靠近边界，复杂度更高。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> (<span class="type">long</span>) Math.max(a,b)*n;      <span class="comment">// 注意Math库返回的是int类型</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">gbs_num</span> <span class="operator">=</span> gbs(a,b);    <span class="comment">//找到最小公倍数</span></span><br><span class="line">        <span class="comment">// System.out.println(gbs_num);</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//核心代码，判断一个数是不是我们要的第n个数</span></span><br><span class="line">            <span class="keyword">if</span> (mid/a + mid/b - mid/gbs_num &lt; n) &#123;     </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//注意：当在第n~n+1个数之间的所有数都满足这个条件（因为/只保留了商），因此我们需要找到第一个满足这个条件的数</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (left%MOD);    <span class="comment">//需要注意：(int)只对后面相邻的数有效，所以别忘了括号。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tips">tips</h4>
<p>一定要注意Math库返回的都是int类型，本题需要转为long型</p>
<h1 id="细分图中的可到达节点">882、细分图中的可到达节点</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="子序列宽度之和">891、子序列宽度之和</h1>
<p>典型数学题目</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626797.png" alt="Screenshot_20221118_105117_com.huawei.browser" /><figcaption aria-hidden="true">Screenshot_20221118_105117_com.huawei.browser</figcaption>
</figure>
<p>仔细分析题目，可以发现子序列只与最大值和最小值有关，和序列的顺序无关。</p>
<p>所以可以先对数组进行排序。</p>
<p>再按照下面思路进行：</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626798.jpg" alt="1 3 5 8_202211181058_07318 1" /><figcaption aria-hidden="true">1 3 5 8_202211181058_07318 1</figcaption>
</figure>
<p>直接看代码更容易理解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            k = (k &lt;&lt; <span class="number">1</span>)%MOD;</span><br><span class="line">            temp = (temp*<span class="number">2</span>%MOD + nums[i-<span class="number">1</span>])%MOD;</span><br><span class="line">            sum = (sum + (nums[i]*(k-<span class="number">1</span>) - temp)%MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="股票价格跨度">901、股票价格跨度⭐</h1>
<h2 id="方法一栈-1">方法一、栈⭐</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626737.png" alt="image-20221021183314076" /><figcaption aria-hidden="true">image-20221021183314076</figcaption>
</figure>
<h4 id="题目翻译">题目翻译</h4>
<p>返回每一天的比这一天的股票价格小于或者等于的连续天数。</p>
<h4 id="思路">思路</h4>
<p>构造一个二元栈：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stock</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于输入的每一个节点，默认day是1。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/online-stock-span/solutions/1910400/-by-muse-77-byhj/">题解</a></p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626738.png" alt="image-20221021183855971" /><figcaption aria-hidden="true">image-20221021183855971</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!st.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Stock</span> <span class="variable">temp</span> <span class="operator">=</span> st.peekLast();</span><br><span class="line">            <span class="keyword">if</span> (price&gt;=temp.price) &#123;</span><br><span class="line">                st.pollLast();</span><br><span class="line">                day = day + temp.day;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.addLast(<span class="keyword">new</span> <span class="title class_">Stock</span>(price,day));</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整代码-2">完整代码</h4>
<p>（面向对象的写法，注意结构体的构造等知识）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Stock&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stock</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stock</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.price = price;</span><br><span class="line">            <span class="built_in">this</span>.day = day;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Stock&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!st.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Stock</span> <span class="variable">temp</span> <span class="operator">=</span> st.peekLast();</span><br><span class="line">                <span class="keyword">if</span> (price&gt;=temp.price) &#123;</span><br><span class="line">                    st.pollLast();</span><br><span class="line">                    day = day + temp.day;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st.addLast(<span class="keyword">new</span> <span class="title class_">Stock</span>(price,day));</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二数组">方法二、数组</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626739.png" alt="image-20221021184036499" /><figcaption aria-hidden="true">image-20221021184036499</figcaption>
</figure>
<p>思路一致。</p>
<p>我们还需要两个指针，分别是index指针，用来指向“待输入股票”；p指针，index指针的前一个指针，用来与“待输入股票”进行price对比用的，如果它的price小于等于“待输入股票”的price，p就会向前移动。</p>
<p>关于p向前移动还有一点需要注意的就是，p向前移动格子的数量，就是days的具体值；当days等于1时，就向前移动1个格子；如果days等于2时，就向前移动2个格子（因为days等于2，说明已经是两个格子聚合过的值了，就不需要重复统计了）。</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626740.png" alt="image-20221021184303533" /><figcaption aria-hidden="true">image-20221021184303533</figcaption>
</figure>
<p>初始化时注意：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    prices = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    days = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三list">方法三、List</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626741.png" alt="image-20221021184138152" /><figcaption aria-hidden="true">image-20221021184138152</figcaption>
</figure>
<p>思路一致。</p>
<h1 id="最大为-n-的数字组合">902、最大为 N 的数字组合⭐⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626742.png" alt="image-20221018223704471" /><figcaption aria-hidden="true">image-20221018223704471</figcaption>
</figure>
<p>非常难的一题，难在实现上！</p>
<h1 id="水果成篮">904、水果成篮</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626743.png" alt="image-20221017104714073" /><figcaption aria-hidden="true">image-20221017104714073</figcaption>
</figure>
<p>构建两个数组，分别记录某一个连续值的值和出现的次数，比较简单。（当然可以将两个数组并为一个二维数组）</p>
<h1 id="子数组的最小值之和">907、子数组的最小值之和⭐⭐</h1>
<h2 id="方法一单调栈动态规划">方法一、单调栈+动态规划</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626744.png" alt="image-20221028190348577" /><figcaption aria-hidden="true">image-20221028190348577</figcaption>
</figure>
<p>维护两个数组，分别维护左边界和右边界（对于下标为i的辐射左范围为left[i]+1（left[i]不在范围内））。</p>
<p>建立一个单调栈，两次遍历数组，更新左边界和右边</p>
<blockquote>
<p>3 4 1 2 5 6</p>
<p>对于1的辐射范围，左边范围长度为3，右边为4 1, 41, 12, 341, 412, 125, 3412, 4125, 1256, 34125, 41256, 341256，共12个</p>
<p>对于4的辐射范围，左边范围长度为1，右边为1 4，共1个</p>
<p>对于6的辐射范围，左边范围长度为1，右边为1 6，共1个</p>
</blockquote>
<p>看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//对于下标为i的辐射左范围为left[i]+1（left[i]不在范围内）</span></span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; arr[i]&lt;arr[dq.peekLast()]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq.isEmpty()) &#123;</span><br><span class="line">                left[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = dq.peekLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dq.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; arr[i]&lt;=arr[dq.peekLast()]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq.isEmpty()) &#123;</span><br><span class="line">                right[i] = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i] = dq.peekLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 4 1 2 5 6</span></span><br><span class="line">        <span class="comment">// 对于1的辐射范围，左边范围长度为3，右边为4</span></span><br><span class="line">        <span class="comment">// 1, 41, 12, 341, 412, 125, 3412, 4125, 1256, 34125, 41256, 341256，共12个</span></span><br><span class="line">        <span class="comment">// 对于4的辐射范围，左边范围长度为1，右边为1</span></span><br><span class="line">        <span class="comment">// 4，共1个</span></span><br><span class="line">        <span class="comment">// 对于6的辐射范围，左边范围长度为1，右边为1</span></span><br><span class="line">        <span class="comment">// 6，共1个</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            sum = (sum + (<span class="type">long</span>)arr[i] * (i-left[i]) * (right[i]-i)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分割数组">915、分割数组</h1>
<h2 id="方法一最小值分割">方法一、最小值分割</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626745.png" alt="image-20221025214008642" /><figcaption aria-hidden="true">image-20221025214008642</figcaption>
</figure>
<p>先找到数组的最小值，最小值包括左边的部分和右边的部分一定需要分开的，如果左边的最大值&lt;=右边的最小值，那么ok，否则对右边部分继续找最小值，继续划分。</p>
<h2 id="方法二两次遍历">方法二、两次遍历</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626746.png" alt="image-20221025220514828" /><figcaption aria-hidden="true">image-20221025220514828</figcaption>
</figure>
<p>先从后向前遍历一遍，用min[i]表示i位置及其以后区域的最小值。</p>
<p>再从前往后遍历一遍，用max记录以当前元素结尾的区域的最大值。</p>
<p>第二次遍历过程中，如果某一次遍历时发现<code>max &lt;= min[i+1]</code>，则i就是分隔符，返回i+1个元素。</p>
<h1 id="环形子数组的最大和">918、环形子数组的最大和⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626747.png" alt="image-20221019211520951" /><figcaption aria-hidden="true">image-20221019211520951</figcaption>
</figure>
<p>本题是<code>53、最大子数组和</code>的加强版。使用的仍然是动态规划的内容。</p>
<h4 id="分析">分析</h4>
<p>本题因为是环形，所以需要考虑两种情况。</p>
<p>情况1：我们的最终答案是<code>53</code>题中的不考虑环的情况。</p>
<p>情况2：我们的答案包含nums的尾部和nums的首部。</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626748.png" alt="image-20221019211933787" /><figcaption aria-hidden="true">image-20221019211933787</figcaption>
</figure>
<h4 id="思路-1">思路</h4>
<p>情况1很简单，直接仿照<code>53</code>题进行即可。</p>
<p>情况2复杂，需要考虑首位，但是首位又是动态的，很麻烦。但是我们能不能换种思路，我们要找到nums的<strong>最小子数组和</strong>min。那么最长的首位组合就是整个nums之和减去这个最小子数组和。</p>
<h4 id="特殊">特殊</h4>
<p>我们需要考虑，如果情况一得到的max小于0，说明整个nums中没有一个元素是&gt;0的，那么直接输出max（矮子当中选将军），它就是最大的那个了。否则表示数组中存在正数，那么输出max和sum-min中的最大值</p>
<h1 id="三等分">927、三等分</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626749.png" alt="image-20221006155904427" /><figcaption aria-hidden="true">image-20221006155904427</figcaption>
</figure>
<p>思路有点复杂，实现不难：</p>
<p>先判断每一组有多少个1，把每个1的下标都放在一个新的数组中，然后判断三组之间对应的1和1之间的距离是否相等，再判断最后一组的最后一个1后的空格其他组是否能满足。</p>
<h1 id="最短的桥">934、最短的桥⭐</h1>
<p>比较难的一题，题目难懂，方法难想到。</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626750.png" alt="image-20221025210227986" /><figcaption aria-hidden="true">image-20221025210227986</figcaption>
</figure>
<h4 id="思路-2">思路</h4>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626751.png" alt="image-20221025210421377" /><figcaption aria-hidden="true">image-20221025210421377</figcaption>
</figure>
<h4 id="代码">代码</h4>
<p>详细的思路看代码更好理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] step = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    Deque&lt;<span class="type">int</span>[]&gt; edge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        edge = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过找到一个岛屿的一块，利用DFS找到这个岛屿的所有块，并标记为2</span></span><br><span class="line">        <span class="comment">//并找到它的边源水域，也标记成为2，并加入edge队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>) &#123;    <span class="comment">//表示已经找到了第一个岛屿的一块了</span></span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                    Mark(grid,i,j);     <span class="comment">//对当前块进行标记为2（通过DFS岛屿标记）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//目前已经扩充一波水域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时第一轮扩充已经完成</span></span><br><span class="line">        <span class="keyword">while</span> (!edge.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edge.size();    <span class="comment">//获取第一个岛屿的边缘水域</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="type">int</span>[] loc = edge.pollFirst();    <span class="comment">//第一个区域的边缘位置</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[]s : step) &#123;    <span class="comment">//对当前位置的四个方向进行扩充</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> loc[<span class="number">0</span>]+s[<span class="number">0</span>], y = loc[<span class="number">1</span>]+s[<span class="number">1</span>];    </span><br><span class="line">                    <span class="keyword">if</span> (!isLegal(x,y,grid.length)) &#123;       <span class="comment">//如果位置不合法</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;    <span class="comment">//表示已经找到了另一个岛屿</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">0</span>) &#123;    <span class="comment">//扩充水域</span></span><br><span class="line">                        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        edge.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Mark</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLegal(i,j,grid.length)) &#123;    <span class="comment">//如果不是合法位置，退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]==<span class="number">2</span>) &#123;    <span class="comment">//如果是同一个岛屿且已经被标记，退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>) &#123;     <span class="comment">//如果是同一个岛屿但是还没有被标记</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[]s : step) &#123;</span><br><span class="line">                Mark(grid,i+s[<span class="number">0</span>],j+s[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]==<span class="number">0</span>) &#123;     <span class="comment">//如果遇到水域，则表示已经到了这个岛屿的边界了，将这个水也变成岛屿的一部分，在存储边界水域的edge中添加</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line">            edge.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLegal</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span> &#123;    <span class="comment">//判断是否在合法区域（没有超过边界）</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=n || j&lt;<span class="number">0</span> || j&gt;=n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="强整数">970. 强整数</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305021012403.png" /></p>
<p>中等题，但是比较简单。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">powerfulIntegers</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> bound)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; x_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; y_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">1</span>) &#123;</span><br><span class="line">            x_list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">1</span> &amp;&amp; sum &lt;= bound) &#123;</span><br><span class="line">            x_list.add(sum);</span><br><span class="line">            sum = sum*x;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y==<span class="number">1</span>) &#123;</span><br><span class="line">            y_list.add(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y!=<span class="number">1</span> &amp;&amp; sum &lt;= bound) &#123;</span><br><span class="line">            y_list.add(sum);</span><br><span class="line">            sum = sum*y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;x_list.size();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;y_list.size();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x_list.get(i)+y_list.get(j)&lt;=bound) &#123;</span><br><span class="line">                    set.add(x_list.get(i)+y_list.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : set) &#123;</span><br><span class="line">            res.add(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="按位与为零的三元组">982. 按位与为零的三元组</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303041201279.png" /></p>
<p>我们可以先枚举任意两个数 x 和 y，用数组统计它们的按位与结果 x&amp;y出现的次数。然后枚举 x 和 y 的按位与结果 xy，再枚举 z，如果 xy&amp;z=0，则将 cnt[xy] 的值加入答案。</p>
<blockquote>
<p>常识：两个数相与的结果一定是小于等于这两个数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countTriplets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个数相与的结果一定是小于等于这个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            max_n = Math.max(max_n, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] re = <span class="keyword">new</span> <span class="title class_">int</span>[max_n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : nums) &#123;</span><br><span class="line">                re[a &amp; b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;max_n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                        res += re[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="检查替换后的词是否有效">1003. 检查替换后的词是否有效</h1>
<h2 id="方法一字符串操作">方法一、字符串操作</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305032222985.png" /></p>
<p>不断对 s 删除"abc"字符串，如果最后能删除干净，那么返回 true，否则返回 false。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s.length()!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(s);</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s.length()-<span class="number">2</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.substring(i,i+<span class="number">3</span>).compareTo(<span class="string">&quot;abc&quot;</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                    s = s.substring(<span class="number">0</span>,i) + s.substring(i+<span class="number">3</span>);</span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isFind) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二栈">方法二、栈</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305032240065.png" /></p>
<p>其实思路与上面一致，但是上面的方法每次都要重新构造 s，会有很大的时间和空间开销，所以用栈将字符串的每个字符依次入栈，如果遇到"abc"，弹出去，依次进行，如果栈空则 true。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            dq.addLast(sc[i]);</span><br><span class="line">            <span class="keyword">while</span> (dq.size()&gt;=<span class="number">3</span> &amp;&amp; dq.peekLast()==<span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                <span class="keyword">if</span> (a!=<span class="string">&#x27;a&#x27;</span> || b!=<span class="string">&#x27;b&#x27;</span> || c!=<span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                    dq.addLast(a);</span><br><span class="line">                    dq.addLast(b);</span><br><span class="line">                    dq.addLast(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dq.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三stringbuilder">方法三、StringBuilder</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305032246039.png" /></p>
<p>这是上面两种方法的结合。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            sb.append(sc[i]);</span><br><span class="line">            <span class="keyword">if</span> (sb.length()&gt;=<span class="number">3</span> &amp;&amp; <span class="string">&quot;abc&quot;</span>.equals(sb.substring(sb.length()-<span class="number">3</span>))) &#123;</span><br><span class="line">                sb.delete(sb.length()-<span class="number">3</span>,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="填充书架">1105. 填充书架⭐</h1>
<blockquote>
<p>考察： #动态规划</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304230907525.png" /></p>
<p>中等题，思路难。</p>
<p>题解：<a target="_blank" rel="noopener" href="https://blog.csdn.net/snailbuster/article/details/98311032?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">题解</a></p>
<p>这里 <code>dp[i]</code> 表示在放到第 <code>i</code> 本书的时候的总高度最优解，但这并不一定是放到最后一本书的最优解。要想找到第 i 本书的最优解，需要从后往前依次判断，如果第 <code>[j, i]</code> 本书都放在同一层（前提是厚度不超过）, 那么总高度会不会变小。这样判断直到 <code>i</code> 所在的这一层的厚度到顶了，将最优解的高度存入 <code>dp[i]</code>，表示我放到 <code>i</code> 这本书的时候的高度最优解。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> books.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1000</span>*<span class="number">1000</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]表示在放到第i本书的时候的最优解</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w + books[j-<span class="number">1</span>][<span class="number">0</span>] &lt;= shelfWidth) &#123;   <span class="comment">// 表示第j本书放入新的一层</span></span><br><span class="line">                    w += books[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                    h = Math.max(h, books[j-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j-<span class="number">1</span>]+h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最佳观光组合">1014、最佳观光组合⭐</h1>
<h4 id="动态规划-1">动态规划</h4>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626752.png" alt="image-20221021185104168" /><figcaption aria-hidden="true">image-20221021185104168</figcaption>
</figure>
<p>数学的正则运算。</p>
<p><code>values[i] + values[j] + i - j == (values[i] + i) +  (values[j] - j)</code></p>
<p>完整代码，思路很清晰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScoreSightseeingPair</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxi</span> <span class="operator">=</span> values[<span class="number">0</span>];    <span class="comment">//记录最大的values[i]+i</span></span><br><span class="line">        <span class="comment">//找最大的values[j]-j</span></span><br><span class="line">        <span class="keyword">for</span>  (<span class="type">int</span> j=<span class="number">1</span>;j&lt;values.length;j++) &#123;</span><br><span class="line">            <span class="comment">//以当前节点为j，将它和前面的最大的i对应的值相加，和原有的res比较</span></span><br><span class="line">            res = Math.max(res, maxi+values[j]-j);</span><br><span class="line">            <span class="comment">//判断如果当前节点不是j而是i，和原本的maxi进行比较更新maxi</span></span><br><span class="line">            maxi = Math.max(maxi, values[j]+j);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="负二进制转换">1017. 负二进制转换⭐</h1>
<blockquote>
<p>考察： #位运算</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304060949672.png" /></p>
<p>思路：构建 bits 数组，bits[i] 表示需要 <span class="math inline">\((-2)^i\)</span> 的次数。但是此时只需要对每个元素进行计数，有以下的规律。</p>
<ul>
<li>对于 <span class="math inline">\(2^i\)</span>，如果 i 为偶数时，此时 <span class="math inline">\(2^i = (-2)^i\)</span>；</li>
<li>对于 <span class="math inline">\(2^i\)</span>，如果 i 为奇数时，此时 <span class="math inline">\(2^i = (-2)^{i+1} + (-2)^i\)</span></li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;     <span class="comment">// 如果i是偶数</span></span><br><span class="line">	bits[i] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;      <span class="comment">// 如果i是奇数</span></span><br><span class="line">	bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">	bits[i] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>对已经构造好的 bits 数组处理，要求每个值只能是 0 或者-1。</p>
<p>如果 h[i]&gt;=2： - 如果 h[i+1]&gt;0，那么 h[i]的两份可以抵消 h[i+1]的一份（因为他们是异号）。 - 否则，h[i]的两份等价于 h[i+1]的一份和 h[i+2]的一份的和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">	<span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span> &amp;&amp; bits[i+<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">		bits[i] -= <span class="number">2</span>;</span><br><span class="line">		bits[i+<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">		bits[i] -= <span class="number">2</span>;</span><br><span class="line">		bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">		bits[i+<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-to-base-2/solutions/1898036/daydayuppp-jian-dan-de-zhi-guan-mo-ni-by-g2y2/">负二进制转换 题解</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">baseNeg2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    bits[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                    bits[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span> &amp;&amp; bits[i+<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                bits[i] -= <span class="number">2</span>;</span><br><span class="line">                bits[i+<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">                bits[i] -= <span class="number">2</span>;</span><br><span class="line">                bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                bits[i+<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isstart</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bits[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                isstart = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isstart) &#123;</span><br><span class="line">                sb.append(String.valueOf(bits[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="链表中的下一个更大节点">1019. 链表中的下一个更大节点</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304102203153.png" /></p>
<p>中等题。思路：将链表先变成数组，然后利用栈的原理找到第一个大于的元素，存入栈的是元素在数组的下标。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t!=<span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            t = t.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        t = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t!=<span class="literal">null</span>) &#123;</span><br><span class="line">            nums[i] = t.val;</span><br><span class="line">            t = t.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[dq.peekLast()]&lt;nums[i]) &#123;</span><br><span class="line">                    res[dq.pollLast()] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            res[dq.pollFirst()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="驼峰式匹配">1023. 驼峰式匹配</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304140819106.png" /></p>
<p>中等题，但是很简单，直接对应遍历即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">camelMatch</span><span class="params">(String[] queries, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">char</span>[] pc = pattern.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pl</span> <span class="operator">=</span> pc.length;</span><br><span class="line">        ArrayList&lt;Boolean&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> queries[i];</span><br><span class="line">            <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;sc.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k&lt;pl &amp;&amp; sc[j]==pc[k]) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sc[j]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; sc[j]&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        isTrue = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isTrue &amp;&amp; k==pl) &#123;</span><br><span class="line">                res.add(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="节点与其祖先之间的最大差值">1026. 节点与其祖先之间的最大差值</h1>
<blockquote>
<p>考察： #树 #前序遍历</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181524869.png" /></p>
<p>中等题，需要认真审题。要注意得是：A、B 必须在一条枝上，但不一定是相邻得。这里使用得前序遍历。</p>
<p>前序遍历核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode r)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (r==<span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(r.val);</span><br><span class="line">	find(r.left);</span><br><span class="line">	find(r.right);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAncestorDiff</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root,-<span class="number">1</span>,<span class="number">100001</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode r, <span class="type">int</span> max, <span class="type">int</span> min)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> r.val;</span><br><span class="line">        max = Math.max(max, d);</span><br><span class="line">        min = Math.min(min, d);</span><br><span class="line">        res = Math.max(res, Math.abs(max-min));</span><br><span class="line">        dfs(r.left, max, min);</span><br><span class="line">        dfs(r.right, max, min);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长等差数列">1027. 最长等差数列⭐⭐</h1>
<blockquote>
<p>考察： #动态规划 #递归</p>
</blockquote>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-arithmetic-subsequence/solutions/2239191/ji-yi-hua-sou-suo-di-tui-chang-shu-you-h-czvx/">题解</a></p>
<h2 id="方法一递归-1">方法一、递归</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221639277.png" /></p>
<p>思路在题解，代码有注释。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Integer&gt;[] maxLen;    <span class="comment">// 这是一个hash数组，长度为n。每个元素为一个hash表，key为方差，value为在这个方差下的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        maxLen = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer,Integer&gt; <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 之前已经计算过了以i下标元素为结尾的hash表了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (maxLen[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxLen[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        maxLen[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充以nums[i]为结尾的hash表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i] - nums[j];    <span class="comment">// 这两个数之间的方差</span></span><br><span class="line">            <span class="keyword">if</span> (!maxLen[i].containsKey(d)) &#123;    <span class="comment">// 如果这个方差没有计算过就放进去，如果已经计算过说明在j~i之间出现过一样的数字，这里就不要考虑了</span></span><br><span class="line">                maxLen[i].put(d, dfs(j).getOrDefault(d,<span class="number">1</span>)+<span class="number">1</span>);    <span class="comment">// 如果以j为结尾的方差为d的长度没有，那么j位置算1个，i位置算一个，一共2个</span></span><br><span class="line">                res = Math.max(res, maxLen[i].get(d));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化-2">优化</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221640989.png" /></p>
<p>将代码合并在一个函数内。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] maxLen = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">// 从0开始，方便初始化</span></span><br><span class="line">            maxLen[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i] - nums[j];    <span class="comment">// 这两个数之间的方差</span></span><br><span class="line">                <span class="keyword">if</span> (!maxLen[i].containsKey(d)) &#123;    <span class="comment">// 如果这个方差没有计算过就放进去，如果已经计算过说明在j~i之间出现过一样的数字，这里就不要考虑了</span></span><br><span class="line">                    maxLen[i].put(d, maxLen[j].getOrDefault(d,<span class="number">1</span>)+<span class="number">1</span>);    <span class="comment">// 如果以j为结尾的方差为d的长度没有，那么j位置算1个，i位置算一个，一共2个</span></span><br><span class="line">                    res = Math.max(res, maxLen[i].get(d));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划-3">方法二、动态规划</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221641848.png" /></p>
<p>关键是区间映射。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1001</span>];      <span class="comment">// nums[i]的范围为[0,500]，所以d最小为-500，最大为500。把[-500,500]映射到[0,1000]中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i] - nums[j] + <span class="number">500</span>;    <span class="comment">// 区间映射到[0,1000]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][d]==<span class="number">0</span>) &#123;   </span><br><span class="line">                    dp[i][d] = dp[j][d] + <span class="number">1</span>;    <span class="comment">// 注意这里是不包括i位置自己的</span></span><br><span class="line">                    res = Math.max(res, dp[i][d]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两个非重叠子数组的最大和">1031. 两个非重叠子数组的最大和</h1>
<blockquote>
<p>考察： #滑动窗口</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304260928945.png" /></p>
<p>中等题，但是比较简单，注意审题。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumTwoNoOverlap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> firstLen, <span class="type">int</span> secondLen)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">// pre[i]表示i之前的元素再firstlen长度的总和</span></span><br><span class="line">        <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[n];      <span class="comment">// end[i]表示i及其之后的firstlen长度的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstLen+secondLen&gt;n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0 1 2 3 4 5   len=2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;firstLen-<span class="number">1</span>) &#123;</span><br><span class="line">                pre[i] = <span class="number">0</span>;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == firstLen-<span class="number">1</span>) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                pre[i] = sum;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                sum -= nums[i-firstLen];</span><br><span class="line">                pre[i] = Math.max(pre[i-<span class="number">1</span>], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0 1 2 3 4 5   len=2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;n-firstLen) &#123;</span><br><span class="line">                end[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i==n-firstLen) &#123;</span><br><span class="line">                end[i] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum -= nums[i+firstLen];</span><br><span class="line">                end[i] = Math.max(end[i+<span class="number">1</span>],sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&lt;secondLen-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-secondLen&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    sum -= nums[i-secondLen];</span><br><span class="line">                    res = Math.max(res, sum + pre[i-secondLen]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n) &#123;</span><br><span class="line">                    res = Math.max(res, sum + end[i+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;      // 表示i之前的 和 i及其之后的</span></span><br><span class="line">        <span class="comment">//     System.out.print(pre[i]);</span></span><br><span class="line">        <span class="comment">//     System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     System.out.println(end[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="字符流">1032. 字符流⭐</h1>
<blockquote>
<p>考察： #前缀树</p>
<p>基础：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303241046436.png" /></p>
<p>典型的<strong>前缀树</strong>题，写这一题前一定要先写 208 题。本题实际上就是前缀树的反思路，是以当前输入的字符为结尾，往前找。而存储 word 的时候是将每个 word 倒着存。</p>
<p>优化：注意条件 <code>1 &lt;= words[i].length &lt;= 200</code>，所以在遍历时可以设置提前退出条件，否则会超时。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">    <span class="type">boolean</span> isStart;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">26</span>];</span><br><span class="line">        isStart = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamChecker</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();    </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamChecker</span><span class="params">(String[] words)</span> &#123;    <span class="comment">//后缀树</span></span><br><span class="line">        TreeNode r;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            r = root;</span><br><span class="line">            <span class="type">char</span>[] sc = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=word.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> sc[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.children[idx]==<span class="literal">null</span>) &#123;</span><br><span class="line">                    r.children[idx] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                r = r.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">            r.isStart = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(<span class="type">char</span> letter)</span> &#123;</span><br><span class="line">        sb.append(letter);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=sb.length()-<span class="number">1</span>,j=<span class="number">0</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;<span class="number">201</span>; i--,j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> sb.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.children[idx]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = r.children[idx];</span><br><span class="line">                <span class="keyword">if</span> (r.isStart==<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StreamChecker obj = new StreamChecker(words);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.query(letter);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="移动石子直到连续">1033. 移动石子直到连续👍</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301630827.png" /></p>
<p>思路：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301629603.png" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numMovesStones(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">        Arrays.sort(map);</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">2</span>]-map[<span class="number">0</span>]==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[<span class="number">1</span>]-map[<span class="number">0</span>]&lt;=<span class="number">2</span> || map[<span class="number">2</span>]-map[<span class="number">1</span>]&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, map[<span class="number">2</span>]-map[<span class="number">0</span>]-<span class="number">2</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, map[<span class="number">2</span>]-map[<span class="number">0</span>]-<span class="number">2</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多边形三角剖分的最低得分">1039. 多边形三角剖分的最低得分⭐</h1>
<blockquote>
<p>考察： #动态规划 #记忆搜索</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304021115756.png" /></p>
<p>中等题，有难度，但是只要思路对了那就好算。</p>
<p>动态规划（递推）的思路。dp[i][j]表示从第 i 节点到第 j 节点的最短乘积和。转换为子问题，遍历 i 和 j 中的点 k，k 将整个图形分割为三部分，分别是 dp[i][k]、dp[k][j]、以 ijk 为顶点的三角形。按照这样的思路配合利用数组记录 dp[i][j]，可以快速求出 dp[0][n-1]。值得注意的是：如果 <code>k == i + 1</code>，那么直接返回 0，如果 <code>j == i + 2</code> 直接表示 i 到 j 就是一个三角形，直接返回他们的乘积。return 之前都别忘了保存，搜索之前别忘了记忆化查找。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] values;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minScoreTriangulation</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="built_in">this</span>.values = values;</span><br><span class="line">        <span class="built_in">this</span>.dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">return</span> find(<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[start][end]!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            dp[start][end] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">2</span>) &#123;</span><br><span class="line">            dp[start][end] = values[start]*values[start+<span class="number">1</span>]*values[end];</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start+<span class="number">1</span>; i &lt;= end-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            min = Math.min(min, find(start,i) + find(i,end) + values[start]*values[i]*values[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][end] = min;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="移动石子直到连续-ii">1040. 移动石子直到连续 II⭐</h1>
<blockquote>
<p>考察： #滑动窗口 #双指针</p>
</blockquote>
<blockquote>
<p>基础：1033</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304070918507.png" /></p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/moving-stones-until-consecutive-ii/solutions/2212638/tu-jie-xia-tiao-qi-pythonjavacgo-by-endl-r1eb/">题解</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numMovesStonesII(<span class="type">int</span>[] stones) &#123;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> stones[n-<span class="number">2</span>]-stones[<span class="number">0</span>]-<span class="number">1</span>-(n-<span class="number">3</span>); </span><br><span class="line">        <span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> stones[n-<span class="number">1</span>]-stones[<span class="number">1</span>]-<span class="number">1</span>-(n-<span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">MaxMove</span> <span class="operator">=</span> Math.max(e1,e2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">MinMove</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (e1==<span class="number">0</span> || e2==<span class="number">0</span>) &#123;     <span class="comment">// 需要端点一个作为跳板移动过来，再将另一个端点跳过去</span></span><br><span class="line">            MinMove = Math.min(<span class="number">2</span>, MaxMove);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">MaxCount</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 定义左端点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;    <span class="comment">// right点一定位于一个石子上</span></span><br><span class="line">                <span class="comment">// 目标是找到一个窗口，它的起点和终点都一定是有石子的</span></span><br><span class="line">                <span class="keyword">while</span> (stones[right] - stones[left] + <span class="number">1</span> &gt; n) &#123;    <span class="comment">// 窗口大小大于n（石子的数量），这能让窗口一直维持在n的长度以内</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                MaxCount = Math.max(MaxCount, right-left+<span class="number">1</span>);   <span class="comment">// right-left+1表示这个窗口内已经放了多少的石子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时MaxCount为最大，则空位有n-MaxCount</span></span><br><span class="line">            MinMove = n - MaxCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;MinMove,MaxMove&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="困于环中的机器人">1041. 困于环中的机器人</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304110918373.png" /></p>
<p>简单的中等题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRobotBounded</span><span class="params">(String instructions)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ic = instructions.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] loc = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">face</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;ic.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ic[i]==<span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                    loc[face]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ic[i]==<span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                    face = (face+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ic[i]==<span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    face = (face+<span class="number">4</span>-<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (loc[<span class="number">0</span>]==loc[<span class="number">2</span>] &amp;&amp; loc[<span class="number">1</span>]==loc[<span class="number">3</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="不邻接植花">1042. 不邻接植花⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304151324483.png" /></p>
<p>中等题。题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/solutions/2226271/bu-lin-jie-zhi-hua-by-leetcode-solution-bv74/">题解</a>。思路如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304151325213.png" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] gardenNoAdj(<span class="type">int</span> n, <span class="type">int</span>[][] paths) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] al = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            al[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.length;i++) &#123;</span><br><span class="line">            al[paths[i][<span class="number">0</span>]-<span class="number">1</span>].add(paths[i][<span class="number">1</span>]-<span class="number">1</span>);</span><br><span class="line">            al[paths[i][<span class="number">1</span>]-<span class="number">1</span>].add(paths[i][<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] color = <span class="keyword">new</span> <span class="title class_">int</span>[n];      <span class="comment">// 表示n个花园的颜色，初始化时为0表示没有颜色</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] tc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>];     <span class="comment">// 表示4中颜色是否可以选，0表示初始化，默认为false，表示都能选</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相邻的花园的颜色都设置为true，表示不可选择了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k : al[i]) &#123;</span><br><span class="line">                tc[color[k]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!tc[j]) &#123;    <span class="comment">// 表示颜色没有选</span></span><br><span class="line">                    color[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分隔数组以得到最大和">1043. 分隔数组以得到最大和⭐</h1>
<blockquote>
<p>考察： #递归 #动态规划</p>
</blockquote>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-array-for-maximum-sum/solutions/2234242/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-rq5i/?languageTags=java">题解</a></p>
<h2 id="方法一递归记忆化搜索">方法一、递归+记忆化搜索⭐</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191002832.png" /></p>
<p>中等题。思路：构造一个函数 dfs (i)，表示以位置 i 为结尾的前面的结果。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;    <span class="comment">// 从右往左进行</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 表示以[0,i]这段的最大结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span> &amp;&amp; j&gt;=i-k+<span class="number">1</span>; j--) &#123;</span><br><span class="line">            max = Math.max(max, arr[j]);    <span class="comment">// 表示在[j,i]这段中，最大值为max，长度为i-j+1</span></span><br><span class="line">            res = Math.max(res, dfs(j-<span class="number">1</span>) + max*(i-j+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = res;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划-4">方法二、动态规划</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191113666.png" /></p>
<p>从左向右正向判断，每次直接计算出以 i 结尾的结果。最终结果就是 <code>dp[n]</code>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">// dp[i]存的是以i-1结尾的前面段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span> &amp;&amp; j&gt;=i-k+<span class="number">1</span>; j--) &#123;</span><br><span class="line">                max = Math.max(max, arr[j]);</span><br><span class="line">                dp[i+<span class="number">1</span>] = Math.max(dp[i+<span class="number">1</span>], dp[j] + max*(i-j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化空间">优化空间</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191119429.png" /></p>
<p>我们可以发现在动态规划中，计算 i 值只需要 <code>[i-k+1, i]</code> 区间的结果，长度为 k。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];     <span class="comment">// dp[i]存的是以i-1结尾的前面段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span> &amp;&amp; j&gt;=i-k+<span class="number">1</span>; j--) &#123;</span><br><span class="line">                max = Math.max(max, arr[j]);</span><br><span class="line">                <span class="comment">// 注意在循环结束前，f[(i+1)%k] 是需要用到的，不能提前覆盖</span></span><br><span class="line">                res = Math.max(res, dp[j%k] + max*(i-j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[(i+<span class="number">1</span>)%k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n%k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最长字符串链">1048. 最长字符串链</h1>
<blockquote>
<p>考察： #动态规划 #双指针</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304270921812.png" /></p>
<p>中等题。比较简单，只需要先将数组按照长度排序，然后遍历每个数组，将它与比它长度少 1 的字符串比较，比较时用一个指针即可，当 i 指针是两个字符串不同的位置，那么长字符串 i 之后的元素一定是与短字符串 i 及其之后的元素是相等的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestStrChain</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.length()-b.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words[j].length() &lt; words[i].length()-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (words[j].length() == words[i].length()-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isTrue(words[i],words[j])==<span class="number">0</span>) &#123;    <span class="comment">// 前面长，后面短</span></span><br><span class="line">                        dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">isTrue</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ac = a.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] bc = b.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;b.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ac[i]!=bc[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==b.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i位置是a新加入的</span></span><br><span class="line">        <span class="keyword">return</span> a.substring(i+<span class="number">1</span>).compareTo(b.substring(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="交换一次的先前排列">1053. 交换一次的先前排列</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304031000331.png" /></p>
<p>中等题，实际上就是找规律。本题实际上找的是比当前数字组合更小的最大数字组合，但是只能交换一组数。通过规律定义如下步骤：</p>
<ol type="1">
<li>从右往左找降序（包括相等），找到第一个不是降序的数字位置，记作 loc1。
<ul>
<li>如果 loc1 还是初始值（定义为-1），表示整个数字组合都是升序，所以直接返回 arr 即可。</li>
<li>如果 loc1 不是初始值，那么继续下面步骤。</li>
</ul></li>
<li>在 loc1 后面找比它小一点点的数，这里不要求数一定更靠左还是靠右，只要找到比它小的最大数的第一次出现位置，记作 loc2。</li>
<li>交换 loc1 的数字和 loc2 的数字。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] prevPermOpt1(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">loc1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                loc1 = i;       <span class="comment">// 这个loc1后面一定有比它更小的，如果都比它大，那它还是在升序里</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loc1 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc2</span> <span class="operator">=</span> loc1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=loc1+<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[loc1] &amp;&amp; arr[i]&gt;arr[loc2]) &#123;</span><br><span class="line">                loc2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[loc1];</span><br><span class="line">        arr[loc1] = arr[loc2];</span><br><span class="line">        arr[loc2] = temp;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最短公共超序列">1092. 最短公共超序列⭐⭐</h1>
<blockquote>
<p>考察： #递归</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303281018733.png" /></p>
<p>困难题。题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/shortest-common-supersequence/solutions/2194615/cong-di-gui-dao-di-tui-jiao-ni-yi-bu-bu-auy8z/">题解</a></p>
<p>思路：利用 dfs 检索以 s1 的 i 下标结尾和 s2 的 j 下标结尾的结果的最短长度。利用 FindStr 按照 dfs 正确的顺序进行查找。</p>
<p>最终代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] map;</span><br><span class="line">    <span class="keyword">public</span> String s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        s1 = str1;</span><br><span class="line">        s2 = str2;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">int</span>[s1.length()][s2.length()];</span><br><span class="line">        <span class="keyword">return</span> FindStr(s1.length()-<span class="number">1</span>,s2.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;     <span class="comment">// 表示在s1[0,i]和s2[0,j]的情况下，返回结果的最短长度</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map[i][j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            map[i][j] = dfs(i-<span class="number">1</span>,j-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[i][j] = Math.min(dfs(i-<span class="number">1</span>,j), dfs(i,j-<span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">FindStr</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.substring(<span class="number">0</span>,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FindStr(i-<span class="number">1</span>,j-<span class="number">1</span>) + s1.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs(i,j) == dfs(i-<span class="number">1</span>,j) + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FindStr(i-<span class="number">1</span>,j) + s1.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FindStr(i,j-<span class="number">1</span>) + s2.charAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="花括号展开-ii">1096. 花括号展开 II⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303071725462.png" /></p>
<p>困难题，实际上就是找规律题。通过阅读题目，发现如下的规律：</p>
<p>如果当前字符为 <code>&#123;</code> ： - 如果前面有字母或者 <code>&#125;</code>，则先入栈 <code>*</code>，再入栈 <code>&#123;</code>。 - 否则直接入栈 <code>&#123;</code>。</p>
<p>如果当前字符为字母：找到以此字母为首的连续字母串，将这个串存入 Treeset 中。</p>
<p>如果当前字符为 <code>,</code> : - 如果栈顶为 <code>*</code>，为了保证乘法优先级更高，先取 Treeset 中的两个和此 <code>*</code> 进行处理……直到栈顶不是 <code>*</code>，再将 <code>+</code> 入栈。 - 否则直接将 <code>+</code> 入栈。</p>
<p>如果当前字符为 <code>&#125;</code> ：取栈顶运算符和两个 set 中的元素进行处理，直到遇到 <code>&#123;</code>，直接将 <code>&#123;</code> 出栈。</p>
<p>在遍历数组之后，如果栈中还有运算符，则依次出栈并处理。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303071735376.png" /></p>
<blockquote>
<p>这里注意运用的 TreeSet 数据结构，不能使用 HashSet，因为答案是有序的，只能使用 TreeSet 按照其默认顺序即可。</p>
<p>在操作时也要注意两个操作数的前后顺序，如果顺序相反则结果也会出错。</p>
</blockquote>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">    List&lt;TreeSet&lt;String&gt;&gt; lss = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeSet&lt;String&gt;&gt;();    <span class="comment">// set()避免重复</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Option</span><span class="params">(<span class="type">char</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            TreeSet&lt;String&gt; set1 = lss.get(lss.size()-<span class="number">1</span>);</span><br><span class="line">            TreeSet&lt;String&gt; set2 = lss.get(lss.size()-<span class="number">2</span>);</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.add(set1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(lss.get(lss.size()-<span class="number">2</span>));</span><br><span class="line">            List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(lss.get(lss.size()-<span class="number">1</span>));</span><br><span class="line">            TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;list1.size();j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;list2.size();k++) &#123;</span><br><span class="line">                    set.add((String)(list1.get(j)+list2.get(k)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">braceExpansionII</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ec= expression.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;ec.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ec[i]==<span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; (ec[i-<span class="number">1</span>]==<span class="string">&#x27;&#125;&#x27;</span> || (ec[i-<span class="number">1</span>]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ec[i-<span class="number">1</span>]&lt;=<span class="string">&#x27;z&#x27;</span>))) &#123;</span><br><span class="line">                    dq.addLast(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dq.addLast(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ec[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ec[i]&lt;=<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                TreeSet&lt;String&gt; ss = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; ec[i-<span class="number">1</span>]==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    dq.addLast(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (p&lt;ec.length &amp;&amp; (ec[p]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ec[p]&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">                ss.add(expression.substring(i,p));</span><br><span class="line">                i = p - <span class="number">1</span>;</span><br><span class="line">                lss.add(ss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ec[i]==<span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekLast()==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                    Option(t);</span><br><span class="line">                &#125;</span><br><span class="line">                dq.addLast(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ec[i]==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Option(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Option(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(lss.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="表现良好的最长时间段">1124. 表现良好的最长时间段</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302140906059.png" /></p>
<p>中等题。</p>
<p>思路：找子串最大长度，表示满足一个子串，使得其左边和右边要么是边界、要么是不劳累，且其内部劳累大于不劳累。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="comment">// 最大长度，表示满足一个子串，使得其左边和右边要么是边界，要么是不劳累，且其内部劳累大于不劳累</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> hours.length;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);     <span class="comment">//下标，劳累，不劳累</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, nl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hours[i]&gt;<span class="number">8</span>) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nl++;</span><br><span class="line">                al.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,l,nl&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n,l,nl&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left=<span class="number">0</span>; left&lt;al.size(); left++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(al.get(left)[2]);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> right=left+<span class="number">1</span>; right&lt;al.size(); right++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> al.get(right)[<span class="number">1</span>]-al.get(left)[<span class="number">1</span>] , nt = al.get(right)[<span class="number">2</span>]-al.get(left)[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (al.get(right)[<span class="number">0</span>]&gt;=<span class="number">0</span> &amp;&amp; al.get(right)[<span class="number">0</span>]&lt;n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hours[al.get(right)[<span class="number">0</span>]]&gt;<span class="number">8</span>) &#123;</span><br><span class="line">                        t--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        nt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (t &gt; nt) &#123;</span><br><span class="line">                    <span class="comment">// System.out.print(left);</span></span><br><span class="line">                    <span class="comment">// System.out.print(&quot; &quot;);</span></span><br><span class="line">                    <span class="comment">// System.out.println(right);</span></span><br><span class="line">                    max = Math.max(max,al.get(right)[<span class="number">0</span>]-al.get(left)[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最小的必要团队">1125. 最小的必要团队⭐</h1>
<blockquote>
<p>考察： #背包问题</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304081833720.png" /></p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-sufficient-team/solutions/2214387/zhuang-ya-0-1-bei-bao-cha-biao-fa-vs-shu-qode/">题解</a></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> all;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] skill;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestSufficientTeam(String[] req_skills, List&lt;List&lt;String&gt;&gt; people) &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> req_skills.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            hash.put(req_skills[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> people.size();</span><br><span class="line">        skill = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;people.get(i).size();j++) &#123;</span><br><span class="line">                skill[i] = skill[i] | <span class="number">1</span>&lt;&lt;hash.get(people.get(i).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">long</span>[n][<span class="number">1</span>&lt;&lt;m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        all = (<span class="number">1L</span> &lt;&lt; n) - <span class="number">1</span>;     <span class="comment">// 表示所有人员都参与</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> dfs(n-<span class="number">1</span>, (<span class="number">1</span>&lt;&lt;m)-<span class="number">1</span>);     <span class="comment">// n-1 表示最后一个人，(1&lt;&lt;m)-1表示最终状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// res是结果的人的集合，需要将每一位提取出来</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[Long.bitCount(res)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((res &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[j] = i;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs(i,j) 定义成从前 i 个人中选择一些人，他们的技能并集为j， 所选择的最少人的集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">//全装满了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> all;     <span class="comment">// 没办法装满背包，返回全集</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;    <span class="comment">// 记忆化搜索</span></span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">res1</span> <span class="operator">=</span> dfs(i-<span class="number">1</span>,j);    <span class="comment">//如果不选当前people</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res2</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; i) | dfs(i-<span class="number">1</span>, j &amp; ~skill[i]);    <span class="comment">// ~skill[i]表示取反，即i这个人拥有的能力为0，没有的为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Long.bitCount(res1) &lt; Long.bitCount(res2)) &#123;</span><br><span class="line">            memo[i][j] = res1;</span><br><span class="line">            <span class="keyword">return</span> res1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i][j] = res2;</span><br><span class="line">            <span class="keyword">return</span> res2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第-n-个斐波那契数">1137、第 N 个斐波那契数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626753.png" alt="image-20221015214614019" /><figcaption aria-hidden="true">image-20221015214614019</figcaption>
</figure>
<p>简单哦~</p>
<h1 id="字母板上的路径">1138. 字母板上的路径</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302121135849.png" /></p>
<p>思路：构建一个 hash 表，存储每个字母的位置。在移动时一定要注意‘z’的判断，如果 <code>if (start[0]+1==5 &amp;&amp; start[1]&gt;=1)</code> 成立，则不能向下移动。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alphabetBoardPath</span><span class="params">(String target)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,<span class="type">int</span>[]&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            hash.put((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i),<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i/<span class="number">5</span>,i%<span class="number">5</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] tc = target.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;tc.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] end = hash.get(tc[i]);</span><br><span class="line">            <span class="keyword">while</span> (start[<span class="number">0</span>]!=end[<span class="number">0</span>] || start[<span class="number">1</span>]!=end[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">0</span>]&gt;end[<span class="number">0</span>]) &#123;    <span class="comment">//需要上移</span></span><br><span class="line">                    start[<span class="number">0</span>]--;</span><br><span class="line">                    sb.append(<span class="string">&quot;U&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">0</span>]&lt;end[<span class="number">0</span>]) &#123;    <span class="comment">//需要下移</span></span><br><span class="line">                    <span class="keyword">if</span> (start[<span class="number">0</span>]+<span class="number">1</span>==<span class="number">5</span> &amp;&amp; start[<span class="number">1</span>]&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        start[<span class="number">0</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">1</span>]&gt;end[<span class="number">1</span>]) &#123;    <span class="comment">//需要左移</span></span><br><span class="line">                    start[<span class="number">1</span>]--;</span><br><span class="line">                    sb.append(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">1</span>]&lt;end[<span class="number">1</span>]) &#123;    <span class="comment">//需要右移</span></span><br><span class="line">                    start[<span class="number">1</span>]++;</span><br><span class="line">                    sb.append(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大的以-1-为边界的正方形">1139. 最大的以 1 为边界的正方形</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302171115497.png" /></p>
<p>中等题，思路比较简单。构造两个二维数据，分别记录以当前为止 (i, j) 的上方连续 1 和左方连续 1 的个数（都包括自己），然后取其中较小值，判断如果以这个值作为边的长度，另外两个顶点是否能满足条件，如果不满足则缩小边的长度，继续判断。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length , m = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] u1 = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];    <span class="comment">//记录包括其上面的连续1的个数</span></span><br><span class="line">        <span class="type">int</span>[][] l1 = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];    <span class="comment">//记录包括其左边的连续1的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            l1[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    u1[i][<span class="number">0</span>] = u1[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    u1[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            u1[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][i]==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    l1[<span class="number">0</span>][i] = l1[<span class="number">0</span>][i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    l1[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                res = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    u1[i][j] = u1[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    l1[i][j] = l1[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">edge</span> <span class="operator">=</span> Math.min(u1[i][j],l1[i][j]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> e=edge;e&gt;<span class="number">0</span>;e--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (u1[i][j-e+<span class="number">1</span>]&gt;=e &amp;&amp; l1[i-e+<span class="number">1</span>][j]&gt;=e) &#123;</span><br><span class="line"></span><br><span class="line">                            res = Math.max(res,e);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递减元素使数组呈锯齿状">1144. 递减元素使数组呈锯齿状</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302270900017.png" /></p>
<p>中等题，但是思路比较简单。只需要判断<strong>奇数下标比偶数下标的小</strong>和<strong>偶数下标比奇数下标小</strong>这两种情况下，需要的最小操作的次数。</p>
<p>小优化：当判断<strong>奇数下标比偶数下标的小</strong>的情况时，只需要以奇数位置为判断点，如果它比两边大就缩小，如果比两边小则继续判断下一个奇数下标。当判断<strong>偶数下标比奇数下标小</strong>的情况时，只需要判断偶数位置，如果比两边大则缩小，如果比两边小则继续判断下一个偶数下标。</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movesToMakeZigzag</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先判断奇数下标小，只要判断奇数位置元素即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; k&gt;=nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                res += k - nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n &amp;&amp; k&gt;=nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                res += k - nums[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先判断偶数下标小，只要判断偶数位置元素即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; k&gt;=nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                total += k - nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n &amp;&amp; k&gt;=nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                total += k - nums[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(res,total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉树着色游戏">1145. 二叉树着色游戏</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303121637065.png" /></p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-coloring-game/solutions/2089813/mei-you-si-lu-yi-zhang-tu-miao-dong-pyth-btav/">没有思路？一张图秒懂！（Python/Java/C++/Go） - 二叉树着色游戏 - 力扣（LeetCode）</a></p>
<p>看完题解，可能还有点懵。简单说就是以 x 为中心，可以分为三部分，分别是其左子树、右子树、还有剩下的部分。要如果 y 在第一步先占领了 x 四周的某一个部分，那么这一部分的所有元素都是 y 所有了。如果这一部分的元素个数比其他部分的元素个数之和还多，那么 y 是<strong>稳赢</strong>！</p>
<p><strong>所以正确的步骤应该是：</strong> 先利用 dfs 找到 x 的节点 node，再分别用 dfs 算出其左子树的元素个数、右子树的元素个数、其他部分的元素个数。选其中元素个数最多的部分作为 y 要占领的，如果这一部分的元素比其他部分的元素个数和都多，那么稳赢。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findn1</span><span class="params">(TreeNode root, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findn1(root.left,x)!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> findn1(root.left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findn1(root.right,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left) + dfs(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">btreeGameWinningMove</span><span class="params">(TreeNode root, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        root = findn1(root,x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ln</span> <span class="operator">=</span> dfs(root.left); </span><br><span class="line">        <span class="type">int</span> <span class="variable">rn</span> <span class="operator">=</span> dfs(root.right); </span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Math.max(ln, Math.max(rn, n - ln - rn - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (n2 &gt; n - n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="段式回文">1147. 段式回文</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304120859713.png" /></p>
<p>困难题。因为找分的最多的 k 的数量，所以直接双指针+贪心即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// aba    aba</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestDecomposition</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] tc = text.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tc.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 窗口大小</span></span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=j) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (;i&lt;start+l;i++,j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc[i]!=tc[j]) &#123;</span><br><span class="line">                    isFind = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                start = start + l;</span><br><span class="line">                end = end - l;</span><br><span class="line">                l = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="按字典序排在最后的子串">1163. 按字典序排在最后的子串⭐⭐</h1>
<blockquote>
<p>考察： #双指针</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304241459815.png" /></p>
<p>困难题，使用暴力会超时。很抽象的解法。题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/last-substring-in-lexicographical-order/solutions/2242562/python3javacgotypescript-yi-ti-yi-jie-sh-3amj/?languageTags=java">题解</a></p>
<p><strong>思路：</strong> 定义两个指针 i，j。i 表示最终结果的起始位置，j 表示开始判断的起始位置，定义 k 表示判断的偏移。每次判断 <code>sc[i+k]</code> 和 <code>sc[j+k]</code> ： - 如果 <code>sc[i+k]==sc[j+k]</code>，则 <code>k++</code>，这表示 <code>[i, i+k]</code> 和 <code>[j, j+k]</code> 的元素完全一样，但因为 i 一直在 j 之前，所以以 i 开头的字符串一定比以 j 结尾的字符串要大。 - 如果 <code>sc[i+k]&lt;sc[j+k]</code>，这表示 <code>[i, i+k-1]</code> 和 <code>[j, j+k-1]</code> 的元素完全一样，那么但是因为 j+k 位置的元素比 i+k 大，那么 i 就不能作为开头了，因为 j 作为开始位置的字符串一定是大于 i 作为开始位置的字符串的。<strong>那 i 直接等于 j 吗？</strong> 这也不对，因为 i 只是表示以 i 开头进行判断，可能 i+1、i+2……开头会有更大的结果，但是我们可以发现在 <code>[i, i+k-1]</code> 开头都比不过 <code>[j, j+k-1]</code> 开头，<strong>但是 i+k 开头我们能判断出来吗？</strong> 显然不能，所以我们将 <code>i=i+k+1</code>，j 如果大于新的 i 那就不变，如果 j 小于等于新的 i，那就 <code>j=i+1</code>，k 重置为 0。 - 如果 <code>sc[i+k]&gt;sc[j+k]</code>，这表示 <code>[i, i+k-1]</code> 和 <code>[j, j+k-1]</code> 的元素完全一样，但是 i+k 的元素更大，那么表示在选择 <code>[i, i+k-1]</code> 为开头都已经是已经是已知的最大，但是以 i 结束的一定就是最大的吗，不一定，我们需要重新将 j 置为 <code>j+k+1</code>，k 重置为 0，再对应 i 重新判断。</p>
<p>思路很抽象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lastSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j+k&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i+k]==sc[j+k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sc[i+k] &lt; sc[j+k]) &#123;    <span class="comment">// 表示[i,i+k-1]和[j,j+k-1]之间的内容一模一样，这之间的内容谁当开头i都行，但是k不一样，导致i+k这个位置不能当当开头，就算当也要在j+k这个位置</span></span><br><span class="line">                i = i+k+<span class="number">1</span>;</span><br><span class="line">                j = Math.max(i+<span class="number">1</span>, j);</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;     <span class="comment">// 表示[i,i+k-1]和[j,j+k-1]之间的内容一模一样，这之间的内容谁当开头i都行。但是k不一样，i+k依然可以当开头，但是j+k已经不能了</span></span><br><span class="line">                j = j+k+<span class="number">1</span>;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="餐盘栈">1172. 餐盘栈</h1>
<blockquote>
<p>考察： #小根堆 #栈</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304281043671.png" /></p>
<p>困难题。典型的思维题。题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/dinner-plate-stacks/solutions/2248707/yu-qi-wei-hu-di-yi-ge-wei-man-zhan-bu-ru-sphs/">题解</a>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DinnerPlates</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Deque&lt;Integer&gt;&gt; stacks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">// list的每一个元素是一个栈，这里保存所有的栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; idx = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();    <span class="comment">// 最小堆返回的永远都是最小的值，这里存储的是没有存满的栈的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DinnerPlates</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx.isEmpty() &amp;&amp; idx.peek()&gt;=stacks.size()) &#123;    <span class="comment">// idx中所有元素都是越界下标，直接清空</span></span><br><span class="line">            idx.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idx.isEmpty()) &#123;     <span class="comment">// 有未满栈，且最小的下标没有越界，表示可以取出来用</span></span><br><span class="line">            Deque&lt;Integer&gt; temp = stacks.get(idx.peek());     <span class="comment">// 相当于指针</span></span><br><span class="line">            temp.push(val);</span><br><span class="line">            <span class="keyword">if</span> (temp.size() == capacity) &#123;</span><br><span class="line">                idx.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">// 所有的栈都已经满了</span></span><br><span class="line">            Deque&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            temp.push(val);</span><br><span class="line">            stacks.add(temp);</span><br><span class="line">            <span class="keyword">if</span> (capacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                idx.add(stacks.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> popAtStack(stacks.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popAtStack</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 非法操作</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= stacks.size() || stacks.get(index).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; temp = stacks.get(index);    <span class="comment">// 相当于一个指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp.size() == capacity) &#123;</span><br><span class="line">            idx.add(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> temp.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stacks.isEmpty() &amp;&amp; stacks.get(stacks.size()-<span class="number">1</span>).isEmpty()) &#123;</span><br><span class="line">            stacks.remove(stacks.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DinnerPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DinnerPlates obj = new DinnerPlates(capacity);</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.popAtStack(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="使数组严格递增">1187. 使数组严格递增⭐</h1>
<blockquote>
<p>考察： #动态规划</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201108404.png" /></p>
<p>困难题，思路很重要。</p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/make-array-strictly-increasing/solutions/491950/yi-wei-dp-si-lu-xiang-jie-cpy3-by-newhar/">题解</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201110411.png" /></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">makeArrayIncreasing</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        arr2 = Arrays.stream(arr2).sorted().distinct().toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr1.length+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置左右哨兵-1和MAXN</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">2</span>;i++) &#123;</span><br><span class="line">            arr[i+<span class="number">1</span>] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[n-<span class="number">1</span>] = MAXN;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">// 记录在i不变的情况下，[0,i]升序的最小次数</span></span><br><span class="line">        Arrays.fill(dp,MAXN);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 第一个元素是-1，在它不动的情况下，变化0次可以保证升序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> lower_bound(arr2, arr[i]);    <span class="comment">// j是在arr2的下标，这是比arr[i]大于或等于的最小数的位置，j是不可以用的。替换i-1的值应该从j-1开始。但是j反映了[0,j-1]的个数为j个</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果下标i不换，i-1换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k&lt;=Math.min(i-<span class="number">1</span>, j); k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i-k-<span class="number">1</span>] &lt; arr2[j-k]) &#123;     <span class="comment">// 这里打算替换arr[i-k]为arr2[j-k]，所以先要判断arr[i-k-1]是不是严格小于arr2[j-k]</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-k-<span class="number">1</span>]+k);     <span class="comment">// 对比dp[i]和在下标i-k-1不动的情况下，之后k个元素都变了的最小次数。     </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下标i不换，i-1不换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i-<span class="number">1</span>] &lt; arr[i]) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (res&gt;=MAXN) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lower_bound</span><span class="params">(<span class="type">int</span>[] arr2, <span class="type">int</span> k)</span> &#123;    <span class="comment">// 找&gt;=k的第一个数的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr2.length;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr2[m]&lt;k) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意-4">注意</h3>
<ul>
<li><a href="LeetCode总结笔记.md#数组#排序+去重">数组的排序+去重（Stream）</a></li>
<li><a href="LeetCode总结笔记.md#二分查找">模拟 C++的 <code>lower_bound()</code> 和 <code>upper_bound()</code></a></li>
</ul>
<h1 id="穿过迷宫的最少移动次数">1210. 穿过迷宫的最少移动次数</h1>
<h2 id="方法一广度优先搜索">方法一、广度优先搜索</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302052359281.png" /></p>
<blockquote>
<p>当遇到<strong>最少移动次数</strong>，首先想到的就是<strong>广度优先搜索</strong>，广度优先搜索使用的是<strong>队列</strong>。</p>
</blockquote>
<p>思路：以蛇尾巴为考察点，蛇有两种状态，当蛇为横着时，蛇只会向右、向下平行、顺时针旋转；当蛇为竖着时，蛇只会向下、向右平行、逆时针旋转。每次考察的时候需要判断当前位置当前状态是否第一次访问、是否越界、是否有墙。</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumMoves</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span>[][][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">2</span>];    <span class="comment">// 记录在此格子此姿势下的移动次数（只会向右边和下面，所以不会来回跑，不用记录最小次数）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                Arrays.fill(dist[i][j],-<span class="number">1</span>);     <span class="comment">//相当于dis[i][j][0]和dis[i][j][1]都初始化为-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只考虑尾巴</span></span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();     <span class="comment">//int[]记录的是三元组</span></span><br><span class="line">        dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = dq.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[<span class="number">0</span>], y = arr[<span class="number">1</span>], status = arr[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 基于当前尾巴位置进行广度优先搜索</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前是横着的</span></span><br><span class="line">            <span class="keyword">if</span> (status==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 有三种情况，分别是平行向下，向右，以尾巴为中心顺时针转(要求另外的两个单元都是空的)</span></span><br><span class="line">                <span class="comment">// 1. 向右</span></span><br><span class="line">                <span class="keyword">if</span> (y+<span class="number">2</span> &lt; n &amp;&amp; grid[x][y+<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; dist[x][y+<span class="number">1</span>][<span class="number">0</span>] == -<span class="number">1</span>) &#123;    <span class="comment">//如果已经走过，那一定比这次的次数要小</span></span><br><span class="line">                    dist[x][y+<span class="number">1</span>][<span class="number">0</span>] = dist[x][y][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y+<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2. 平行向下</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">1</span> &lt; n &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dist[x+<span class="number">1</span>][y][<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x+<span class="number">1</span>][y][<span class="number">0</span>] = dist[x][y][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x+<span class="number">1</span>, y, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">1</span> &lt; n &amp;&amp; y+<span class="number">1</span> &lt; n &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; dist[x+<span class="number">1</span>][y][<span class="number">1</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dist[x][y][<span class="number">1</span>] = dist[x][y][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 向右</span></span><br><span class="line">                <span class="keyword">if</span> (y+<span class="number">1</span> &lt; n &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dist[x][y+<span class="number">1</span>][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x][y+<span class="number">1</span>][<span class="number">1</span>] = dist[x][y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y + <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2. 向下</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">2</span> &lt; n &amp;&amp; grid[x+<span class="number">2</span>][y] == <span class="number">0</span> &amp;&amp; dist[x+<span class="number">1</span>][y][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x+<span class="number">1</span>][y][<span class="number">1</span>] = dist[x][y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x + <span class="number">1</span>, y, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">1</span> &lt; n &amp;&amp; y+<span class="number">1</span> &lt; n &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dist[x][y][<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x][y][<span class="number">0</span>] = dist[x][y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n - <span class="number">1</span>][n - <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除子文件夹">1233. 删除子文件夹</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302081040786.png" /></p>
<p>比较简单，字符串的匹配问题。</p>
<h1 id="替换子串得到平衡字符串">1234. 替换子串得到平衡字符串⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302132232292.png" /></p>
<p>非常难且恶心的一道题。</p>
<p>思路和很多题一样，找中间的最小子串，实际上要找的是两边的满足条件的最大子串。定义一个 left=0，先遍历 right 从头到尾，当遇到某个 right 不满足外面每个字母&lt;=l 这个条件时，继续右移 left，一直更新最小的 min。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.length/<span class="number">4</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] remainder = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        hash.put(<span class="string">&#x27;Q&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;W&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;E&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;R&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sc.length;i++) &#123;</span><br><span class="line">            remainder[hash.get(sc[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remainder[<span class="number">0</span>]==l &amp;&amp; remainder[<span class="number">1</span>]==l &amp;&amp; remainder[<span class="number">2</span>]==l &amp;&amp; remainder[<span class="number">3</span>]==l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//right和left算在里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right=<span class="number">0</span>;right&lt;sc.length;right++) &#123;</span><br><span class="line">            remainder[hash.get(sc[right])]--;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;=right &amp;&amp; remainder[<span class="number">0</span>]&lt;=l &amp;&amp; remainder[<span class="number">1</span>]&lt;=l &amp;&amp; remainder[<span class="number">2</span>]&lt;=l &amp;&amp; remainder[<span class="number">3</span>]&lt;=l) &#123;</span><br><span class="line">                min = Math.min(min,right-left+<span class="number">1</span>);</span><br><span class="line">                remainder[hash.get(sc[left])]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="找出给定方程的正整数解">1237. 找出给定方程的正整数解</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303121721337.png" /></p>
<p>中等题，但是是阅读理解，唯一有用的是 <code>Arrays.asList</code> 的使用。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction &#123;</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     public int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSolution</span><span class="params">(CustomFunction customfunction, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">1</span>;x&lt;=z;x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y=<span class="number">1</span>;y&lt;=z;y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (customfunction.f(x,y)==z) &#123;</span><br><span class="line">                    res.add(Arrays.asList(x,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="循环码排列">1238. 循环码排列⭐</h1>
<h1 id="方法一格雷编码">方法一、格雷编码</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230951037.png" /></p>
<p>详细见 <strong>89. 格雷编码</strong>，这里唯一的不同是定义了一个 start，其实不难想到先将整个二进制数组转化为格雷码数组，从 start 开始进行写入 res，再将前面部分补上即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">circularPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] gray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>&lt;&lt;n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//记录格雷码为start的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存每个数的格雷码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            gray[i] = i ^ (i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (gray[i]==start) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=j;i&lt;j+(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i%(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">            res.add(k ^ (k&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化-3">优化</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230935328.png" /></p>
<p>但是这其实是可以优化的，标准的格雷码是从 0 开始，其实 <code>start ⊕ 0 = start</code>，所以直接将标准的格雷码⊕ start 即可。详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">circularPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>) ^ start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="交换字符使得字符串相同">1247. 交换字符使得字符串相同</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302251656447.png" /></p>
<p>中等题，但容易想的很复杂。其实思路很简单，对于 s1 和 s2 不同的组合，有如下的处理情况：</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302251659131.jpg" alt="51391c182efbd1f86b0c93246c15503.jpg" /><figcaption aria-hidden="true">51391c182efbd1f86b0c93246c15503.jpg</figcaption>
</figure>
<p>不难看出，只要有偶数个 xy 对或者偶数个 yx 对，都能通过一半的次数消去不同；对于一个 yx 对和一个 xy 对，需要 2 次处理。只有在处理完后还有 1 个 xy 对或者 yx 对时，表示无法完全消除。详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSwap</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1c = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2c = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">xy</span> <span class="operator">=</span> <span class="number">0</span>, yx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1c.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1c[i]!=s2c[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1c[i]==<span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                    xy ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    yx ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += xy/<span class="number">2</span>;</span><br><span class="line">        xy = xy%<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        res += yx/<span class="number">2</span>;</span><br><span class="line">        yx = yx%<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xy==<span class="number">0</span> &amp;&amp; yx==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (xy==<span class="number">1</span> &amp;&amp; yx==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="得分最高的单词集合">1255. 得分最高的单词集合</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302261756195.png" /></p>
<p>困难题，使用的是 DFS 遍历每种情况。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-score-words-formed-by-letters/solutions/2133515/hui-su-san-wen-si-kao-hui-su-wen-ti-de-t-kw3y/">题解</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302261758306.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] surplus = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] score;</span><br><span class="line">    String[] words;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> total)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res = Math.max(res,total);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选words[i]</span></span><br><span class="line">        dfs(i-<span class="number">1</span>,total);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选words[i]</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">haveAll</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span>[] wc = words[i].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : wc) &#123;</span><br><span class="line">            surplus[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (surplus[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                haveAll = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += score[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveAll==<span class="literal">true</span>) &#123;    <span class="comment">//当前单词可以完全拼出</span></span><br><span class="line">            dfs(i-<span class="number">1</span>,total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : wc) &#123;</span><br><span class="line">            surplus[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScoreWords</span><span class="params">(String[] words, <span class="type">char</span>[] letters, <span class="type">int</span>[] score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.words = words;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;letters.length;i++) &#123;</span><br><span class="line">            surplus[letters[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(words.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="找出井字棋的获胜者">1275、找出井字棋的获胜者</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626754.png" alt="image-20221009160316785" /><figcaption aria-hidden="true">image-20221009160316785</figcaption>
</figure>
<p>常规简单题。</p>
<h3 id="注意-5">注意</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];    <span class="comment">//初始化为null</span></span><br><span class="line"><span class="type">int</span>[] i = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];          <span class="comment">//初始化为0</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>];    <span class="comment">//初始化为false</span></span><br></pre></td></tr></table></figure>
<h1 id="灌溉花园的最少水龙头数目">1326. 灌溉花园的最少水龙头数目⭐⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302211041920.png" /></p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/solutions/2124024/python3javacgotypescript-yi-ti-yi-jie-ta-hwfe/">题解</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302211047624.png" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minTaps</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] ranges)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">//表示以下标为起点的最远能去的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.max(<span class="number">0</span>,i-ranges[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i+ranges[i];</span><br><span class="line">            right[l] = Math.max(right[l],r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">//i表示的是起点</span></span><br><span class="line">            last = Math.max(last,right[i]);    <span class="comment">//表示目前能一直到达的地方</span></span><br><span class="line">            <span class="keyword">if</span> (last&lt;=i) &#123;      <span class="comment">//表示目前能到的地方比判断的起点还小</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==pre) &#123;    <span class="comment">//表示这一段结束了</span></span><br><span class="line">                res++;</span><br><span class="line">                pre = last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通知所有员工所需的时间">1376. 通知所有员工所需的时间</h1>
<blockquote>
<p>考察： #图 #dfs #bfs</p>
</blockquote>
<h2 id="方法一邻接表dfs">方法一、邻接表+dfs</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305011043569.png" /></p>
<p>中等题，按部就班 dfs 即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; list;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] informTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numOfMinutes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> headID, <span class="type">int</span>[] manager, <span class="type">int</span>[] informTime)</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.informTime = informTime;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">// 构建邻接表</span></span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;      <span class="comment">// 遍历manager    </span></span><br><span class="line">            <span class="keyword">if</span> (manager[i]==-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(manager[i]).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (manager[i]==-<span class="number">1</span>) &#123;</span><br><span class="line">                dfs(i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> time)</span> &#123;    <span class="comment">//表示当前节点是i，传给他的时候的时间已经是time</span></span><br><span class="line">        res = Math.max(res, time);</span><br><span class="line">        <span class="keyword">if</span> (list.get(i).size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;list.get(i).size(); j++) &#123;</span><br><span class="line">            dfs(list.get(i).get(j),time+informTime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="用栈操作构建数组">1441、用栈操作构建数组</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626755.png" alt="image-20221015120642642" /><figcaption aria-hidden="true">image-20221015120642642</figcaption>
</figure>
<p>比较简单，注意ArrayList的构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<h1 id="保证文件名唯一">1487. 保证文件名唯一</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303031107630.png" /></p>
<p>利用 HashMap 记录，其 value 记录的值 v 表示[1, v]都是确定已经用过的了，下次可以直接从 v+1 进行查找。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] getFolderNames(String[] names) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> names.length;</span><br><span class="line">        String[] sc = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> names[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(name)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> hash.get(name);</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> name + <span class="string">&quot;(&quot;</span> + (v+<span class="number">1</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (hash.containsKey(temp)) &#123;</span><br><span class="line">                    v++;</span><br><span class="line">                    hash.replace(name,v);</span><br><span class="line">                    temp = name + <span class="string">&quot;(&quot;</span> + (v+<span class="number">1</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash.put(temp,<span class="number">0</span>);</span><br><span class="line">                sc[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.put(name,<span class="number">0</span>);</span><br><span class="line">                sc[i] = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="乘积为正数的最长子数组长度">1567、乘积为正数的最长子数组长度⭐</h1>
<p>本题是<code>152、乘积最大子数组和</code>的升级版。</p>
<h2 id="方法一常规思路">方法一、常规思路</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626756.png" alt="image-20221020214723468" /><figcaption aria-hidden="true">image-20221020214723468</figcaption>
</figure>
<p>本思路其实很简单。</p>
<p>先遍历一遍找到所有的0，在0与0之间找我们的答案。</p>
<p>在每个0和0之间，如果负数的个数是0或者偶数，则这个范围长度就是这个范围内的max；如果不是偶数，用双指针对应范围内的首尾位置，找到第一个负数，返回除去这个负数的范围剩下的范围的长度，就是这个范围的max。具体可以看代码理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;z.size()-<span class="number">1</span>;i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> z.get(i)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> z.get(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.get(i)%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        max = Math.max(max,right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j=left,t=right-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;=t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j==t) &#123;     <span class="comment">//一定是负数</span></span><br><span class="line">                max = Math.max(max,j-left);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                max = Math.max(max,right-j-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[t]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                max = Math.max(max,t-left);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划-5">方法二、动态规划⭐</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626757.png" alt="image-20221020221331318" /><figcaption aria-hidden="true">image-20221020221331318</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solutions/441152/cheng-ji-wei-zheng-shu-de-zui-chang-zi-shu-zu-ch-3/">题解</a></p>
<p>这个很厉害！</p>
<p>建立两个数组zs和fs：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] zs = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//记录以当前下标i结尾的乘积为正数的长度</span></span><br><span class="line"><span class="type">int</span>[] fs = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//记录以当前下标i结尾的乘积为负数的长度</span></span><br></pre></td></tr></table></figure>
<p>处理第一个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    zs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    fs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是0，那么zs和fs都是0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> zs[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>对i&gt;=1后的所有元素进行分析：</p>
<p>对于nums[i]&lt;0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//连续正数的个数+1</span></span><br><span class="line">    zs[i] = zs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//当前数为正数</span></span><br><span class="line">    <span class="keyword">if</span> (fs[i-<span class="number">1</span>]==<span class="number">0</span>) &#123;    <span class="comment">//如果在此之前都没有能成为负数的乘积，再加上这个正数，负数长度仍然为0</span></span><br><span class="line">        fs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fs[i] = fs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于nums[i]&lt;0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs[i-<span class="number">1</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">        zs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        zs[i] = fs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fs[i] = zs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于nums[i]==0：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]==<span class="number">0</span>) &#123;</span><br><span class="line">    zs[i] = <span class="number">0</span>;</span><br><span class="line">    fs[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划优化">动态规划优化</h3>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626758.png" alt="image-20221020221215423" /><figcaption aria-hidden="true">image-20221020221215423</figcaption>
</figure>
<p>每次只使用了i-1的相关值，可以设置两个变量即可。</p>
<h1 id="删除最短的子数组使剩余数组有序">1574. 删除最短的子数组使剩余数组有序</h1>
<blockquote>
<p>考察： #滑动窗口</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303252314502.png" /></p>
<p>中等题，但是比较考验思路。首先找到左边非降序的子序列，left 为其结尾位置；再从右往左找右边部分的非降序子序列，right 为其开始位置。在 left 计算出来之后直接处理，如果 left 为结尾，那么表示全部元素非降序，那么直接返回 0。之后初始化窗口，也就是<strong>最大的窗口其实就是只要左边非降序部分的剩余部分或者只要右边非降序部分的剩余部分，取最小值</strong>，再依次从头移动 start，和 right 判断，如果 arr[start]&lt;=arr[right]，那么更新窗口；否则继续右移 right 直到 right 到 n，那么意思就是只要左边非降序部分。注意窗口更新时都需要与自己取 min。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfShortestSubarray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="keyword">for</span> (left=<span class="number">0</span>;left&lt;n-<span class="number">1</span>;left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &gt; arr[left+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (right=n-<span class="number">1</span>;right&gt;<span class="number">0</span>;right--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[right] &lt; arr[right-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(left);</span><br><span class="line">        System.out.println(right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.min(n-left-<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= left) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; arr[start] &gt; arr[right]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.min(res, right-start-<span class="number">1</span>);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使数组和能被-p-整除">1590. 使数组和能被 P 整除</h1>
<h2 id="方法一前缀和-余数">方法一、前缀和 + 余数</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303101013283.png" /></p>
<p>思路：我们要找到一个子数组，使得整个数组减去它就能被 p 整数，那么可以发现：<strong>子数组的余数等于整个数组的余数</strong>，我们需要找到一个最短的满足这个要求的子数组。</p>
<p>这里涉及到几个小优化。我们设置前缀，是防止在后面求子数组和的时候要进行遍历求和，而前缀和直接用收尾的前缀和相减即可得到。但是为了优化代码和简化操作，这里实际上是前缀和的余数，一样的，他们对比的标准也是 nums 的余数。在下面的两层 for 循环内，我们不应该一个设置头一个设置尾进行循环，而是应该一个设置长度，一个设置头，这样找到一个最小的子数组就可以直接返回了。</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果子数组的余数 == 整个数组的余数，则就是答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 前缀和的余数</span></span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 整个nums的余数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            y = (y + nums[i] % p) % p;</span><br><span class="line">            pre[i] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果整个nums的余数就是0，那么无需操作</span></span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;     <span class="comment">//子数组的长度</span></span><br><span class="line">            <span class="comment">// 子数组的起点下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> start=<span class="number">0</span>;start&lt;=n-i;start++) &#123;</span><br><span class="line">                <span class="comment">// 如果起点下标为0</span></span><br><span class="line">                <span class="keyword">if</span> (start==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pre[i-<span class="number">1</span>]==y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果起点下标不是0</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((pre[start+i-<span class="number">1</span>] - pre[start-<span class="number">1</span>] + p)%p == y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="经营摩天轮的最大利润">1599. 经营摩天轮的最大利润</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303051034143.png" /></p>
<p>中等题，读懂题目很重要！代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperationsMaxProfit</span><span class="params">(<span class="type">int</span>[] customers, <span class="type">int</span> boardingCost, <span class="type">int</span> runningCost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">surplus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=customers.length;i++) &#123;</span><br><span class="line">            surplus += customers[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 这一圈一定会亏损，如果需要转，在后面计算的时候会默认转，如果不转，这里的最大盈利就是当前的上一个情况的盈利值。</span></span><br><span class="line">            <span class="keyword">if</span> (surplus==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (surplus&lt;<span class="number">4</span> &amp;&amp; surplus&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                ready += surplus;</span><br><span class="line">                surplus = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;      <span class="comment">// &gt;=4个人</span></span><br><span class="line">                ready += <span class="number">4</span>;</span><br><span class="line">                surplus -= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ready * boardingCost - i * runningCost &gt; res) &#123;</span><br><span class="line">                res = ready * boardingCost - i * runningCost;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 游客不再添加</span></span><br><span class="line">        <span class="keyword">while</span> (surplus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (surplus &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">                ready += surplus;</span><br><span class="line">                <span class="keyword">if</span> (ready * boardingCost - i * runningCost &gt; res) &#123;</span><br><span class="line">                    res = ready * boardingCost - i * runningCost;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ready += <span class="number">4</span>;</span><br><span class="line">                surplus -= <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span> (ready * boardingCost - i * runningCost &gt; res) &#123;</span><br><span class="line">                    res = ready * boardingCost - i * runningCost;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (res&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="警告一小时内使用相同员工卡大于等于三次的人">1604. 警告一小时内使用相同员工卡大于等于三次的人</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302071247679.png" /></p>
<p>我们先用哈希表 hash 记录每个员工的所有打卡时间。注意这里需要将字符串的时间转为以分钟为单位的整形时间。</p>
<p>然后遍历哈希表，对于每个员工，我们先判断员工的打卡次数是否大于等于 3，如果不是，则跳过该员工。否则，我们将该员工的所有打卡时间按照时间先后排序，然后遍历排序后的打卡时间，判断下标距离为 2 的两个时间是否在同一小时内，如果是，则将该员工加入答案数组。</p>
<p>最后，将答案数组按照字典序排序，即可得到答案。</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">alertNames</span><span class="params">(String[] keyName, String[] keyTime)</span> &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;Integer&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;keyName.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Integer.parseInt(keyTime[i].substring(<span class="number">0</span>, <span class="number">2</span>)) * <span class="number">60</span> + Integer.parseInt(keyTime[i].substring(<span class="number">3</span>));     <span class="comment">//将时间转为分钟</span></span><br><span class="line">            <span class="keyword">if</span> (!hash.containsKey(keyName[i])) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                al.add(t);</span><br><span class="line">                hash.put(keyName[i],al);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; al = hash.get(keyName[i]);</span><br><span class="line">                al.add(t);</span><br><span class="line">                hash.replace(keyName[i],al);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            ArrayList&lt;Integer&gt; value = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value.size()&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Collections.sort(value);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;value.size()-<span class="number">2</span>;i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value.get(i+<span class="number">2</span>)-value.get(i)&lt;=<span class="number">60</span>) &#123;</span><br><span class="line">                        res.add(key);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="给定行和列的和求可行矩阵">1605. 给定行和列的和求可行矩阵</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303140824625.png" /></p>
<p>贪心到底。每次 <code>res[i][j] = Math.min(rowSum[i],colSum[j])</code> 并同时更新 <code>rowSum[i] -= res[i][j]</code> 和 <code>colSum[j] -= res[i][j]</code>，一定存在解。详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] restoreMatrix(<span class="type">int</span>[] rowSum, <span class="type">int</span>[] colSum) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> rowSum.length;    <span class="comment">// 行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> colSum.length;    <span class="comment">// 列</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                res[i][j] = Math.min(rowSum[i],colSum[j]);</span><br><span class="line">                rowSum[i] -= res[i][j];</span><br><span class="line">                colSum[j] -= res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大网络秩">1615. 最大网络秩</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303150823244.png" /></p>
<p>中等题，但是比较简单想到，利用邻接矩阵再小优化即可，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n][n+<span class="number">1</span>];     <span class="comment">//最后一列记录总数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] road : roads) &#123;</span><br><span class="line">            map[road[<span class="number">0</span>]][road[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            map[road[<span class="number">0</span>]][n]++;</span><br><span class="line">            map[road[<span class="number">1</span>]][road[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">            map[road[<span class="number">1</span>]][n]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    max = Math.max(max, map[i][n]+map[j][n]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, map[i][n]+map[j][n]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;n+1;j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(map[i][j]);</span></span><br><span class="line">        <span class="comment">//         System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分割两个字符串得到回文串">1616. 分割两个字符串得到回文串⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303181158607.png" /></p>
<blockquote>
<p>考察： #回文串</p>
</blockquote>
<p>中等题，但是想要在 O (n) 的时间复杂度里通过还是需要思考的。</p>
<p>我们可以分为两种情况，分别是 a 在 b 前面和 b 在 a 前面。现在讨论 a 在 b 前面的情况，我们可以直接进行判断 a 的头和 b 的尾是否相等，如果相等，则双指针继续往中间移动。如果直到两个指针遇到了，那就表示一定可以 true，如果在某一处两个指针不相等，那么开始判断 a 或者 b 这两个指针之间的元素是不是构成回文串，如果 a 或者 b 构成，那么也 true，如果不行则返回 false。讨论 b 在 a 前面的情况同理。</p>
<blockquote>
<p>举个例子：<br />
a = abcabaaaa<br />
b = aaabdacba<br />
按照上面的规则：<br />
abc|abaaaa<br />
aaabda|cba<br />
我们需要判断 aba 或者 bda 是不是回文串，如本例，第一个 a 子串的 aba 是，那么最后可以划分：<br />
<strong>abcaba</strong>|aaa<br />
aaabda|<strong>cba</strong><br />
变成：abcabacba</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i]!=sc[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span> <span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j &amp;&amp; a.charAt(i)==b.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (isPalindrome(a,i,j) || isPalindrome(b,i,j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (check(a,b) || check(b,a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="执行操作后字典序最小的字符串">1625. 执行操作后字典序最小的字符串</h1>
<blockquote>
<p>考察： #哈希 #队列</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303191053748.png" /></p>
<p>中等题，利用 Hash 存储和 queue 队列进行判断。每次从队列中取出一个字符串，对它做两种操作，如果已经存在于 hash 中，则不管；如果没有在 hash 中，则存入 hash，并再放入 queue 中。结束条件为：队列为空。</p>
<blockquote>
<p>感悟：本题说明了，bfs 是利用队列进行完成，优化可以搭配 hash 进行查重（hash 可以是 hashset、treeset、hashmap 等等，只要包含 contains () 即可）</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Add</span><span class="params">(String s, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i=i-<span class="number">2</span>) &#123;</span><br><span class="line">            sc[i] = Integer.toString((sc[i] - <span class="string">&#x27;0&#x27;</span> + a)%<span class="number">10</span>).charAt(<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> String.valueOf(sc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Rotate</span><span class="params">(String s, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">return</span> s.substring(n-b) + s.substring(<span class="number">0</span>,n-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLexSmallestString</span><span class="params">(String s, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> s;</span><br><span class="line">        Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        dq.addLast(s);</span><br><span class="line">        ts.add(s);</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (res.compareTo(t)&gt;<span class="number">0</span>) &#123;     <span class="comment">//res更大</span></span><br><span class="line">                res = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Add(t,a);</span><br><span class="line">            <span class="keyword">if</span> (!ts.contains(s1)) &#123;</span><br><span class="line">                ts.add(s1);</span><br><span class="line">                dq.addLast(s1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Rotate(t,b);</span><br><span class="line">            <span class="keyword">if</span> (!ts.contains(s2)) &#123;</span><br><span class="line">                ts.add(s2);</span><br><span class="line">                dq.addLast(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="无矛盾的最佳球队">1626. 无矛盾的最佳球队⭐</h1>
<blockquote>
<p>考察： #动态规划 #最长递增子序列</p>
<p>基础题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303221004200.png" /></p>
<p>中等题，典型的动态规划题。</p>
<p>按照分数进行从小到大排序，分数相等的按照年龄进行从小到大排序。只需要从左向右遍历构建 dp，dp 数组表示以当前数结尾的最大和。每遍历一个数时，再从当前数左边那个数从右往左遍历，因为越往前面表示分数越小，如果满足条件那年龄应该是相等或者更小，所以如果前面的年龄更大则直接 continue，直到把前面遍历完，找到最大和放入这个数的 dp 下。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bestTeamScore</span><span class="params">(<span class="type">int</span>[] scores, <span class="type">int</span>[] ages)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scores.length;</span><br><span class="line">        <span class="type">int</span>[][] sl = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            sl[i][<span class="number">0</span>] = ages[i];</span><br><span class="line">            sl[i][<span class="number">1</span>] = scores[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(sl, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>]!=b[<span class="number">1</span>]) &#123;      <span class="comment">// 分数不一样，则按照分数从小到大</span></span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];      <span class="comment">// 分数一样，则按照年龄从小到大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = sl[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sl[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sl[j][<span class="number">0</span>]&gt;sl[i][<span class="number">0</span>]) &#123;     <span class="comment">//前面的表示分数小。如果前面的年龄更大</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m = Math.max(m, sl[i][<span class="number">1</span>] + dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m; </span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="等差子数组">1630. 等差子数组</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303230818106.png" /></p>
<p>中等题，但是暴力模拟即可。</p>
<p>用到了<strong>数组的深拷贝</strong>：<code>System.arraycopy(原数组, 原数组起点, 新数组, 新数组起点, 长度);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">checkArithmeticSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] l, <span class="type">int</span>[] r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, m = l.length;</span><br><span class="line">        ArrayList&lt;Boolean&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> l[i], right = r[i];</span><br><span class="line">            <span class="type">int</span>[] child = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">            System.arraycopy(nums, left, child, <span class="number">0</span>, right-left+<span class="number">1</span>);</span><br><span class="line">            Arrays.sort(child);</span><br><span class="line">            <span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span> child[<span class="number">1</span>]- child[<span class="number">0</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;child.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child[j]-child[j-<span class="number">1</span>] != dis) &#123;</span><br><span class="line">                    isTrue = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(isTrue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="两点之间不包含任何点的最宽垂直区域">1637. 两点之间不包含任何点的最宽垂直区域</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303300832320.png" /></p>
<p>中等题，但是很简单。</p>
<h1 id="统计只差一个字符的子串数目">1638. 统计只差一个字符的子串数目</h1>
<h2 id="方法一暴力">方法一、暴力</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303270843071.png" /></p>
<p>直接遍历两个字符串的起点 i、j，再同时遍历相同长度，看看在这个长度内是否只有一个不同，如果成立，sum++。时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p>
<h2 id="方法二极致优化">方法二、极致优化</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303271000198.png" /></p>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/solutions/2192600/tu-jie-fei-bao-li-onm-suan-fa-pythonjava-k5og/">题解</a>，复杂度 <span class="math inline">\(O(nm)\)</span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tc = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>-m; d&lt;n; d++) &#123;    <span class="comment">// d表示i比j的位置大多少（可以是负数），i表示sc的最后一个元素、j表示tc的最后一个元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, d);     <span class="comment">// i一定是&gt;=0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k0</span> <span class="operator">=</span> i - <span class="number">1</span>, k1 = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; i - d &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[i]!=tc[i-d]) &#123;     </span><br><span class="line">                    k0 = k1;</span><br><span class="line">                    k1 = i;     <span class="comment">//表示 (k0,k1] 是可以取s的起点</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum += k1 - k0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="能否连接形成数组">1640、能否连接形成数组</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626759.png" alt="image-20220922221718430" /><figcaption aria-hidden="true">image-20220922221718430</figcaption>
</figure>
<h1 id="统计字典序元音字符串的数目">1641. 统计字典序元音字符串的数目</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303292201695.png" /></p>
<p>中等题，找规律即可。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countVowelStrings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];   <span class="comment">// u o i e a</span></span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            map[i] = <span class="number">1</span> + map[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k&lt;=n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                map[i] += map[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="拆炸弹">1652、拆炸弹</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626760.png" alt="image-20220924104449440" /><figcaption aria-hidden="true">image-20220924104449440</figcaption>
</figure>
<p>负数的求余：</p>
<p>被除数的绝对值与除数绝对值取余的值即为余数绝对值，余数符号与被除数一致。</p>
<h1 id="使字符串平衡的最少删除次数">1653. 使字符串平衡的最少删除次数⭐</h1>
<h2 id="方法一分割">方法一、分割</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061024105.png" /></p>
<p>中等题，遍历分隔符。在分隔符的左边删掉 b，右边（及其自己）删掉 a。记录删除最少时的位置所删除的次数。<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/solutions/2149746/qian-hou-zhui-fen-jie-yi-zhang-tu-miao-d-dor2/">题解</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] nn = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i]==<span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">// 带当前i下标的前面的b</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[i]==<span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                    nn[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                    nn[<span class="number">1</span>][i] = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nn[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">                    nn[<span class="number">1</span>][i] = a;</span><br><span class="line">                    a--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc[i]==<span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                nn[<span class="number">0</span>][i] = nn[<span class="number">0</span>][i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                nn[<span class="number">1</span>][i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nn[<span class="number">0</span>][i] = nn[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">                nn[<span class="number">1</span>][i] = a;</span><br><span class="line">                a--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;    <span class="comment">//i和i之后的都是b，删a</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                res = Math.min(res,nn[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i==n) &#123;</span><br><span class="line">                res = Math.min(res,nn[<span class="number">0</span>][i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.min(res,nn[<span class="number">0</span>][i-<span class="number">1</span>] + nn[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划-6">方法二、动态规划</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061103971.png" /></p>
<p>考虑 s 的最后一个字母：</p>
<ul>
<li>如果它是‘b’，则无需删除，问题规模缩小，变成「使 s 的前 n−1 个字母平衡的最少删除次数」。</li>
<li>如果它是‘a’：
<ul>
<li>删除它，则答案为「使 s 的前 n−1 个字母平衡的最少删除次数」加上 1。</li>
<li>保留它，那么前面的所有‘b’ 都要删除；</li>
</ul></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                bn++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.min(res + <span class="number">1</span>, bn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="将-x-减到-0-的最小操作数">1658. 将 x 减到 0 的最小操作数⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626799.png" alt="Pasted image 20230107130117" /><figcaption aria-hidden="true">Pasted image 20230107130117</figcaption>
</figure>
<p>本题较难，需要转换思路。</p>
<p>把问题转换成nums中移除一个最长的子数组，使得剩余元素的和为 x。 换句话说，要从nums中找最长的子数组，其元素和等于 s−x，这里 s为 nums所有元素之和。 最后答案为 nums 的长度减去最长子数组的长度。</p>
<p>题中想要找到两端最短和，转换思路就是<strong>找到 nums 的满足条件的最长子数组</strong>。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">snums</span> <span class="operator">=</span> Arrays.stream(nums).sum() - x;    <span class="comment">//找到最长的子数组，常读等于snums</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (snums&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; snums) &#123;      <span class="comment">//其实sum不可能减到负数的，应为while的限制条件会在减成0的时候及时打断</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == snums) &#123;</span><br><span class="line">                res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res==-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n-res;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求数组和：</span><br><span class="line">```java</span><br><span class="line">sum = Arrays.stream(nums).sum();</span><br></pre></td></tr></table></figure>
<h1 id="具有给定数值的最小字符串">1663. 具有给定数值的最小字符串</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626800.png" alt="Pasted image 20230126163114" /><figcaption aria-hidden="true">Pasted image 20230126163114</figcaption>
</figure>
<p>比较简单的题目~</p>
<h1 id="生成平衡数组的方案数">1664. 生成平衡数组的方案数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626801.png" alt="Pasted image 20230128112355" /><figcaption aria-hidden="true">Pasted image 20230128112355</figcaption>
</figure>
<p>比较简单的一题，维护两个数组，动态区分正向和反向的偶数和和奇数和。</p>
<h1 id="合并两个链表">1669. 合并两个链表</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626802.png" alt="Pasted image 20230131093641" /><figcaption aria-hidden="true">Pasted image 20230131093641</figcaption>
</figure>
<p>比较简单。唯一要注意的是指针在没有定义时为 <code>null</code>，而不是 <code>NULL</code>。</p>
<h1 id="重新格式化电话号码">1694、重新格式化电话号码</h1>
<h2 id="方法一常规逻辑">方法一、常规逻辑</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626761.png" alt="image-20221001102615465" /><figcaption aria-hidden="true">image-20221001102615465</figcaption>
</figure>
<p>先除去多余字符，再插入'-'</p>
<p>substring()使用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = s.substring(<span class="number">1</span>,<span class="number">5</span>);    <span class="comment">//截取下标1~4</span></span><br><span class="line"></span><br><span class="line">s = s.substring(<span class="number">5</span>);   <span class="comment">//截取下标为5~end</span></span><br></pre></td></tr></table></figure>
<p>replace()使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);    <span class="comment">//将全文的-变成无</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二stringbuilder方法">方法二、StringBuilder方法</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626762.png" alt="image-20221001115656084" /><figcaption aria-hidden="true">image-20221001115656084</figcaption>
</figure>
<blockquote>
<p>String内容是不可变的，StringBuilder内容是可变的</p>
<p>StringBuilder处理字符串性能比String好</p>
</blockquote>
<p>StringBuilder的创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure>
<p>StringBuilder的尾部插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.append(<span class="string">&quot;wry&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>StringBuilder的中间插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.insert(<span class="number">0</span>,<span class="string">&#x27;w&#x27;</span>);    <span class="comment">//在下标为0之前插入字符w</span></span><br></pre></td></tr></table></figure>
<p>StringBuilder的长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br></pre></td></tr></table></figure>
<p>StringBuilder的删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.delete(<span class="number">6</span>, <span class="number">14</span>);    <span class="comment">//删除下标为[6,14)</span></span><br></pre></td></tr></table></figure>
<p>StringBuilder转为String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure>
<p>String转为StringBuilder</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br></pre></td></tr></table></figure>
<h1 id="无法吃午餐的学生数量">1700、无法吃午餐的学生数量</h1>
<h2 id="方法一队列">方法一、队列</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626763.png" alt="image-20221019105203982" /><figcaption aria-hidden="true">image-20221019105203982</figcaption>
</figure>
<p>使用队列进行判断，容易想到。</p>
<h2 id="方法二优化-1">方法二、优化</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626764.png" alt="image-20221019105321277" /><figcaption aria-hidden="true">image-20221019105321277</figcaption>
</figure>
<p>披萨和学生数量相同，所以不会出现披萨没了学生还有的情况。</p>
<p>所以除了会因为卡在第一个披萨的情况而结束，就只可能是成功的状态而结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countStudents</span><span class="params">(<span class="type">int</span>[] students, <span class="type">int</span>[] sandwiches)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];    <span class="comment">//记录学生的0和1的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;students.length;i++) &#123;</span><br><span class="line">            nums[students[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sandwiches.length;i++) &#123;</span><br><span class="line">            nums[sandwiches[i]]--;</span><br><span class="line">            <span class="keyword">if</span> (nums[sandwiches[i]]==-<span class="number">1</span>) &#123;    <span class="comment">//表示本来就只有0个学生要这种披萨，但是目前披萨的第一个就是这种，所以在这里会卡住</span></span><br><span class="line">                <span class="keyword">return</span> sandwiches.length - i;    <span class="comment">//包含当前i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//披萨和学生数量相同，所以不会出现披萨没了学生还有的情况。</span></span><br><span class="line">        <span class="comment">//所以除了会因为卡在第一个披萨的情况而结束，就只可能是成功的状态而结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="放置盒子">1739、放置盒子🌟</h1>
<blockquote>
<p>题解：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/building-boxes/solutions/2031813/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-8vbe/">放置盒子</a></p>
</blockquote>
<h2 id="方法一数学找规律">方法一、数学找规律</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626803.png" alt="Pasted image 20221225135724" /><figcaption aria-hidden="true">Pasted image 20221225135724</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626804.png" alt="Pasted image 20221225135834" /><figcaption aria-hidden="true">Pasted image 20221225135834</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumBoxes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//底面数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//层数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//每层的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            cs += i;</span><br><span class="line">            sum += cs;</span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">                res = i*(i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">                sum -= cs;</span><br><span class="line">                c = i-<span class="number">1</span>;</span><br><span class="line">                res = c*(c+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c+<span class="number">1</span>;j++) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">                res += j;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">                res += j;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法-2开平方和开立方优化">方法 2、开平方和开立方优化</h2>
<p>详细看题解，不太会写……</p>
<h1 id="找到最高海拔">1732、找到最高海拔</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626805.png" alt="Screenshot_20221119_004204_com.huawei.browser" /><figcaption aria-hidden="true">Screenshot_20221119_004204_com.huawei.browser</figcaption>
</figure>
<p>简单题，没啥意思～</p>
<h1 id="删除字符串两端相同字符后的最短长度">1750. 删除字符串两端相同字符后的最短长度</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626806.png" alt="Pasted image 20221228112432" /><figcaption aria-hidden="true">Pasted image 20221228112432</figcaption>
</figure>
<p>很简单的题目，意义不大。</p>
<h1 id="检查数组是否经排序和轮转得到">1752、检查数组是否经排序和轮转得到</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626807.png" alt="Pasted image 20221127015201" /><figcaption aria-hidden="true">Pasted image 20221127015201</figcaption>
</figure>
<p>简单题，循环查数组，实现起来比较巧妙，判断是否有两个增区间，如果有则比较首位的大小；如果多于 2 个增区间，那就错；如果只有一个增区间，那就对。</p>
<h1 id="移除石子的最大得分">1753. 移除石子的最大得分</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626808.png" alt="Pasted image 20221221110600" /><figcaption aria-hidden="true">Pasted image 20221221110600</figcaption>
</figure>
<p>比较简单的一题，一共就三个数，每次动态选取最大的两个减 1 即可。</p>
<h1 id="构造字典序最大的合并字符串">1754、构造字典序最大的合并字符串⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626809.png" alt="Pasted image 20221224152639" /><figcaption aria-hidden="true">Pasted image 20221224152639</figcaption>
</figure>
<p>本题考查对 String 的 compareTo 的灵活运用，需要熟知 compareTo 的核心。compareTo 可以比较两个字符串，字典序和长度都会影响结果。</p>
<p>本题不能按照字符单独比较，因为如果出现：</p>
<blockquote>
<p>b a a b b a a a 按照字符比较，是 b a a b b a a a；但是正确的答案应该是 b b a a b a a a。</p>
</blockquote>
<p>因此只能用 compareTo 进行比较。每次提取较大的那个字符串的第一个字符，再继续比较，这样既考虑了大小比较，又考虑了上述例子中的情况。</p>
<blockquote>
<p>按照 compareTo 的情况： 分别出现：b (1) b (2) a (1) a (1) b (1) a (2) a (2) a (2)</p>
</blockquote>
<p>详细代码如下，代码不难，思想难：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestMerge</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> word1.length(), n2 = word2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n1 &amp;&amp; j&lt;n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.substring(i).compareTo(word2.substring(j))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(word1.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(word2.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;n1) &#123;</span><br><span class="line">            sb.append(word1.substring(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;n2) &#123;</span><br><span class="line">            sb.append(word2.substring(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="统计同构子字符串的数目">1759、统计同构子字符串的数目</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626810.png" alt="Pasted image 20221226002129" /><figcaption aria-hidden="true">Pasted image 20221226002129</figcaption>
</figure>
<p>简单题，注意 long 的定义和相加。</p>
<blockquote>
<p><code>res +=  (long)(i-start)*(i-start+1)/2%MOD;</code></p>
</blockquote>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countHomogenous</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// zzzzz</span></span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;    <span class="comment">//记录start</span></span><br><span class="line">            <span class="keyword">if</span> (sc[i]==sc[start]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res +=  (<span class="type">long</span>)(i-start)*(i-start+<span class="number">1</span>)/<span class="number">2</span>%MOD;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (<span class="type">long</span>)(n-start)*(n-start+<span class="number">1</span>)/<span class="number">2</span>%MOD;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="袋子里最少数目的球">1760、袋子里最少数目的球⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626811.png" alt="Pasted image 20221220135905" /><figcaption aria-hidden="true">Pasted image 20221220135905</figcaption>
</figure>
<p>二分法，思路较难。</p>
<p>题目想要求得<strong>最小的最大值</strong>，这很容易想到<strong>二分法</strong>。但是二分法要怎么用呢，这里就是二分遍历。每次找到一个数，如果它成立则往一边二分，否则往另一边二分。</p>
<p>观察题目发现，在只有“操作至多 maxOperations 次”这么一个条件的限制下，很难把握把袋子平均分成几份才是最好的。所以我们考虑人为增加一个条件，即“每个袋子至多有 y 个球”。</p>
<p>此时问题便转化成了“<strong>给定 maxOperations 次操作次数，能否可以使得单个袋子里球数目的最大值不超过 y</strong>”。</p>
<p>从 1 和 nums 数组的最大值之间二分。如果 y 可以实现，我们尝试继续压低 y，即将 right 更新为 y-1，然后继续二分；如果 y 不能实现，我们将 y 提高，即将此时 left 更新为 y+1，然后继续二分。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSize</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> maxOperations)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                opt += (num-<span class="number">1</span>) / r;     <span class="comment">//如果刚好满足r，那么就不用分袋子了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (opt&gt;maxOperations) &#123;</span><br><span class="line">                left = r+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="通过连接另一个数组的子数组得到一个数组">1764. 通过连接另一个数组的子数组得到一个数组⭐⭐</h1>
<h2 id="方法一kmp">方法一、KMP⭐</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303131131903.png" /></p>
<p>经典 KMP，考察的就是 KMP 的计算和 next 数组的构建。</p>
<blockquote>
<p>KMP 算法的实现步骤其实就是：text（长） 和 pattern（短） 数组进行匹配，当在 <code>text[i]</code> 和 <code>pattern[j]</code> 位置发生了第一次的不相同，但是可以清楚 <code>pattern[0]~pattern[j-1]</code> 的位置和 <code>text[j]</code> 往前 <code>j</code> 个元素都是相同的。KMP 要求 <code>i</code> 不动，但 <code>j</code> 要进行移动到 <code>new_j</code>，使得 <code>pattern[0]~pattern[new_j]</code> 与 <code>text[i]</code> 前 <code>new_j</code> 个元素完全相等。</p>
<p>现在如何从 <code>j</code> 找到这个 <code>new_j</code> 就是新的问题。所以需要构建一个 next 数组，假设 <code>new_j=next[j]</code> ，那么 <code>0~new_j-1</code> 间的 <code>new_j</code> 个元素与 <code>j</code> 之前的 <code>new_j</code> 个元素都完全相同。此时可以直接比较 <code>text[i]</code> 和 <code>next[new_j]</code>，这表示已经匹配成功 <code>new_j</code> 个元素了。</p>
</blockquote>
<blockquote>
<p>注意：next 数组的长度和 group 的长度一致。默认 <code>next[0]=-1</code>，每一个<code>next[j]</code> 是为了求出 <code>next[j+1]</code>。</p>
</blockquote>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] GetNext(<span class="type">int</span>[] group) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> group.length;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, t = next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (j&lt;n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t==-<span class="number">1</span> || group[t]==group[j]) &#123;</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">// System.out.println(j);</span></span><br><span class="line">                next[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t = next[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] group, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] next = GetNext(group);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, m = group.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j==-<span class="number">1</span> || nums[start]==group[j]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j==m) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;    <span class="comment">//下一个数组的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canChoose</span><span class="params">(<span class="type">int</span>[][] groups, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] group : groups) &#123;</span><br><span class="line">            start = KMP(nums, group, start);</span><br><span class="line">            <span class="keyword">if</span> (start == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="所有子字符串美丽值之和">1781、所有子字符串美丽值之和</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626812.png" alt="Pasted image 20221224200703" /><figcaption aria-hidden="true">Pasted image 20221224200703</figcaption>
</figure>
<p>暴力解法。循环固定左端和右端，再遍历这一段，找到最大和最小出现的次数，加入 res，3 个嵌套 for。意义不大。</p>
<h1 id="检查二进制字符串字段">1784、检查二进制字符串字段</h1>
<h2 id="方法一正常思路">方法一、正常思路</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626765.png" alt="image-20221003091100144" /><figcaption aria-hidden="true">image-20221003091100144</figcaption>
</figure>
<h2 id="方法二一行代码">方法二、一行代码</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626766.png" alt="image-20221003091323854" /><figcaption aria-hidden="true">image-20221003091323854</figcaption>
</figure>
<p>本题可以转化为只能出现一次<code>10</code>，也就是只能出现111111000000这种情况。</p>
<h1 id="构成特定和需要添加的最少元素">1785. 构成特定和需要添加的最少元素</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303130848990.png" /></p>
<p>虽然是中等题，但是很简单。只需要分类讨论：</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303130849378.jpg" alt="2191a50b89ff4f95a40b9bad3641d54.jpg" /><figcaption aria-hidden="true">2191a50b89ff4f95a40b9bad3641d54.jpg</figcaption>
</figure>
<p>根据规律，不难发现，其实只要将 dis 都转为正数，循环与 limit 比较即可。或者直接进行除法操作，注意存在什么都不用操作的可能。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minElements</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            dis += n;</span><br><span class="line">        &#125;</span><br><span class="line">        dis = Math.abs(dis-goal);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)((dis + limit - <span class="number">1</span>) / limit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="仅执行一次字符串交换能否使两个字符串相等">1790、仅执行一次字符串交换能否使两个字符串相等</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626767.png" alt="image-20221011221427327" /><figcaption aria-hidden="true">image-20221011221427327</figcaption>
</figure>
<p>思路简单，不多说了。</p>
<h1 id="最大平均通过率">1792. 最大平均通过率⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302201059163.png" /></p>
<p>中等题，但是不太好想，如果有思路就会很简单。</p>
<p>首先我考虑的时背包问题，但是一顿操作后并不能实现。根据 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-average-pass-ratio/solutions/2119717/python3javacgo-yi-ti-yi-jie-you-xian-dui-qrmo/">题解</a>，转换了思路，每次加一个学生，选择增量最大的确定永久增加，循环判断即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302201102769.png" /></p>
<p>这里考察<a href="LeetCode总结笔记.md#大根堆">大根堆</a>的构建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxAverageRatio</span><span class="params">(<span class="type">int</span>[][] classes, <span class="type">int</span> extraStudents)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> classes.length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">double</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">double</span>[]&gt;((a,b) -&gt; &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> (a[<span class="number">0</span>]+<span class="number">1</span>)/(a[<span class="number">1</span>]+<span class="number">1</span>) - a[<span class="number">0</span>]/a[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (b[<span class="number">0</span>]+<span class="number">1</span>)/(b[<span class="number">1</span>]+<span class="number">1</span>) - b[<span class="number">0</span>]/b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> Double.compare(y, x);     <span class="comment">//如果后面的增量比前面的增量大，那么返回正值，则调换顺序</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] cl : classes) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;(<span class="type">double</span>)cl[<span class="number">0</span>],(<span class="type">double</span>)cl[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;extraStudents;i++) &#123;    </span><br><span class="line">            <span class="type">double</span>[] temp = q.poll();</span><br><span class="line">            temp[<span class="number">0</span>]++;</span><br><span class="line">            temp[<span class="number">1</span>]++;</span><br><span class="line">            q.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">double</span>[] temp = q.poll();</span><br><span class="line">            res += temp[<span class="number">0</span>]/temp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res/c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tips-1">tips</h2>
<p>double 元素比较大小，使用 <code>Double.compare(x,y)</code>，如果 <code>x&gt;y</code> 则返回正数，如果 <code>y&gt;x</code> 则返回负数。</p>
<h1 id="设计一个验证系统">1797. 设计一个验证系统</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302121226049.png" /></p>
<p>普通工程题，意义不大。</p>
<p>注意：hashmap 在 put 时如果有相同 key，value 会进行覆盖。</p>
<h1 id="你能构造出连续值的最大数目">1798. 你能构造出连续值的最大数目⭐</h1>
<h2 id="方法一动态规划贪心算法">方法一、动态规划+贪心算法</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302042351940.png" /></p>
<p>利用动态规划的思想。先使 coins 升序，我们假设 res 之前的数（连续的）都能凑出来，那么在考察 res 时，如果 coins[i] 能小于 res，那么 coins[i] 加上 res-coins[i] 就可以构造出来 res，其中 res-coins[i] 是一定能构造出来的；如果 coins[i]大于 res，那么没有办法通过加上什么数达到当前需要的 res。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumConsecutive</span><span class="params">(<span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c&gt;res) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="n-次操作后的最大分数和">1799. N 次操作后的最大分数和⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626814.png" alt="Pasted image 20221222132834" /><figcaption aria-hidden="true">Pasted image 20221222132834</figcaption>
</figure>
<p><strong>动态规划+位运算压缩存储</strong></p>
<p>难题!!!</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626815.png" alt="Pasted image 20221222133224" /><figcaption aria-hidden="true">Pasted image 20221222133224</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x%y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最大公约数矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] gcdmap = <span class="keyword">new</span> <span class="title class_">int</span>[l][l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;l;j++) &#123;</span><br><span class="line">                gcdmap[i][j] = gcd(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造res向量，下标i表示位运算中已经包含的值的最大结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; l;     <span class="comment">//一共l个数，则1后面l个0。len的十进制所表示的是多个元素的组合</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">		<span class="comment">//表示res的下标从0（还没有一个元素进行判断），到二进制全是1（表示所有元素都判断完了）（res[len-1]就是我们要的最终结果）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;len;k++) &#123;      </span><br><span class="line">            <span class="comment">//对k中的任意一对数据拿出来，比较res[k]和没有这对数据时的res+这对数据的得分的最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> Integer.bitCount(k);     <span class="comment">//判断k的二进制由多少个1组成</span></span><br><span class="line">            <span class="keyword">if</span> (cnt%<span class="number">2</span>==<span class="number">0</span>) &#123;     <span class="comment">//偶数个1，表示成对的，那么可以进行判断</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;     <span class="comment">//i表示第一个数是从nums[0]到nums[i-1]</span></span><br><span class="line">                    <span class="keyword">if</span> (((k&gt;&gt;i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;     <span class="comment">//如果第i个数据是在这个k中的</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;l;j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (((k&gt;&gt;j) &amp; <span class="number">1</span>) ==<span class="number">1</span>) &#123;     <span class="comment">//i和j两个数据都在k中，可以按照计划进行判断</span></span><br><span class="line">                                res[k] = Math.max(res[k],res[k^(<span class="number">1</span>&lt;&lt;i)^(<span class="number">1</span>&lt;&lt;j)]+cnt/<span class="number">2</span>*gcdmap[i][j]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最大升序子数组和">1800、最大升序子数组和</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626768.png" alt="image-20221007095515941" /><figcaption aria-hidden="true">image-20221007095515941</figcaption>
</figure>
<p>思路简单，只要判断当前值是否比上一个值大，如果大，那以当前值结尾的最大升序子数组和 = 以上一个值为结尾的最大升序子数组和 + 当前值的大小。否则值为本身。</p>
<h1 id="积压订单中的订单总数">1801、积压订单中的订单总数</h1>
<h2 id="方法一hashmap-搜索arraylist-排序">方法一、HashMap 搜索+ArrayList 排序</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626816.png" alt="Pasted image 20230102130246" /><figcaption aria-hidden="true">Pasted image 20230102130246</figcaption>
</figure>
<p>思路比较简单，设置两个 hash 和两个 list，list 用来存储值，分别从小到大排序和从大到小排序，hash 可以根据 list 的值作为 key 查到对应的数量，再进行处理。涉及的 Java 基础语法比较多。</p>
<blockquote>
<p>需要注意 <code>(int)(res%MOD)</code> 才是正确的返回，<code>(int)res%MOD</code> 不对。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfBacklogOrders</span><span class="params">(<span class="type">int</span>[][] orders)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; buy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; sell = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; buylist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="comment">//从大到小</span></span><br><span class="line">        ArrayList&lt;Integer&gt; selllist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();   <span class="comment">//从小到大</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//buy大于sell才能抵消</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] or : orders) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (or[<span class="number">2</span>]==<span class="number">0</span>) &#123;    <span class="comment">//表示buy采购，要找到小于等于它的最小的sell</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 or[0]&gt;=selllist.get(0) &amp;&amp; or[1]&gt;0，可以进行判断</span></span><br><span class="line">                <span class="comment">// 如果只满足 or[0]&gt;=selllist.get(0) 但不满足 or[1]&gt;0，直接退出</span></span><br><span class="line">                <span class="comment">// 如果只满足 or[1]&gt;0 但不满足 or[0]&gt;=selllist.get(0)，直接退出</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (selllist.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (or[<span class="number">0</span>]&gt;=selllist.get(<span class="number">0</span>) &amp;&amp; or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> selllist.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> sell.get(key);      <span class="comment">//当前sell值得数量</span></span><br><span class="line">                        <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;=value) &#123;    <span class="comment">//如果要加入的buy的值数量大于等于sell最小值的数量</span></span><br><span class="line">                            or[<span class="number">1</span>] -= value;</span><br><span class="line">                            <span class="comment">//将sell和selllist都删除对应的数据</span></span><br><span class="line">                            sell.remove(key);</span><br><span class="line">                            selllist.remove(<span class="number">0</span>);      <span class="comment">//可以进行接下来的判断 </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            sell.replace(key,value-or[<span class="number">1</span>]);   <span class="comment">//更新sell散列表中的对应关系</span></span><br><span class="line">                            or[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;    <span class="comment">//只有当or[1]&gt;0时，表示现有的sell中没有比当前buy小的值了</span></span><br><span class="line">                    buy.put(or[<span class="number">0</span>],(buy.getOrDefault(or[<span class="number">0</span>],<span class="number">0</span>)+or[<span class="number">1</span>])%MOD);     <span class="comment">//如果原本就有这个值，那么取原来的值加上现在的值；如果原来没有，则设置初始值default为0再加上现在的值。</span></span><br><span class="line">                    buylist.add(or[<span class="number">0</span>]);</span><br><span class="line">                    Collections.sort(buylist, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;    <span class="comment">//升序排序</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer n1, Integer n2)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> n2-n1;   <span class="comment">//如果return&gt;0则需要对调</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;        <span class="comment">//表示sell采购，要找到大于等于它的最大的buy</span></span><br><span class="line">                <span class="keyword">while</span> (buylist.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (or[<span class="number">0</span>]&lt;=buylist.get(<span class="number">0</span>) &amp;&amp; or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> buylist.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buy.get(key);      <span class="comment">//当前sell值得数量</span></span><br><span class="line">                        <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;=value) &#123;   </span><br><span class="line">                            or[<span class="number">1</span>] -= value;</span><br><span class="line">                            buy.remove(key);</span><br><span class="line">                            buylist.remove(<span class="number">0</span>); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            buy.replace(key,value-or[<span class="number">1</span>]);</span><br><span class="line">                            or[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123; </span><br><span class="line">                    sell.put(or[<span class="number">0</span>],(sell.getOrDefault(or[<span class="number">0</span>],<span class="number">0</span>)+or[<span class="number">1</span>])%MOD);</span><br><span class="line">                    selllist.add(or[<span class="number">0</span>]);</span><br><span class="line">                    Collections.sort(selllist);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;=================buy====================&quot;);</span></span><br><span class="line">            <span class="comment">// System.out.print(buy.keySet());</span></span><br><span class="line">            <span class="comment">// System.out.println(buy.values());</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;=================sell====================&quot;);</span></span><br><span class="line">            <span class="comment">// System.out.print(sell.keySet());</span></span><br><span class="line">            <span class="comment">// System.out.println(sell.values());</span></span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : sell.values()) &#123;</span><br><span class="line">            res += (<span class="type">long</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : buy.values()) &#123;</span><br><span class="line">            res += (<span class="type">long</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二题解">方法二、题解🐶</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626817.png" alt="Pasted image 20230102131042" /><figcaption aria-hidden="true">Pasted image 20230102131042</figcaption>
</figure>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-orders-in-the-backlog/solutions/2041077/by-lcbin-vf1s/">题解</a></p>
<h1 id="有界数组中指定下标处的最大值">1802. 有界数组中指定下标处的最大值</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626818.png" alt="Pasted image 20230104230948" /><figcaption aria-hidden="true">Pasted image 20230104230948</figcaption>
</figure>
<p>根据题目要求，其实只要从 index 左右递减，每次减少 1，如果还有多余的空位，全部设置为 1 即可。（getsum ()) 函数）</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626819.png" alt="0631e4632dfc62297ea12dadffdee8a" /><figcaption aria-hidden="true">0631e4632dfc62297ea12dadffdee8a</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getsum</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> len)</span> &#123;     <span class="comment">//注意x必须是long，否则会在下面的乘法中越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; len) &#123;     <span class="comment">//有多余的1</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>)((<span class="number">1</span>+x)*x/<span class="number">2</span> + (len-x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>)((x-len+<span class="number">1</span>+x)*len/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> maxSum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">llen</span> <span class="operator">=</span> index + <span class="number">1</span>, rlen = n - index;       <span class="comment">//这里的长度是包括当前mid的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = maxSum;     <span class="comment">//right设置为maxsum，不能是n（nums.length）</span></span><br><span class="line">        <span class="comment">//找满足条件的最大的</span></span><br><span class="line">        <span class="comment">//需要在当前满足条件的前提下，不断右移，需要left存储最后一个判断成功的满足条件的</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((getsum(mid,llen)+getsum(mid,rlen)-mid)&lt;=maxSum) &#123;     <span class="comment">//注意需要减去重复加上的mid值</span></span><br><span class="line">                left = mid;    <span class="comment">//left不断存储成功的最大的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="还原排列的最少操作步数">1806、还原排列的最少操作步数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626820.png" alt="Pasted image 20230109015856" /><figcaption aria-hidden="true">Pasted image 20230109015856</figcaption>
</figure>
<p>中等题，通过列举多个情况找规律即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reinitializePermutation</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (loc*<span class="number">2</span>&gt;=<span class="number">1</span> &amp;&amp; loc*<span class="number">2</span>&lt;n-<span class="number">1</span>) &#123;</span><br><span class="line">                loc = loc * <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                loc = (loc * <span class="number">2</span> - n) + <span class="number">1</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (loc!=<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="替换字符串中的括号内容">1807. 替换字符串中的括号内容</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626821.png" alt="Pasted image 20230112200229" /><figcaption aria-hidden="true">Pasted image 20230112200229</figcaption>
</figure>
<p>hash 的和 stringbuidler 的结合应用。比较简单~</p>
<h2 id="句子相似性-iii">1813、句子相似性 III⭐</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626822.png" alt="Pasted image 20230116024951" /><figcaption aria-hidden="true">Pasted image 20230116024951</figcaption>
</figure>
<p>简单但是需要考虑的比较多的题目。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCon</span><span class="params">(String s1,String s2)</span> &#123;    <span class="comment">//判断s2是否包含在s1中且符合条件</span></span><br><span class="line">        String[] str1 = s1.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] str2 = s2.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> str2.length;     <span class="comment">//n1一定大于n2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str1[i].equals(str2[i])) &#123;     <span class="comment">//说明最左边匹配成功</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!str1[i].equals(str2[i])) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==n2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//左匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n1-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> n2-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str1[j].equals(str2[t])) &#123;        <span class="comment">//说明最右边匹配成功</span></span><br><span class="line">            <span class="keyword">for</span> (j=n1-<span class="number">1</span>,t=n2-<span class="number">1</span>;t&gt;=i;t--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!str1[j].equals(str2[t])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==t+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilar</span><span class="params">(String sentence1, String sentence2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> sentence1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> sentence2.length();</span><br><span class="line">        <span class="keyword">if</span> (n1&lt;n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> isCon(sentence2,sentence1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n1&gt;n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> isCon(sentence1,sentence2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sentence1.equals(sentence2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="统计一个数组中好对子的数目">1814. 统计一个数组中好对子的数目</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626823.png" alt="Pasted image 20230117122523" /><figcaption aria-hidden="true">Pasted image 20230117122523</figcaption>
</figure>
<p>比较难想也比较难操作的一题。核心思路：</p>
<p><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code> 与 <code>nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</code> 等价</p>
<p>此外，还需要注意在乘法时 long 的乘法，(long) 只能将紧跟着的变量或者括号强制转化为 long，如果后面跟的是括号，括号里的内容会先按照原来类型进行运算，再强转。</p>
<p><strong>所以：<code>res = (res + (long)((i-left)*(i-left-1)/2)%MOD);</code> 可能会越界，但是 <code>res = (res + (long)(i-left)*(i-left-1)/2)%MOD;</code> 不会</strong></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rev</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + n%<span class="number">10</span>;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNicePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(rev(nums[i]));</span></span><br><span class="line">            nums[i] = nums[i] - rev(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(nums[i]);</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-left &gt; <span class="number">1</span>) &#123;   <span class="comment">//不止一个数，能为数对</span></span><br><span class="line">                    res = (res + (<span class="type">long</span>)(i-left)*(i-left-<span class="number">1</span>)/<span class="number">2</span>)%MOD;     <span class="comment">//下标为3 4 5 6 7，实际上相同是4个，也就是3 4 5 6，一共有3+2+1对，即(1+3)*3/2</span></span><br><span class="line">                &#125;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(n);</span></span><br><span class="line">            res = (res + (<span class="type">long</span>)(n-left)*(n-left-<span class="number">1</span>)/<span class="number">2</span>)%MOD;   <span class="comment">//下标为6 7 (8)，实际上相同是2个，也就是6 7, 一共1对，即(1+(2-1))*(2-1)/2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找用户活跃分钟数">1817. 查找用户活跃分钟数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626824.png" alt="Pasted image 20230120125215" /><figcaption aria-hidden="true">Pasted image 20230120125215</figcaption>
</figure>
<p>虽然是中等题，但是很简单，只要注意使用<a href="LeetCode总结笔记.md#数组#自定义排序">数组的自定义排序</a>即可。</p>
<h1 id="序列中不同最大公约数的数目">1819. 序列中不同最大公约数的数目⭐</h1>
<p>困难题，原本思路是使用 list 和 hashmap 对 nums 的每对元素求最大公约数，但是超时。此方法不可行。注意：根据题目要求，每个单独的元素也算答案。</p>
<p><strong>0 和任何数 x 的最大公约数都是 x</strong></p>
<h2 id="方法一枚举">方法一、枚举</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626825.png" alt="Pasted image 20230114133455" /><figcaption aria-hidden="true">Pasted image 20230114133455</figcaption>
</figure>
<p>需要转换思路，枚举以 i 为因子的所有数，如果有 2 个或 2 个以上的数存在，判断这些数的最大公约数是不是 i，如果是，那么 res++。注意，每个单独元素也算答案。</p>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gys</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDifferentSubsequenceGCDs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] ishas = <span class="keyword">new</span> <span class="title class_">boolean</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            ishas[n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max;i++) &#123;     <span class="comment">//公约数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=max;j=j+i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ishas[j]) &#123;</span><br><span class="line">                    g = gys(j,g);      <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g==i) &#123;    <span class="comment">//表示满足存在2个或2个以上的数，使得i作为最大公约数</span></span><br><span class="line">                res++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二枚举优化">方法二、枚举优化</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626826.png" alt="Pasted image 20230114133600" /><figcaption aria-hidden="true">Pasted image 20230114133600</figcaption>
</figure>
<p>在嵌套的 for 的判断中增加：<code>g!=i</code>，这表示如果出现 <code>g==i</code> 的情况，也就是出现 2 个或 2 个以上的数，使得 i 作为最大公约数，那么直接可以跳出循环，返回 i。</p>
<p>详细代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gys</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDifferentSubsequenceGCDs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] ishas = <span class="keyword">new</span> <span class="title class_">boolean</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            ishas[n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max;i++) &#123;     <span class="comment">//公约数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=max &amp;&amp; g!=i;j=j+i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ishas[j]) &#123;</span><br><span class="line">                    g = gys(j,g);      <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g==i) &#123;    <span class="comment">//表示满足存在2个或2个以上的数，使得i作为最大公约数</span></span><br><span class="line">                res++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法三最强优化">方法三、最强优化</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-different-subsequences-gcds/solutions/2061079/ji-bai-100mei-ju-gcdxun-huan-you-hua-pyt-get7/">1819题解</a></p>
<h1 id="数组元素积的符号">1822、数组元素积的符号</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626769.png" alt="image-20221027101133285" /><figcaption aria-hidden="true">image-20221027101133285</figcaption>
</figure>
<p>简单模拟题……</p>
<h1 id="最少侧跳次数">1824. 最少侧跳次数⭐</h1>
<h2 id="方法一动态规划二维">方法一、动态规划（二维）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626827.png" alt="Pasted image 20230121124109" /><figcaption aria-hidden="true">Pasted image 20230121124109</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626828.png" alt="Pasted image 20230121124138" /><figcaption aria-hidden="true">Pasted image 20230121124138</figcaption>
</figure>
<p>简而言之，在 i 点的 j 跑道上的最小侧翻次数来源于两个值，<strong>一个是 i-1 点的 j 跑道，另一个是 i 点的其他跑道。</strong> 这里需要注意，在求 i 点的其他跑道的值的时候，这些值也是来源于 i-1 点的相应的跑道，所以需要分为两步进行，先计算由 i-1 点的 j 跑道计算得到的，再计算由 i 点的其他跑道计算得到的。i 点的其他跑道实际上就是 i 点所有跑道的 dp 最小值。</p>
<p>详细代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSideJumps</span><span class="params">(<span class="type">int</span>[] obstacles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacles.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> n+<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">//从上一个点到这个点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]==j+<span class="number">1</span>) &#123;    <span class="comment">//表示有石头</span></span><br><span class="line">                    dp[i][j] = MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min_step</span> <span class="operator">=</span> Math.min(dp[i][<span class="number">0</span>],Math.min(dp[i][<span class="number">1</span>],dp[i][<span class="number">2</span>]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]!=j+<span class="number">1</span>) &#123;    <span class="comment">//表示没有石头</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],min_step+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n-<span class="number">1</span>][<span class="number">0</span>],Math.min(dp[n-<span class="number">1</span>][<span class="number">1</span>],dp[n-<span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二动态规划优化一维">方法二、动态规划优化（一维）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626829.png" alt="Pasted image 20230121125056" /><figcaption aria-hidden="true">Pasted image 20230121125056</figcaption>
</figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSideJumps</span><span class="params">(<span class="type">int</span>[] obstacles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacles.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> n+<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">//从上一个点到这个点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]==j+<span class="number">1</span>) &#123;    <span class="comment">//表示有石头</span></span><br><span class="line">                    dp[j] = MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min_step</span> <span class="operator">=</span> Math.min(dp[<span class="number">0</span>],Math.min(dp[<span class="number">1</span>],dp[<span class="number">2</span>]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]!=j+<span class="number">1</span>) &#123;    <span class="comment">//表示没有石头</span></span><br><span class="line">                    dp[j] = Math.min(dp[j],min_step+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>],Math.min(dp[<span class="number">1</span>],dp[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="统计一个圆中点的数目">1828. 统计一个圆中点的数目</h1>
<h2 id="方法一暴力-1">方法一、暴力</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626830.png" alt="Pasted image 20230124124708" /><figcaption aria-hidden="true">Pasted image 20230124124708</figcaption>
</figure>
<p>意义不大的中等题。</p>
<h2 id="方法二压缩搜索">方法二、压缩搜索</h2>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/solutions/1531794/by-mumuxinfei-shnh/?topicTags=er-fen">1828题解</a></p>
<h1 id="句子相似性iii">1913、句子相似性III</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626770.png" alt="image-20221009155406386" /><figcaption aria-hidden="true">image-20221009155406386</figcaption>
</figure>
<p>对于题目只有三种情况：</p>
<ol type="1">
<li><p>A......</p>
<p>A</p></li>
<li><p>......A</p>
<p>​ A</p></li>
<li><p>A......B</p>
<p>AB</p></li>
</ol>
<p>首先要确定谁是长的句子，谁是短的句子。</p>
<p>可以从第一个单词进行匹配，如果匹配上了，说明一定是1、3情况，如果遇到匹配不成功的，则从各自的最后一个单词进行匹配，如果最后两个指针遇上了，则说明成立。结束的条件是短的字符串的做指针和右指针能遇上（i = t + 1）。具体思路可以看代码，更容易懂。</p>
<h1 id="寻找图中是否存在路径">1971. 寻找图中是否存在路径</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626831.png" alt="Pasted image 20221219132739" /><figcaption aria-hidden="true">Pasted image 20221219132739</figcaption>
</figure>
<p>典型 <a href="LeetCode总结笔记.md#并查集">并查集</a>题目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] bc, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bc[x]!=x) &#123;     <span class="comment">//如果自己不是根</span></span><br><span class="line">            bc[x] = find(bc,bc[x]);     <span class="comment">//将一条线上的所有的都变成直连根</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bc[x];    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] bc, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (find(bc,x)==find(bc,y)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bc[find(bc,x)] = find(bc,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] bc = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            bc[i] = i;     <span class="comment">// 初始每个节点的根就是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++) &#123;</span><br><span class="line">            union(bc,edges[i][<span class="number">0</span>],edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(bc[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (find(bc,source)==find(bc,destination)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="执行操作后的变量值">2011. 执行操作后的变量值</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626832.png" alt="Pasted image 20221223105336" /><figcaption aria-hidden="true">Pasted image 20221223105336</figcaption>
</figure>
<p>简单题，没意思~</p>
<h1 id="增量元素之间的最大差值">2016、增量元素之间的最大差值</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626771.png" alt="image-20221009153057630" /><figcaption aria-hidden="true">image-20221009153057630</figcaption>
</figure>
<p>本题思路很巧妙，目的是求一对升序的两个数，而且是差值最大的。</p>
<p>可以将左端点定为左边第一个数，开始遍历。</p>
<p>如果右边的某个值比左端点大，则记录他们之间的差值，并和已经保存的差值比较，保存更大的那个。</p>
<p>如果右边的某个值比左端点小，那么这个值就成为了新的左端点，然后再继续遍历。</p>
<blockquote>
<p>比如 3...9...2...10</p>
<p>以3作为左端点的时候，当遇到9时，res = 6</p>
<p>再往后遍历遇到比左端点3更小的2，那么更小左端点为2，继续往后遍历，遇到更大的10，发现差值为8，比6大，则更新res = 8</p>
</blockquote>
<h1 id="转换字符串的最少操作次数">2027. 转换字符串的最少操作次数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626833.png" alt="Pasted image 20221227115342" /><figcaption aria-hidden="true">Pasted image 20221227115342</figcaption>
</figure>
<p>简单题，不多说。</p>
<h1 id="链表最大孪生和">2130、链表最大孪生和</h1>
<h2 id="方法一常规遍历数组">方法一、常规遍历+数组</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626772.png" alt="image-20221014091817803" /><figcaption aria-hidden="true">image-20221014091817803</figcaption>
</figure>
<p>对链表遍历两次，第一次记录长度n；构建一个n/2长度的数据，第二次遍历的前一半直接放在数组中，后一半对数组从后往前分别加上，最后取得数组的最大值。</p>
<h2 id="方法二双端队列">方法二、双端队列</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626773.png" alt="image-20221014092114561" /><figcaption aria-hidden="true">image-20221014092114561</figcaption>
</figure>
<p>遍历一次链表，将所有的数值都按顺序加入队列中。对队列进行操作，如果队列不为空<code>!dq.isEmpyt()</code>，那么每次<code>pollFirst()</code>和<code>pollLast()</code>，并相加，用max记录最大的和，最后输出。</p>
<h1 id="至少在两个数组中出现的值">2032. 至少在两个数组中出现的值</h1>
<p>简单题，但涉及到<a href="LeetCode总结笔记.md#动态数组">动态数组</a>和<a href="LeetCode总结笔记.md#HashMap（散列表）">哈希表</a>。</p>
<h2 id="方法一hashmap位记录">方法一、HashMap+位记录</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626834.png" alt="Pasted image 20221229122222" /><figcaption aria-hidden="true">Pasted image 20221229122222</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">twoOutOfThree</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;(); </span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++) &#123;</span><br><span class="line">            hash.put(nums1[i], <span class="number">1</span>);     <span class="comment">//第1个有的在二进制第1位上至1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++) &#123;</span><br><span class="line">            hash.put(nums2[i], hash.getOrDefault(nums2[i],<span class="number">0</span>) | <span class="number">2</span>);   <span class="comment">//第2个有的在二进制第2位上至1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums3.length;i++) &#123;</span><br><span class="line">            hash.put(nums3[i], hash.getOrDefault(nums3[i],<span class="number">0</span>) | <span class="number">4</span>);   <span class="comment">//第3个有的在二进制第3位上至1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> ((v &amp; (v-<span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">                al.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二hashmap排序数量记录">方法二、HashMap+排序+数量记录</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626835.png" alt="Pasted image 20221229122416" /><figcaption aria-hidden="true">Pasted image 20221229122416</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">twoOutOfThree</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;(); </span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        Arrays.sort(nums3);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums1[i]==nums1[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums1[i], hash.getOrDefault(nums1[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums2[i]==nums2[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums2[i], hash.getOrDefault(nums2[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums3.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums3[i]==nums3[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums3[i], hash.getOrDefault(nums3[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">                al.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使每位学生都有座位的最少移动次数">2037. 使每位学生都有座位的最少移动次数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626836.png" alt="Pasted image 20221231002356" /><figcaption aria-hidden="true">Pasted image 20221231002356</figcaption>
</figure>
<p>简单题，只要将 seat 和 student 两个数组排序，然后对应相减取绝对值，最后相加即可。</p>
<h1 id="检查句子中的数字是否递增">2042. 检查句子中的数字是否递增</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626837.png" alt="Pasted image 20230103025153" /><figcaption aria-hidden="true">Pasted image 20230103025153</figcaption>
</figure>
<p>简单题，大脑清晰且认真即可。</p>
<h1 id="统计各位数字之和为偶数的整数个数">2180. 统计各位数字之和为偶数的整数个数</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626838.png" alt="Pasted image 20230106174004" /><figcaption aria-hidden="true">Pasted image 20230106174004</figcaption>
</figure>
<p>简单题，直接判断操作即可。</p>
<h1 id="统计包含给定前缀的字符串">2185. 统计包含给定前缀的字符串</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626839.png" alt="Pasted image 20230108010634" /><figcaption aria-hidden="true">Pasted image 20230108010634</figcaption>
</figure>
<p>简单题，没啥意思~</p>
<h1 id="按位与结果大于零的最长组合">2275、按位与结果大于零的最长组合</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626774.png" alt="image-20221009154203464" /><figcaption aria-hidden="true">image-20221009154203464</figcaption>
</figure>
<p>本题考到位运算，但是实际上思路很简单，就看能不能想到。</p>
<p><strong>a&amp;b什么情况下不为0？只有在某一位中全都是1的时候，他们一定是部位0的。</strong></p>
<p>因此，我们可以拓展到本题。</p>
<p>首先建立一个数组，用来记录所有数再某一位中为1的个数。（<strong>1e7&lt;2^25</strong>）</p>
<p>对每一个数进行遍历，如何找到这个数的每一位呢？</p>
<p>可以通过与00000001、00000010、00000100......进行与操作，如果结果不是0，那么就说明这一位为1。</p>
<p>这是一种思路，我们也可以对每个数每次与1与操作，然后右移一位，再与1与操作......（也就是题解的方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> candidates[i];</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//提取数字的每一位</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//将 1 位存起来</span></span><br><span class="line">    <span class="keyword">if</span> ((num &amp; <span class="number">1</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        times[j]++;</span><br><span class="line">    &#125; </span><br><span class="line">    num = num &gt;&gt; <span class="number">1</span>;   <span class="comment">//每次num的二进制向右移动一位</span></span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后取1最多的那个值，即为次数。如果某一位的1有y个，那么说明在这n个数中一定会有y个数，他们'且'后这一位为1（即结果不为0）。</p>
<h1 id="判断一个数的数字计数是否等于数位的值">2283. 判断一个数的数字计数是否等于数位的值</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626840.png" alt="Pasted image 20230111004354" /><figcaption aria-hidden="true">Pasted image 20230111004354</figcaption>
</figure>
<p>简单题，利用 hash 表进行处理即可。但是要注意 int 转为 char 的相关操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+i)</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">digitCount</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] nc = num.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            hash.put(nc[i], hash.getOrDefault(nc[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash.forEach((key,value)-&gt; &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(key);</span></span><br><span class="line">        <span class="comment">//     System.out.println(value);</span></span><br><span class="line">        <span class="comment">// &#125;);  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.getOrDefault((<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+i),<span class="number">0</span>)!=(nc[i]-<span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="重排字符形成目标字符串">2287. 重排字符形成目标字符串</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626841.png" alt="Pasted image 20230113170949" /><figcaption aria-hidden="true">Pasted image 20230113170949</figcaption>
</figure>
<p>虽然是简单题，但是本题的解题过程不简单。需要清楚的是：题目中只是要求用过的字符不能再次用，并没有说每次匹配好的那段所有的其他字符都不能用。因此只需要构造两个 hashmap，一个是用来记录 target 的每个字符出现的次数，另一个是记录 s 中在 target 的字符出现的次数，然后对应字符的次数相除，取最小值即可。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rearrangeCharacters</span><span class="params">(String s, String target)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tc = target.toCharArray();</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> t : tc) &#123;</span><br><span class="line">            hash2.put(t,hash2.getOrDefault(t,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash2.containsKey(c)) &#123;</span><br><span class="line">                hash1.put(c,hash1.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hash1.size()!=hash2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character,Integer&gt; entry : hash2.entrySet()) &#123;  </span><br><span class="line">            <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            sum = Math.min(sum, hash1.get(key)/entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="极大极小游戏">2293、极大极小游戏</h1>
<p>简单题，方法很多。</p>
<h2 id="方法一list-操作">方法一、list 操作</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626842.png" alt="Pasted image 20230115012636" /><figcaption aria-hidden="true">Pasted image 20230115012636</figcaption>
</figure>
<p>将 nums 转为 list，之后再操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMaxGame</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">while</span> (size!=<span class="number">1</span>) &#123;      <span class="comment">//多行的循环处理</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (size!=<span class="number">0</span>) &#123;       <span class="comment">//每一行的循环处理</span></span><br><span class="line">                <span class="keyword">if</span> (t%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                    list.add(Math.min(list.get(<span class="number">0</span>),list.get(<span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(Math.max(list.get(<span class="number">0</span>),list.get(<span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                t++;</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">                size = size-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            size = list.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二数组原地操作">方法二、数组原地操作</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626843.png" alt="Pasted image 20230115012800" /><figcaption aria-hidden="true">Pasted image 20230115012800</figcaption>
</figure>
<p>利用 <code>/2</code> 的特性，在原数组进行操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMaxGame</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    nums[i] = Math.min(nums[i*<span class="number">2</span>],nums[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] = Math.max(nums[i*<span class="number">2</span>],nums[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="强密码检验器-ii">2299. 强密码检验器 II</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626844.png" alt="Pasted image 20230119130843" /><figcaption aria-hidden="true">Pasted image 20230119130843</figcaption>
</figure>
<p>简单题。注意：判断一个字符是否包含在字符串内：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.indexOf(pc[i])!=-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h1 id="计算应缴税款总额">2303. 计算应缴税款总额</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626846.png" alt="Pasted image 20230123154310" /><figcaption aria-hidden="true">Pasted image 20230123154310</figcaption>
</figure>
<p>简单题~遍历即可。</p>
<h1 id="兼具大小写的最好英文字母">2309. 兼具大小写的最好英文字母</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626847.png" alt="Pasted image 20230127125026" /><figcaption aria-hidden="true">Pasted image 20230127125026</figcaption>
</figure>
<p>虽然是简单题，但是涉及很多 java 的基础知识。比如：小写转为大写需要 <strong>-32</strong>。 详细代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greatestLetter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">char</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sc.length;i++) &#123; </span><br><span class="line">            set.add(sc[i]);</span><br><span class="line">            <span class="keyword">if</span> (sc[i]&lt;=<span class="string">&#x27;z&#x27;</span> &amp;&amp; sc[i]&gt;=<span class="string">&#x27;a&#x27;</span>) &#123;    <span class="comment">//小写</span></span><br><span class="line">                <span class="keyword">if</span> (set.contains((<span class="type">char</span>)(sc[i]-<span class="number">32</span>))) &#123;    <span class="comment">//存在它的大写</span></span><br><span class="line">                    <span class="keyword">if</span> (res==<span class="string">&#x27; &#x27;</span> || res&lt;(<span class="type">char</span>)(sc[i]-<span class="number">32</span>)) &#123;</span><br><span class="line">                        res = (<span class="type">char</span>)(sc[i]-<span class="number">32</span>);    <span class="comment">//对比的是大写</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;     <span class="comment">//大写</span></span><br><span class="line">                <span class="keyword">if</span> (set.contains((<span class="type">char</span>)(sc[i]+<span class="number">32</span>))) &#123;    <span class="comment">//存在它的小写</span></span><br><span class="line">                    <span class="keyword">if</span> (res==<span class="string">&#x27; &#x27;</span> || res&lt;sc[i]) &#123;</span><br><span class="line">                        res = sc[i];  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="统计星号">2315. 统计星号</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626848.png" alt="Pasted image 20230129003138" /><figcaption aria-hidden="true">Pasted image 20230129003138</figcaption>
</figure>
<p>简单题。</p>
<h1 id="判断矩阵是否是一个-x-矩阵">2319. 判断矩阵是否是一个 X 矩阵</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626849.png" alt="Pasted image 20230131093415" /><figcaption aria-hidden="true">Pasted image 20230131093415</figcaption>
</figure>
<p>简单题。</p>
<h1 id="解密消息">2325. 解密消息</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626850.png" alt="Pasted image 20230201104134" /><figcaption aria-hidden="true">Pasted image 20230201104134</figcaption>
</figure>
<p>简单题。唯一需要注意的是普通的动态数组用 ArrayList，字符动态数组用 StringBuilder。</p>
<h1 id="计算布尔二叉树的值">2331. 计算布尔二叉树的值</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302061731815.png" /></p>
<p>简单题，考察树的<strong>后序遍历</strong>，并存入栈中（使用双端队列）。</p>
<p>核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode root, Deque&lt;Integer&gt; dq)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	PostOrder(root.left,dq);</span><br><span class="line">	PostOrder(root.right,dq);</span><br><span class="line">	<span class="keyword">if</span> (root.val == <span class="number">2</span> || root.val == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">		<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">		<span class="keyword">if</span> (root.val == <span class="number">2</span>) &#123;    <span class="comment">//or</span></span><br><span class="line">			dq.addLast(x|y);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			dq.addLast(x&amp;y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		dq.addLast(root.val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="装满杯子需要的最短总时长">2335. 装满杯子需要的最短总时长</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302121048252.png" /></p>
<p>本题只要将最大的两个值同时-1，当只剩下最后一个温度的杯子没有装满时，再直接加上即可。</p>
<h1 id="数组能形成多少数对">2341. 数组能形成多少数对</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302162153619.png" /></p>
<p>简单题，没有意义。</p>
<h1 id="最好的扑克手牌">2347. 最好的扑克手牌</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302200856699.png" /></p>
<p>简单题，快排即可。</p>
<h1 id="第一个出现两次的字母">2351. 第一个出现两次的字母</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626851.png" alt="Pasted image 20230101002426" /><figcaption aria-hidden="true">Pasted image 20230101002426</figcaption>
</figure>
<p>简单题，利用位运算判断字符是否已经判断过。</p>
<h1 id="使数组中所有元素都等于零">2357. 使数组中所有元素都等于零</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241543738.png" /></p>
<p>简单题。</p>
<h1 id="合并相似的物品">2363. 合并相似的物品</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302280901635.png" /></p>
<p>简单题，但是涉及到很多知识点。</p>
<ol type="1">
<li><p>hash 的添加操作<br />
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.put(i[<span class="number">0</span>],hash.getOrDefault(i[<span class="number">0</span>],<span class="number">0</span>)+i[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p></li>
<li><p>hash 的遍历 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">	list.add(entry.getKey());</span><br><span class="line">	list.add(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>list 的自定义遍历（注意是 <code>Collections</code>，不是 <code>Arrays</code>） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(res,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(List&lt;Integer&gt; l1, List&lt;Integer&gt; l2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> l1.get(<span class="number">0</span>)-l2.get(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h1 id="算术三元组的数目">2367. 算术三元组的数目</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303310835410.png" /></p>
<p>简单题。</p>
<h1 id="矩阵中的局部最大值">2373. 矩阵中的局部最大值</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303010824823.png" /></p>
<p>简单题，意义不大。</p>
<h1 id="得到-k-个黑块的最少涂色次数">2379. 得到 K 个黑块的最少涂色次数</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303090848394.png" /></p>
<p>简单题，滑动窗口基础题！</p>
<h1 id="赢得比赛需要的最少训练时长">2383、赢得比赛需要的最少训练时长</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626775.png" /></p>
<p>本题思路比较简单：</p>
<p>首先要求训练后的experience值要比对手的experience之和多1；</p>
<p>因为是依次挑战（按顺序挑战），所以一个个计算，如果因为energy打不过当前，那就要额外训练一段时间，让他刚好能打过，依次类推，最后能算出energy的额外训练时间。</p>
<p>将两个训练时间相加即可。</p>
<h1 id="和有限的最长子序列">2389. 和有限的最长子序列</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303170816108.png" /></p>
<p>简单题，先排序，然后计算前缀和即可。</p>
<h1 id="和相等的子数组">2395. 和相等的子数组</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303261026706.png" /></p>
<p>简单题，求和即可。</p>
<h1 id="检查相同字母间的距离">2399. 检查相同字母间的距离</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304091111895.png" /></p>
<p>简单题。</p>
<h1 id="出现最频繁的偶数元素">2404. 出现最频繁的偶数元素</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304130837105.png" /></p>
<p>简单题，无脑 hash 存储即可。</p>
<h1 id="统计共同度过的日子数">2409. 统计共同度过的日子数</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304171610755.png" /></p>
<p>简单题，但是恶心人。只要找到两个人的出发日期的最大值和离开日期的最小值，它们之间的时间差就是我们要求得得。</p>
<h1 id="最小偶倍数">2413. 最小偶倍数</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304210854632.png" /></p>
<p>简单题，一行结束，优雅。</p>
<h1 id="按身高排序">2418. 按身高排序</h1>
<blockquote>
<p>考察： #数组排序</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304251542535.png" /></p>
<p>简单题， #模板题 。但是注意：<strong>根据一个数组的结果排序另一个数组的</strong>，这是模板题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] sortPeople(String[] names, <span class="type">int</span>[] heights) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> names.length;</span><br><span class="line">        Integer[] idx = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            idx[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(idx, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> heights[b]-heights[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            res[i] = names[idx[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="删除字符使频率相同">2423. 删除字符使频率相同</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304292317566.png" /></p>
<p>简单模拟题。但是要考虑的东西特别多。</p>
<h1 id="公因子的数目">2427. 公因子的数目</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304051652694.png" /></p>
<p>简单题。</p>
<h1 id="温度转换">2469. 温度转换</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303210819183.png" /></p>
<p>简单题，没有意义。</p>
<h1 id="统计中位数为-k-的子数组">2488. 统计中位数为 K 的子数组⭐</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303160938313.png" /></p>
<blockquote>
<p>Tags： #前缀和 #后缀和 #哈希</p>
</blockquote>
<p>困难题，思路很难！是前缀和的超级灵活考察，它不是简单的前缀相加再处理，而是用相对大小进行处理，最后记录大于 k 和小于 k 的个数之间的关系。</p>
<p><strong>思路：</strong></p>
<p>首先注意，由于 nums 长度为 n，且是 1~n 的不同整数组成，数组只能是一个 1 到 n 的排列。同时 k≤n，则 k 一定在数组中出现过。</p>
<p>那么可以在数组中先找到 k，考虑一个数组的中位数如果是 k，那么这个排序后的 k 就在中间或中间偏左。</p>
<p>因此可以将 k 及其右侧所有数字到 k 这个位置上的“前缀和”统计出来（这里“前缀和”并不是常规上的“前缀和”），k 位置上的 sum=0，大于 k 的位置是 sum+1，小于的是 sum-1，并都存入哈希表。哈希表的 key 就是 sum，value 就是 sum 出现的次数。不难发现 key=0 一定会出现 1 次，也就表示整个数组至少会出现一个只有 k 单独元素组成的符合条件的子数组。</p>
<p>接下来对 k 左侧进行相反处理，从 k 位置向左端点进行遍历，即求到 k 的“后缀和”。等于 k 就 sum=0，小于 k 是 sum+1，大于 k 是 sum-1。但是本次遍历不需要存入 hash，而是直接不断 hash. get (sum)+hash. get (sum+1) 求出结果了。</p>
<p><strong>举个例子：</strong></p>
<p>假设数组为[3, 2, 1, 5, <strong>4</strong>, 7, 6]。</p>
<p>先处理右端：[0, 0, 0, 0, <strong>0</strong>, 1, 2]。</p>
<p>再处理左端：[2, 1, 0, -1, <strong>0</strong> , 1, 2]。我们可以看出当左边遍历到 2 的时候 sum=1，意味着<strong>左边小于 k 的比大于 k 的多 1 个</strong>，如果要使得子数组成立，我需要再右边找到<strong>右边大于 k 的比小于 k 的多 1 个</strong>，或者<strong>右边找到大于 k 的比小于 k 的多 2 个</strong>（因为中位数靠左），所以本题下标为 1~5 可以为一个结果，1~6 也可以为一个结果。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 找k的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//记录k的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==k) &#123;</span><br><span class="line">                loc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算以k为起点的前缀和以k为终点的后缀</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.1 以k为起点，等于k的也就是起点设置为0，比k大的sum+1，比k小的sum-1，每次结果都存在hash中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=loc;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==k) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&gt;k) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(sum, hash.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2 以k为终点，但是遍历的时候k仍然是起点，只是从右往左遍历，等于k的也就是最初时候sum=0，比k大的sum-1，比k小的sum+1，每次结果直接和hash中的进行对比。</span></span><br><span class="line">        <span class="comment">// 依赖的原则是：k左边的sum一定比k右边的sum相等或者大1，那么这段就是正确的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=loc;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==k) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&lt;k) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            res += hash.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">            res += hash.getOrDefault(sum+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试题-01.02.-判定是否互为字符重排">面试题 01.02. 判定是否互为字符重排⭐</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626776.png" alt="image-20220928215225321" /><figcaption aria-hidden="true">image-20220928215225321</figcaption>
</figure>
<p>本题可以使用将字符串转为字符数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] sa1 = s1.toCharArray();</span><br></pre></td></tr></table></figure>
<p>再对字符数组进行排序，一样可以使用Arrays.sort()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(sa1);     <span class="comment">//对sa1原地排序</span></span><br></pre></td></tr></table></figure>
<p>判断两个字符数组是否相同，可以先将字符数组转为字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(sa1);</span><br></pre></td></tr></table></figure>
<p>字符串的比较：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2);    <span class="comment">//返回true或者false</span></span><br></pre></td></tr></table></figure>
<h1 id="剑指-offer-47.-礼物的最大价值">剑指 Offer 47. 礼物的最大价值</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303080826979.png" /></p>
<p>经典动态规划~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                dp[j+<span class="number">1</span>] = Math.max(dp[j]+grid[i][j],dp[j+<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试题01.05.一次编辑">面试题01.05.一次编辑</h1>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626777.png" alt="image-20221014091320312" /><figcaption aria-hidden="true">image-20221014091320312</figcaption>
</figure>
<p>比较简单的一题，类似于<code>1913题</code>的思路.</p>
<h1 id="面试题-01.08零矩阵">面试题 01.08、零矩阵</h1>
<h2 id="方法一两次遍历">方法一、两次遍历</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626778.png" alt="image-20220930094258272" /><figcaption aria-hidden="true">image-20220930094258272</figcaption>
</figure>
<p>对二维数组遍历两遍，第一遍是为了找到受影响的行和列，第二遍是针对这些行和列做处理。</p>
<p>List查找某个元素是否在其中，可以用：（List其他操作见15题）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(s);    <span class="comment">//查找s这个元素是否在list中</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二两个标记变量">方法二、两个标记变量</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626779.png" alt="image-20220930101828955" /><figcaption aria-hidden="true">image-20220930101828955</figcaption>
</figure>
<p>这个思路就是将第一行第一列作为标签，如果matrix中i行j列为0，则将第一行的j列和第一列的i行置为0即可。但是为了保存第一行和第一列的信息，我需要先判断如果第一行中没有0，但是由于matrix[i][j]为0，所以第一行的第j列必然为0。所以在操作之前先判断第一行和第一列是否有0，如果有则在最后一步将其全置为0。接下来的操作是分析除去第一行和第一列的元素，如果为0，则其对应的第一行的元素和第一列的元素变为0。遍历完之后，根据第一行和第一列的情况对内部元素操作。最后按照上面刚说的那样对第一行和第一列处理。</p>
<h1 id="面试题-01.09字符串轮转">面试题 01.09、字符串轮转</h1>
<h2 id="方法一利用子串匹配">方法一、利用子串匹配</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626780.png" alt="image-20220929224340027" /><figcaption aria-hidden="true">image-20220929224340027</figcaption>
</figure>
<p>java中有内置的判断字符串是否在另一个字符串的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.contains(s2);    <span class="comment">//如果s2包含在s1中，则返回true，否则返回false</span></span><br></pre></td></tr></table></figure>
<p>只需要将其中的一个字符串连续两个相同的拼接上，如果可以循环成为它，则另一个字符串就一定包含在这个拼接的字符串中。</p>
<h2 id="方法二指针移动关系">方法二、指针移动关系</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626781.png" alt="image-20220929225202308" /><figcaption aria-hidden="true">image-20220929225202308</figcaption>
</figure>
<p>如果s1向左循环移动i位得到s2，那么对于s2的下标为j的元素有这样的关系：<code>s2[j] = s1[(i+j)%j]</code>。其实很好理解，因为如果是s1向左移动i位，相当于s2相对s1向右移动i位，所以对于s2的i位，实际就是s1的0位，这样就能得到这样的关系。注意的是对于字符串，提取下标为i的字符需要用<code>s1.charAt(i)</code>。</p>
<h1 id="面试题-05.02.-二进制数转字符串">面试题 05.02. 二进制数转字符串</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303020957917.png" /></p>
<p>常规中等题，考察 StringBuilder 和除法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">printBin</span><span class="params">(<span class="type">double</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">1.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">32</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= cs*<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= cs) &#123;</span><br><span class="line">                num -= cs;</span><br><span class="line">                cs = cs / <span class="number">2</span>;</span><br><span class="line">                sb.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cs = cs / <span class="number">2</span>;</span><br><span class="line">                sb.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试题-17.05.-字母与数字">面试题 17.05. 字母与数字</h1>
<h2 id="方法一前缀和定长">方法一、前缀和+定长</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303111105673.png" /></p>
<p>先计算前缀和，因为要找最长子串，所以定长遍历，从最长的长度开始，遍历起点，再依次缩小长度，继续遍历起点。直到找到一个长度下满足条件的起点，这个起点和长度就是满足条件的最长且靠左的。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="type">int</span>[] pren = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] prec = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> array[i].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) || (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                    prec[i] = <span class="number">1</span>;</span><br><span class="line">                    pren[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    prec[i] = <span class="number">0</span>;</span><br><span class="line">                    pren[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) || (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                    prec[i] = prec[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    pren[i] = pren[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    prec[i] = prec[i-<span class="number">1</span>];</span><br><span class="line">                    pren[i] = pren[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> n; len &gt; <span class="number">0</span>; len--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> start=<span class="number">0</span>;start&lt;=n-len;start++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prec[start+len-<span class="number">1</span>] == pren[start+len-<span class="number">1</span>]) &#123;</span><br><span class="line">                        left = start;</span><br><span class="line">                        right = start+len-<span class="number">1</span>;</span><br><span class="line">                        isFind = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prec[start+len-<span class="number">1</span>] - prec[start-<span class="number">1</span>] == pren[start+len-<span class="number">1</span>] - pren[start-<span class="number">1</span>]) &#123;</span><br><span class="line">                        left = start;</span><br><span class="line">                        right = start+len-<span class="number">1</span>;</span><br><span class="line">                        isFind = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right==left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            res[i] = array[i+left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二前缀和哈希">方法二、前缀和+哈希⭐</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303111219097.png" /></p>
<p>我们设遇到字母+1，遇到数字-1，所以满足条件的子串的和就是为 0。但是找到一个和为 0 的子串实际上操作和方法一一致，没有达到优化的效果，所以需要转换思路。</p>
<p>假设以下标为 i 结尾的前缀和为 k，以下标为 j 结尾的前缀和也为 k，那么可以知道 i~j 之间部分的和为 0，实际上是 <strong><code>[i+1, j]</code> 区间的和为 0，这个区间长度为 <code>j-i</code></strong>。</p>
<p>哈希表 hash 记录每个前缀和第一次出现的位置，max 记录最大子数组的长度，start 记录最大子数组时的起点位置。</p>
<blockquote>
<p>关于数组的深拷贝，使用方法见：<a href="LeetCode总结笔记.md#数组##拷贝###深拷贝">数组深拷贝</a></p>
</blockquote>
<p>详细代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        hash.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> array[i].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ((c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) || (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;      <span class="comment">// 字母+1</span></span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;       <span class="comment">// 数字-1</span></span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(sum)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-hash.get(sum) &gt; max) &#123;       <span class="comment">// 表示以hash.get(sum)为尾的前缀和 和 以i为尾的前缀和是相等的，所以他们中间部分就是满足条件的子串</span></span><br><span class="line">                    max = i - hash.get(sum);</span><br><span class="line">                    start = hash.get(sum)+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.put(sum,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[max];</span><br><span class="line">        System.arraycopy(array,start,res,<span class="number">0</span>,max);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试题17.09第k个数">面试题17.09、第k个数</h1>
<h2 id="方法一硬算">方法一、硬算</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626782.png" alt="image-20220928204023119" /><figcaption aria-hidden="true">image-20220928204023119</figcaption>
</figure>
<p>使用方法三的手法进行优化</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626783.png" alt="image-20220928214832520" /><figcaption aria-hidden="true">image-20220928214832520</figcaption>
</figure>
<p>List本质上就是动态数组</p>
<p>创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<p>查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.get(<span class="number">0</span>);     <span class="comment">// 通过下标查询</span></span><br></pre></td></tr></table></figure>
<h2 id="方法二小根堆">方法二、小根堆</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626784.png" alt="image-20220928211555288" /><figcaption aria-hidden="true">image-20220928211555288</figcaption>
</figure>
<h3 id="小根堆">小根堆</h3>
<p>小根堆的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Long&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>小根堆添加操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.add(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>小根堆判断是否为空：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.isEmpty()    <span class="comment">//如果是空则返回true</span></span><br></pre></td></tr></table></figure>
<p>小根堆弹出操作（弹出最小的数，并返回此数）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br></pre></td></tr></table></figure>
<h3 id="set集合">Set集合</h3>
<p>Set 表示唯一对象的集合。集合中元素的排序是不相关的。</p>
<h4 id="hashset">HashSet</h4>
<p>HashSet 基于 HashMap 来实现的，是一个<strong>不允许有重复元素的集合</strong>。</p>
<p>HashSet 允许有 null 值。</p>
<p>HashSet <strong>是无序的，即不会记录插入的顺序</strong>。</p>
<p>HashSet 实现了 Set 接口。（这就是为什么这个解法可以使用<code>Set&lt;Long&gt; set = new HashSet&lt;&gt;();</code>）</p>
<p>Set对象的创建：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Long&gt; set = new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>Set对象的添加操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.add(<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>Set对象的判断是否存在操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.contains(k)     <span class="comment">//判断k这个值在set中是否存在，存在则返回true</span></span><br></pre></td></tr></table></figure>
<p>Set对象删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.remove(&quot;book&quot;);</span><br></pre></td></tr></table></figure>
<h2 id="方法三多路归并多指针方法一优化">方法三、多路归并（多指针）（方法一优化）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626785.png" alt="image-20220928214035095" /><figcaption aria-hidden="true">image-20220928214035095</figcaption>
</figure>
<p>设置3个指针，分别是对于*3、*5、*7的，每次比较选择最小的加入到数组中。</p>
<h3 id="注意-6">注意</h3>
<p>在使用两个数比大小时，尽量使用<code>Math.min(a,b)</code>。如果时三个数，使用<code>Math.min(a,Math.min(b,c))</code>。</p>
<h1 id="面试题-17.19消失的两个数字">面试题 17.19、消失的两个数字</h1>
<h2 id="方法一硬算不合规矩">方法一、硬算（不合规矩）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626786.png" alt="image-20220926152844119" /><figcaption aria-hidden="true">image-20220926152844119</figcaption>
</figure>
<h2 id="方法二异或官方">方法二、异或（官方）</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626787.png" alt="image-20220926205020657" /><figcaption aria-hidden="true">image-20220926205020657</figcaption>
</figure>
<blockquote>
<ol type="1">
<li><p><strong>负数的补码:</strong></p>
<p>对于正数9：0000 1001</p>
<p>对于负数-9：先-1：0000 1000；再全部取反：1111 0111。</p></li>
</ol>
<p>​ 或者先变成：1000 1001；再除了符号位取反：1111 0110；再末位+1：1111 0111。</p>
<p>​ 所以: 9 = 0000 1001</p>
<p>​ -9 = 1111 0111</p>
<pre><code>          9 &amp; -9 = 0000 0001（能生成二进制中为1的最小位） </code></pre>
<p>​ 拓展: 10 = 0000 1010</p>
<p>​ -10 = 1111 0110</p>
<pre><code>           10 &amp; -10 = 0000 0010 </code></pre>
<ol start="2" type="1">
<li><p><strong>异或</strong></p>
<p>Java中异或用<code>^</code>表示</p>
<p>1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 4 =&gt; 0 ^ 0 ^ 3 ^ 4 =&gt; 0 ^ 3 ^ 4（x = 3^4）=&gt; 0 ^ x =&gt; x</p>
<p>即 a ^ a ^ b = b</p></li>
<li><p><code>Integer.MIN_VALUE</code> = 1000 0000 0000 0000 0000 0000 0000 0000，-2 147 483 648</p>
<p><code>Integer.MAX_VALUE</code> = 0111 1111 1111 1111 1111 1111 1111 1111， 2 147 483 647</p></li>
</ol>
</blockquote>
<p>逻辑：</p>
<p>这是考察异或和且的位运算算法题。我们想要找到n个数中没有出现的2个数，也就是再n个数中找出除了<code>nums</code>中存在的n-2个数的另外2个数。</p>
<p>如果先将这n个数和<code>nums</code>中n-2个数异或，也就是这2n-2（n-2 + n-2 + 2）个数异或，根据上面异或的相关知识，能得到结果<code>x = x1 ^ x2</code>（x为异或结果，x1、x2为我们想要求得的两个不在nums的数）。</p>
<p>得到<code>x = x1 ^ x2</code>，如何提取出x1和x2成为了最大的难题。我们发现x1和x2不可能相同，所以<code>x1&amp;x2! = 0</code>，根据上面且的相关知识，对于x而言，它二进制最低位的1（假设是第k位）所代表的含义是x1的第k位和x2的第k位是不相同的（因为相同为0、不同为1），因此我们可以将<code>nums</code>分为两类，一类是第k位为0的，一类是第k位为1的。筛选出<code>nums</code>这两类很简单，只需要与<code>x&amp;-x</code>（<code>x&amp;-x</code>的结果是除了第k位为1，其他位都是0）进行且操作，如果结果是0，表示<code>nums</code>中的这个数的第k位是0；如果是1，表示<code>nums</code>中的这个数的第k位是1。这里需要进行防溢出操作，即判断<code>x == Integer.MIN_VALUE</code>，如果成立，说明-x已经越界，就直接将x与nums中每个数进行比较筛选。</p>
<p>经过上一步就已经将<code>nums</code>分为两部分了<code>type1</code>、<code>type2</code>，这时候只需要将n个数分为两部分，两部分分别是<code>type1</code>多一个x1、<code>type2</code>多一个x2。只需要再用一次异或，结果就分别是x1和x2了。</p>
<p>返回结果直接用<code>new int[]&#123;type1,type2&#125;</code>即可。</p>
<h2 id="方法三求和">方法三、求和</h2>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626788.png" alt="image-20220926213157385" /><figcaption aria-hidden="true">image-20220926213157385</figcaption>
</figure>
<p>本方法使用数学基础运算。先求出n个数之和，再求出nums中n-2个数之和，则这两个和之差就是<code>x1+x2</code>。我们可以通过<code>x = x1+x2</code>，算出x1和x2的中位数t，即<strong>x1一定小于t，x2一定大于t</strong>，求出1~t的和truenum，可以将nums遍历一遍，筛选每一个值小于等于t的num，再用truenum减去这个值，得到的结果就是x1。用<code>x2 = x - x1</code>得到结果。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>LeetCode逐题笔记</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://wryit.fun/2022/11/15/LeetCode%E9%80%90%E9%A2%98%E7%AC%94%E8%AE%B0/">https://wryit.fun/2022/11/15/LeetCode逐题笔记/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>火星架构师</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2022-11-15</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-05-03</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LeetCode/">LeetCode</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%B0%81%E9%9D%A2%E5%9B%BE2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/15/LeetCode%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" title="LeetCode总结笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E5%B0%81%E9%9D%A2%E5%9B%BE2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-15</div><div class="title">LeetCode总结笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="author_top is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/%E7%BD%91%E7%AB%99%E5%9B%BE%E6%A0%87.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">火星架构师</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Wang-Ruiyang"><i></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/437601842" target="_blank" title="B站"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-bilibili"></use></svg></a><a class="social-icon faa-parent animated-hover" href="https://github.com/Wang-Ruiyang" target="_blank" title="github"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-github"></use></svg></a><a class="social-icon faa-parent animated-hover" href="mailto:wry0818@126.com" target="_blank" title="邮箱"><svg class="icon faa-tada" aria-hidden="true"><use xlink:href="#icon-MAILBOX"></use></svg></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://wryit.fun"><b><font color="#5ea6e5">wryit.fun</font></b></a>&nbsp</b></a></center></div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">1.</span> <span class="toc-text">1、两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#length%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.0.1.</span> <span class="toc-text">length的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0"><span class="toc-number">2.</span> <span class="toc-text">2. 两数相加</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.</span> <span class="toc-text">4、寻找两个正序数组的中位数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">5、最长回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%AD%E5%BF%83%E6%89%A9%E5%BC%A0%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">方法一、中心扩张法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2"><span class="toc-number">5.1.2.</span> <span class="toc-text">替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.2.</span> <span class="toc-text">方法二、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">11、盛最多水的容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-number">7.</span> <span class="toc-text">15、三数之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="toc-number">8.</span> <span class="toc-text">20. 有效的括号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-number">9.</span> <span class="toc-text">26、删除有序数组中的重复项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">10.</span> <span class="toc-text">31、下一个排列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">11.</span> <span class="toc-text">33、搜索旋转排序数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E4%B8%8D%E6%BB%A1%E8%B6%B3logn"><span class="toc-number">11.1.</span> <span class="toc-text">方法一、暴力（不满足log(n)）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BA%8C%E5%88%86%E6%B3%95%E4%B8%8D%E5%AE%8C%E5%85%A8%E6%BB%A1%E8%B6%B3logn"><span class="toc-number">11.2.</span> <span class="toc-text">方法二、二分法（不完全满足log(n)）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E4%BA%8C%E5%88%86%E6%B3%95%E4%BC%98%E5%8C%96%E6%BB%A1%E8%B6%B3logn"><span class="toc-number">11.3.</span> <span class="toc-text">方法三、二分法优化（满足log(n)）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-number">12.</span> <span class="toc-text">34、在排序数组中查找元素的第一个和最后一个位置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%BA%8C%E5%88%86%E6%89%A9%E5%BC%A0"><span class="toc-number">12.1.</span> <span class="toc-text">方法一、二分+扩张</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%80%A7%E8%B4%A8"><span class="toc-number">12.2.</span> <span class="toc-text">方法二、二分查找性质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="toc-number">13.</span> <span class="toc-text">35. 搜索插入位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C"><span class="toc-number">14.</span> <span class="toc-text">39、组合总和⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97dfs"><span class="toc-number">14.1.</span> <span class="toc-text">方法一、双端队列+DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">14.1.1.</span> <span class="toc-text">相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#listlist"><span class="toc-number">14.1.1.1.</span> <span class="toc-text">List&lt;List&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">14.1.1.2.</span> <span class="toc-text">Deque双端队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%89%AA%E6%9E%9D%E5%8F%B6"><span class="toc-number">14.2.</span> <span class="toc-text">方法二、剪枝叶</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8Cii"><span class="toc-number">15.</span> <span class="toc-text">40、组合总和II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8Fii"><span class="toc-number">16.</span> <span class="toc-text">45、跳跃游戏II⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%95%B0%E7%BB%84"><span class="toc-number">16.1.</span> <span class="toc-text">方法一、动态规划+数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BC%98%E5%8C%96"><span class="toc-number">16.2.</span> <span class="toc-text">方法二、优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">17.</span> <span class="toc-text">46、全排列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">17.1.</span> <span class="toc-text">拓展</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-number">18.</span> <span class="toc-text">49. 字母异位词分组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">19.</span> <span class="toc-text">53、最大子数组和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="toc-number">20.</span> <span class="toc-text">55、跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp%E6%95%B0%E7%BB%84"><span class="toc-number">20.1.</span> <span class="toc-text">方法一、动态规划+dp数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BC%98%E5%8C%96%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6"><span class="toc-number">20.2.</span> <span class="toc-text">方法二、优化——动态更新最大长度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="toc-number">21.</span> <span class="toc-text">56. 合并区间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90"><span class="toc-number">22.</span> <span class="toc-text">68、文本左右对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9E%9A%E4%B8%BE%E5%90%84%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-number">22.1.</span> <span class="toc-text">方法一、枚举各种情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">23.</span> <span class="toc-text">70、爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">23.1.</span> <span class="toc-text">方法一、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BC%98%E5%8C%96"><span class="toc-number">23.1.1.</span> <span class="toc-text">简单优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-number">24.</span> <span class="toc-text">74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">25.</span> <span class="toc-text">78. 子集⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">25.1.</span> <span class="toc-text">方法一</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%9B%B4%E9%80%9A%E7%94%A8%E7%9A%84%E5%9B%9E%E6%BA%AF%E6%A1%86%E6%9E%B6"><span class="toc-number">25.2.</span> <span class="toc-text">方法二、更通用的回溯⭐（框架）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81"><span class="toc-number">26.</span> <span class="toc-text">89. 格雷编码 ⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%84%E5%BE%8B"><span class="toc-number">26.1.</span> <span class="toc-text">方法一、规律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81"><span class="toc-number">26.2.</span> <span class="toc-text">方法二、格雷编码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E9%9B%86-ii"><span class="toc-number">27.</span> <span class="toc-text">90. 子集 II⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">28.</span> <span class="toc-text">94. 二叉树的中序遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">29.</span> <span class="toc-text">101. 对称二叉树😭</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">30.</span> <span class="toc-text">102. 二叉树的层序遍历</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-number">31.</span> <span class="toc-text">104. 二叉树的最大深度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">32.</span> <span class="toc-text">118. 杨辉三角</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA"><span class="toc-number">33.</span> <span class="toc-text">121、买卖股票的最佳时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii"><span class="toc-number">34.</span> <span class="toc-text">122、买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97"><span class="toc-number">35.</span> <span class="toc-text">128. 最长连续序列⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-number">36.</span> <span class="toc-text">135、分发糖果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92"><span class="toc-number">36.1.</span> <span class="toc-text">方法一、递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%B7%A6%E5%8F%B3%E9%81%8D%E5%8E%86"><span class="toc-number">36.2.</span> <span class="toc-text">方法二、左右遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-number">37.</span> <span class="toc-text">136. 只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80hashset"><span class="toc-number">37.1.</span> <span class="toc-text">方法一、HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">37.2.</span> <span class="toc-text">方法二、位运算👍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">38.</span> <span class="toc-text">152、乘积最大子数组⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">39.</span> <span class="toc-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-number">40.</span> <span class="toc-text">189. 轮转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%BC%80%E8%BE%9F%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4"><span class="toc-number">40.1.</span> <span class="toc-text">方法一、开辟额外空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8E%9F%E5%9C%B0%E7%BF%BB%E8%BD%AC"><span class="toc-number">40.2.</span> <span class="toc-text">方法二、原地翻转👍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E6%A8%A1%E6%9D%BF%E9%A2%98"><span class="toc-number">41.</span> <span class="toc-text">198、打家劫舍（模板题）⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%89%8D"><span class="toc-number">41.0.1.</span> <span class="toc-text">优化前</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-2"><span class="toc-number">41.0.1.1.</span> <span class="toc-text">注意：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%90%8E%E7%90%86%E8%AE%BA%E4%B8%8A%E6%9B%B4%E4%BC%98%E7%9A%84"><span class="toc-number">41.0.2.</span> <span class="toc-text">优化后（理论上更优的）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">42.</span> <span class="toc-text">208. 实现 Trie (前缀树)⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-ii"><span class="toc-number">43.</span> <span class="toc-text">213、打家劫舍 II⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">43.1.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">44.</span> <span class="toc-text">226. 翻转二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-number">45.</span> <span class="toc-text">283. 移动零</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">46.</span> <span class="toc-text">300. 最长递增子序列⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-number">47.</span> <span class="toc-text">438. 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89"><span class="toc-number">48.</span> <span class="toc-text">453. 最小操作次数使数组元素相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89-ii"><span class="toc-number">49.</span> <span class="toc-text">462. 最小操作次数使数组元素相等 II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">50.</span> <span class="toc-text">494. 目标和⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84-%E7%BA%AF%E6%9A%B4%E5%8A%9B"><span class="toc-number">50.1.</span> <span class="toc-text">方法一、二维数组 （纯暴力）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%95%B0%E5%AD%A6%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">50.2.</span> <span class="toc-text">方法二、数学+动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%94%A8%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">50.2.1.</span> <span class="toc-text">优化、用一维数组进行动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">50.3.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">50.3.1.</span> <span class="toc-text">栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">51.</span> <span class="toc-text">509、斐波那契数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D"><span class="toc-number">52.</span> <span class="toc-text">524、通过删除字母匹配到字典里最长单词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%8E%92%E5%BA%8F%E5%90%8E%E6%93%8D%E4%BD%9C"><span class="toc-number">52.1.</span> <span class="toc-text">方法一：排序后操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%8D%E6%8E%92%E5%BA%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">52.2.</span> <span class="toc-text">方法二、不排序操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-3"><span class="toc-number">52.2.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">53.</span> <span class="toc-text">543. 二叉树的直径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">54.</span> <span class="toc-text">560. 和为 K 的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">54.1.</span> <span class="toc-text">方法一、前缀和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%89%8D%E7%BC%80%E5%92%8Chash-%E4%BC%98%E5%8C%96"><span class="toc-number">54.2.</span> <span class="toc-text">方法二、前缀和+hash 优化⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">55.</span> <span class="toc-text">621. 任务调度器⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">56.</span> <span class="toc-text">647. 回文子串⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E6%89%A9%E5%BC%A0%E6%B3%95"><span class="toc-number">56.1.</span> <span class="toc-text">中心扩张法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-k-diff-%E6%95%B0%E5%AF%B9"><span class="toc-number">57.</span> <span class="toc-text">532、数组中的 k-diff 数对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">58.</span> <span class="toc-text">671、二叉树中第二小的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9B%BF%E6%8D%A2%E6%B3%95"><span class="toc-number">58.1.</span> <span class="toc-text">方法一、替换法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cdfs"><span class="toc-number">58.2.</span> <span class="toc-text">方法二、DFS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="toc-number">59.</span> <span class="toc-text">707、设计链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">60.</span> <span class="toc-text">714、买卖股票的最佳时机含手续费⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E8%B4%AA%E5%BF%83"><span class="toc-number">60.1.</span> <span class="toc-text">方法一、贪心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-number">60.2.</span> <span class="toc-text">方法二、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">60.2.1.</span> <span class="toc-text">优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6"><span class="toc-number">61.</span> <span class="toc-text">739. 每日温度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">61.1.</span> <span class="toc-text">方法一、单调栈⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0"><span class="toc-number">62.</span> <span class="toc-text">740、删除并获得点数⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">63.</span> <span class="toc-text">746、使用最小花费爬楼梯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-number">63.1.</span> <span class="toc-text">方法一、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4"><span class="toc-number">63.1.1.</span> <span class="toc-text">尝试优化空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97"><span class="toc-number">64.</span> <span class="toc-text">769、最多能完成排序的块⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8lr%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%AD%97%E7%AC%A6"><span class="toc-number">65.</span> <span class="toc-text">777、在LR字符串中交换相邻字符⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7"><span class="toc-number">66.</span> <span class="toc-text">779、第K个语法符号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97"><span class="toc-number">67.</span> <span class="toc-text">788、旋转数字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0"><span class="toc-number">68.</span> <span class="toc-text">792、匹配子序列的单词数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B%E5%BE%AE%E4%BC%98%E5%8C%96"><span class="toc-number">68.1.</span> <span class="toc-text">方法一、暴力+微优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%A6%96%E5%AD%97%E6%AF%8D%E9%98%9F%E5%88%97"><span class="toc-number">68.2.</span> <span class="toc-text">方法二、首字母+队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">69.</span> <span class="toc-text">796、旋转字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A6%99%E6%A7%9F%E5%A1%94"><span class="toc-number">70.</span> <span class="toc-text">799、香槟塔</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E6%8B%9F"><span class="toc-number">70.1.</span> <span class="toc-text">方法一、动态规划（模拟）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1"><span class="toc-number">70.1.1.</span> <span class="toc-text">优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0"><span class="toc-number">71.</span> <span class="toc-text">801、使序列递增的最小交换次数⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">71.1.</span> <span class="toc-text">方法一、分类讨论+动态规划</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%96%B9%E6%B3%95%E4%B8%80dp%E6%95%B0%E7%BB%84%E6%94%B9%E5%8F%98"><span class="toc-number">71.2.</span> <span class="toc-text">方法二、方法一dp数组改变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E4%BC%98%E5%8C%96"><span class="toc-number">71.3.</span> <span class="toc-text">方法三、优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%B1%A4"><span class="toc-number">72.</span> <span class="toc-text">808、分汤⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80dfs%E8%AE%B0%E5%BF%86%E5%8C%96"><span class="toc-number">72.1.</span> <span class="toc-text">方法一、DFS+记忆化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%961"><span class="toc-number">72.1.1.</span> <span class="toc-text">优化1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%962"><span class="toc-number">72.1.2.</span> <span class="toc-text">优化2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-number">72.1.3.</span> <span class="toc-text">完整代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-number">72.2.</span> <span class="toc-text">方法二、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-1"><span class="toc-number">72.2.1.</span> <span class="toc-text">完整代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%83%85%E6%84%9F%E4%B8%B0%E5%AF%8C%E7%9A%84%E6%96%87%E5%AD%97"><span class="toc-number">73.</span> <span class="toc-text">809、情感丰富的文字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%90%E5%AD%97%E5%AF%B9%E6%AF%94%E9%95%BF%E5%BA%A6%E5%8A%A0%E9%80%9F"><span class="toc-number">73.1.</span> <span class="toc-text">方法一、逐字对比+长度加速</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0"><span class="toc-number">74.</span> <span class="toc-text">811、子域名访问计数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">74.0.1.</span> <span class="toc-text">HashMap（散列表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%89%E7%A9%BA%E6%A0%BC%E5%88%86%E5%89%B2"><span class="toc-number">74.0.2.</span> <span class="toc-text">字符串按空格分割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E6%95%B4%E6%95%B0"><span class="toc-number">74.0.3.</span> <span class="toc-text">字符串转为整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">74.0.4.</span> <span class="toc-text">长度函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%E7%9A%84%E6%9E%84%E5%BB%BA"><span class="toc-number">74.0.5.</span> <span class="toc-text">List的构建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">75.</span> <span class="toc-text">817、链表组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">76.</span> <span class="toc-text">831. 隐藏个人信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%80%83%E5%9C%BA%E5%B0%B1%E5%BA%A7"><span class="toc-number">77.</span> <span class="toc-text">855. 考场就座⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">77.1.</span> <span class="toc-text">方法一、有序集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">77.2.</span> <span class="toc-text">方法二、有序集合+优先队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0"><span class="toc-number">78.</span> <span class="toc-text">856、括号的分数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%A0%88"><span class="toc-number">78.1.</span> <span class="toc-text">方法一、栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95-1"><span class="toc-number">78.1.1.</span> <span class="toc-text">拓展：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%80%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">78.2.</span> <span class="toc-text">方法二、一次遍历⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BAk%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">79.</span> <span class="toc-text">862、和至少为K的最短子数组⭐⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C"><span class="toc-number">80.</span> <span class="toc-text">870、优势洗牌⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%ACn%E4%B8%AA%E7%A5%9E%E5%A5%87%E6%95%B0%E5%AD%97"><span class="toc-number">81.</span> <span class="toc-text">878、第N个神奇数字⭐🌟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tips"><span class="toc-number">81.0.0.1.</span> <span class="toc-text">tips</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%86%E5%88%86%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%88%B0%E8%BE%BE%E8%8A%82%E7%82%B9"><span class="toc-number">82.</span> <span class="toc-text">882、细分图中的可到达节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E5%BA%8F%E5%88%97%E5%AE%BD%E5%BA%A6%E4%B9%8B%E5%92%8C"><span class="toc-number">83.</span> <span class="toc-text">891、子序列宽度之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6"><span class="toc-number">84.</span> <span class="toc-text">901、股票价格跨度⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%A0%88-1"><span class="toc-number">84.1.</span> <span class="toc-text">方法一、栈⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E7%BF%BB%E8%AF%91"><span class="toc-number">84.1.0.1.</span> <span class="toc-text">题目翻译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">84.1.0.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-2"><span class="toc-number">84.1.0.3.</span> <span class="toc-text">完整代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%95%B0%E7%BB%84"><span class="toc-number">84.2.</span> <span class="toc-text">方法二、数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89list"><span class="toc-number">84.3.</span> <span class="toc-text">方法三、List</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%B8%BA-n-%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88"><span class="toc-number">85.</span> <span class="toc-text">902、最大为 N 的数字组合⭐⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE"><span class="toc-number">86.</span> <span class="toc-text">904、水果成篮</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="toc-number">87.</span> <span class="toc-text">907、子数组的最小值之和⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8D%95%E8%B0%83%E6%A0%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">87.1.</span> <span class="toc-text">方法一、单调栈+动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84"><span class="toc-number">88.</span> <span class="toc-text">915、分割数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9C%80%E5%B0%8F%E5%80%BC%E5%88%86%E5%89%B2"><span class="toc-number">88.1.</span> <span class="toc-text">方法一、最小值分割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">88.2.</span> <span class="toc-text">方法二、两次遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">89.</span> <span class="toc-text">918、环形子数组的最大和⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">89.0.0.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">89.0.0.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A"><span class="toc-number">89.0.0.3.</span> <span class="toc-text">特殊</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%AD%89%E5%88%86"><span class="toc-number">90.</span> <span class="toc-text">927、三等分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-number">91.</span> <span class="toc-text">934、最短的桥⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">91.0.0.1.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">91.0.0.2.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E6%95%B4%E6%95%B0"><span class="toc-number">92.</span> <span class="toc-text">970. 强整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E4%B8%BA%E9%9B%B6%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84"><span class="toc-number">93.</span> <span class="toc-text">982. 按位与为零的三元组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88"><span class="toc-number">94.</span> <span class="toc-text">1003. 检查替换后的词是否有效</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">94.1.</span> <span class="toc-text">方法一、字符串操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%A0%88"><span class="toc-number">94.2.</span> <span class="toc-text">方法二、栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89stringbuilder"><span class="toc-number">94.3.</span> <span class="toc-text">方法三、StringBuilder</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E4%B9%A6%E6%9E%B6"><span class="toc-number">95.</span> <span class="toc-text">1105. 填充书架⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E8%A7%82%E5%85%89%E7%BB%84%E5%90%88"><span class="toc-number">96.</span> <span class="toc-text">1014、最佳观光组合⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-number">96.0.0.1.</span> <span class="toc-text">动态规划</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%9F%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">97.</span> <span class="toc-text">1017. 负二进制转换⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="toc-number">98.</span> <span class="toc-text">1019. 链表中的下一个更大节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A9%BC%E5%B3%B0%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">99.</span> <span class="toc-text">1023. 驼峰式匹配</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E4%B8%8E%E5%85%B6%E7%A5%96%E5%85%88%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">100.</span> <span class="toc-text">1026. 节点与其祖先之间的最大差值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97"><span class="toc-number">101.</span> <span class="toc-text">1027. 最长等差数列⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92-1"><span class="toc-number">101.1.</span> <span class="toc-text">方法一、递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-2"><span class="toc-number">101.1.1.</span> <span class="toc-text">优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-3"><span class="toc-number">101.2.</span> <span class="toc-text">方法二、动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E9%9D%9E%E9%87%8D%E5%8F%A0%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">102.</span> <span class="toc-text">1031. 两个非重叠子数组的最大和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">103.</span> <span class="toc-text">1032. 字符流⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD"><span class="toc-number">104.</span> <span class="toc-text">1033. 移动石子直到连续👍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86"><span class="toc-number">105.</span> <span class="toc-text">1039. 多边形三角剖分的最低得分⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%9F%B3%E5%AD%90%E7%9B%B4%E5%88%B0%E8%BF%9E%E7%BB%AD-ii"><span class="toc-number">106.</span> <span class="toc-text">1040. 移动石子直到连续 II⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%B0%E4%BA%8E%E7%8E%AF%E4%B8%AD%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA"><span class="toc-number">107.</span> <span class="toc-text">1041. 困于环中的机器人</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8D%E9%82%BB%E6%8E%A5%E6%A4%8D%E8%8A%B1"><span class="toc-number">108.</span> <span class="toc-text">1042. 不邻接植花⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%9A%94%E6%95%B0%E7%BB%84%E4%BB%A5%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">109.</span> <span class="toc-text">1043. 分隔数组以得到最大和⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">109.1.</span> <span class="toc-text">方法一、递归+记忆化搜索⭐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-4"><span class="toc-number">109.2.</span> <span class="toc-text">方法二、动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4"><span class="toc-number">109.2.1.</span> <span class="toc-text">优化空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%93%BE"><span class="toc-number">110.</span> <span class="toc-text">1048. 最长字符串链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%B8%80%E6%AC%A1%E7%9A%84%E5%85%88%E5%89%8D%E6%8E%92%E5%88%97"><span class="toc-number">111.</span> <span class="toc-text">1053. 交换一次的先前排列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97"><span class="toc-number">112.</span> <span class="toc-text">1092. 最短公共超序列⭐⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%8A%B1%E6%8B%AC%E5%8F%B7%E5%B1%95%E5%BC%80-ii"><span class="toc-number">113.</span> <span class="toc-text">1096. 花括号展开 II⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5"><span class="toc-number">114.</span> <span class="toc-text">1124. 表现良好的最长时间段</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84%E5%BF%85%E8%A6%81%E5%9B%A2%E9%98%9F"><span class="toc-number">115.</span> <span class="toc-text">1125. 最小的必要团队⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-n-%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-number">116.</span> <span class="toc-text">1137、第 N 个斐波那契数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E6%AF%8D%E6%9D%BF%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">117.</span> <span class="toc-text">1138. 字母板上的路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A5-1-%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2"><span class="toc-number">118.</span> <span class="toc-text">1139. 最大的以 1 为边界的正方形</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%87%8F%E5%85%83%E7%B4%A0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%91%88%E9%94%AF%E9%BD%BF%E7%8A%B6"><span class="toc-number">119.</span> <span class="toc-text">1144. 递减元素使数组呈锯齿状</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9D%80%E8%89%B2%E6%B8%B8%E6%88%8F"><span class="toc-number">120.</span> <span class="toc-text">1145. 二叉树着色游戏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87"><span class="toc-number">121.</span> <span class="toc-text">1147. 段式回文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%9C%A8%E6%9C%80%E5%90%8E%E7%9A%84%E5%AD%90%E4%B8%B2"><span class="toc-number">122.</span> <span class="toc-text">1163. 按字典序排在最后的子串⭐⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A4%90%E7%9B%98%E6%A0%88"><span class="toc-number">123.</span> <span class="toc-text">1172. 餐盘栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%A5%E6%A0%BC%E9%80%92%E5%A2%9E"><span class="toc-number">124.</span> <span class="toc-text">1187. 使数组严格递增⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-4"><span class="toc-number">124.0.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BF%E8%BF%87%E8%BF%B7%E5%AE%AB%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">125.</span> <span class="toc-text">1210. 穿过迷宫的最少移动次数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">125.1.</span> <span class="toc-text">方法一、广度优先搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">126.</span> <span class="toc-text">1233. 删除子文件夹</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%90%E4%B8%B2%E5%BE%97%E5%88%B0%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">127.</span> <span class="toc-text">1234. 替换子串得到平衡字符串⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E7%BB%99%E5%AE%9A%E6%96%B9%E7%A8%8B%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A7%A3"><span class="toc-number">128.</span> <span class="toc-text">1237. 找出给定方程的正整数解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%A0%81%E6%8E%92%E5%88%97"><span class="toc-number">129.</span> <span class="toc-text">1238. 循环码排列⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81"><span class="toc-number">130.</span> <span class="toc-text">方法一、格雷编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-3"><span class="toc-number">130.0.1.</span> <span class="toc-text">优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%BE%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%90%8C"><span class="toc-number">131.</span> <span class="toc-text">1247. 交换字符使得字符串相同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%97%E5%88%86%E6%9C%80%E9%AB%98%E7%9A%84%E5%8D%95%E8%AF%8D%E9%9B%86%E5%90%88"><span class="toc-number">132.</span> <span class="toc-text">1255. 得分最高的单词集合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%BE%E5%87%BA%E4%BA%95%E5%AD%97%E6%A3%8B%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85"><span class="toc-number">133.</span> <span class="toc-text">1275、找出井字棋的获胜者</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-5"><span class="toc-number">133.0.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%81%8C%E6%BA%89%E8%8A%B1%E5%9B%AD%E7%9A%84%E6%9C%80%E5%B0%91%E6%B0%B4%E9%BE%99%E5%A4%B4%E6%95%B0%E7%9B%AE"><span class="toc-number">134.</span> <span class="toc-text">1326. 灌溉花园的最少水龙头数目⭐⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4"><span class="toc-number">135.</span> <span class="toc-text">1376. 通知所有员工所需的时间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%82%BB%E6%8E%A5%E8%A1%A8dfs"><span class="toc-number">135.1.</span> <span class="toc-text">方法一、邻接表+dfs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">136.</span> <span class="toc-text">1441、用栈操作构建数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%96%87%E4%BB%B6%E5%90%8D%E5%94%AF%E4%B8%80"><span class="toc-number">137.</span> <span class="toc-text">1487. 保证文件名唯一</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="toc-number">138.</span> <span class="toc-text">1567、乘积为正数的最长子数组长度⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="toc-number">138.1.</span> <span class="toc-text">方法一、常规思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-5"><span class="toc-number">138.2.</span> <span class="toc-text">方法二、动态规划⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96"><span class="toc-number">138.2.1.</span> <span class="toc-text">动态规划优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9C%80%E7%9F%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E5%89%A9%E4%BD%99%E6%95%B0%E7%BB%84%E6%9C%89%E5%BA%8F"><span class="toc-number">139.</span> <span class="toc-text">1574. 删除最短的子数组使剩余数组有序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%AB-p-%E6%95%B4%E9%99%A4"><span class="toc-number">140.</span> <span class="toc-text">1590. 使数组和能被 P 整除</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BD%99%E6%95%B0"><span class="toc-number">140.1.</span> <span class="toc-text">方法一、前缀和 + 余数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%8F%E8%90%A5%E6%91%A9%E5%A4%A9%E8%BD%AE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="toc-number">141.</span> <span class="toc-text">1599. 经营摩天轮的最大利润</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AD%A6%E5%91%8A%E4%B8%80%E5%B0%8F%E6%97%B6%E5%86%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%90%8C%E5%91%98%E5%B7%A5%E5%8D%A1%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E4%B8%89%E6%AC%A1%E7%9A%84%E4%BA%BA"><span class="toc-number">142.</span> <span class="toc-text">1604. 警告一小时内使用相同员工卡大于等于三次的人</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%99%E5%AE%9A%E8%A1%8C%E5%92%8C%E5%88%97%E7%9A%84%E5%92%8C%E6%B1%82%E5%8F%AF%E8%A1%8C%E7%9F%A9%E9%98%B5"><span class="toc-number">143.</span> <span class="toc-text">1605. 给定行和列的和求可行矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%BD%91%E7%BB%9C%E7%A7%A9"><span class="toc-number">144.</span> <span class="toc-text">1615. 最大网络秩</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BE%97%E5%88%B0%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">145.</span> <span class="toc-text">1616. 分割两个字符串得到回文串⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">146.</span> <span class="toc-text">1625. 执行操作后字典序最小的字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E7%9F%9B%E7%9B%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E7%90%83%E9%98%9F"><span class="toc-number">147.</span> <span class="toc-text">1626. 无矛盾的最佳球队⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%89%E5%B7%AE%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">148.</span> <span class="toc-text">1630. 等差子数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A4%E7%82%B9%E4%B9%8B%E9%97%B4%E4%B8%8D%E5%8C%85%E5%90%AB%E4%BB%BB%E4%BD%95%E7%82%B9%E7%9A%84%E6%9C%80%E5%AE%BD%E5%9E%82%E7%9B%B4%E5%8C%BA%E5%9F%9F"><span class="toc-number">149.</span> <span class="toc-text">1637. 两点之间不包含任何点的最宽垂直区域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%8F%AA%E5%B7%AE%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0%E7%9B%AE"><span class="toc-number">150.</span> <span class="toc-text">1638. 统计只差一个字符的子串数目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B"><span class="toc-number">150.1.</span> <span class="toc-text">方法一、暴力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%9E%81%E8%87%B4%E4%BC%98%E5%8C%96"><span class="toc-number">150.2.</span> <span class="toc-text">方法二、极致优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84"><span class="toc-number">151.</span> <span class="toc-text">1640、能否连接形成数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%AD%97%E5%85%B8%E5%BA%8F%E5%85%83%E9%9F%B3%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">152.</span> <span class="toc-text">1641. 统计字典序元音字符串的数目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8B%86%E7%82%B8%E5%BC%B9"><span class="toc-number">153.</span> <span class="toc-text">1652、拆炸弹</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0"><span class="toc-number">154.</span> <span class="toc-text">1653. 使字符串平衡的最少删除次数⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%88%86%E5%89%B2"><span class="toc-number">154.1.</span> <span class="toc-text">方法一、分割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-6"><span class="toc-number">154.2.</span> <span class="toc-text">方法二、动态规划</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%86-x-%E5%87%8F%E5%88%B0-0-%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">155.</span> <span class="toc-text">1658. 将 x 减到 0 的最小操作数⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E7%BB%99%E5%AE%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">156.</span> <span class="toc-text">1663. 具有给定数值的最小字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%B9%B3%E8%A1%A1%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0"><span class="toc-number">157.</span> <span class="toc-text">1664. 生成平衡数组的方案数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">158.</span> <span class="toc-text">1669. 合并两个链表</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="toc-number">159.</span> <span class="toc-text">1694、重新格式化电话号码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B8%B8%E8%A7%84%E9%80%BB%E8%BE%91"><span class="toc-number">159.1.</span> <span class="toc-text">方法一、常规逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Cstringbuilder%E6%96%B9%E6%B3%95"><span class="toc-number">159.2.</span> <span class="toc-text">方法二、StringBuilder方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F"><span class="toc-number">160.</span> <span class="toc-text">1700、无法吃午餐的学生数量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E9%98%9F%E5%88%97"><span class="toc-number">160.1.</span> <span class="toc-text">方法一、队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BC%98%E5%8C%96-1"><span class="toc-number">160.2.</span> <span class="toc-text">方法二、优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BE%E7%BD%AE%E7%9B%92%E5%AD%90"><span class="toc-number">161.</span> <span class="toc-text">1739、放置盒子🌟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%95%B0%E5%AD%A6%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">161.1.</span> <span class="toc-text">方法一、数学找规律</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2%E5%BC%80%E5%B9%B3%E6%96%B9%E5%92%8C%E5%BC%80%E7%AB%8B%E6%96%B9%E4%BC%98%E5%8C%96"><span class="toc-number">161.2.</span> <span class="toc-text">方法 2、开平方和开立方优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E6%9C%80%E9%AB%98%E6%B5%B7%E6%8B%94"><span class="toc-number">162.</span> <span class="toc-text">1732、找到最高海拔</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%AB%AF%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E5%90%8E%E7%9A%84%E6%9C%80%E7%9F%AD%E9%95%BF%E5%BA%A6"><span class="toc-number">163.</span> <span class="toc-text">1750. 删除字符串两端相同字符后的最短长度</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%BB%8F%E6%8E%92%E5%BA%8F%E5%92%8C%E8%BD%AE%E8%BD%AC%E5%BE%97%E5%88%B0"><span class="toc-number">164.</span> <span class="toc-text">1752、检查数组是否经排序和轮转得到</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4%E7%9F%B3%E5%AD%90%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86"><span class="toc-number">165.</span> <span class="toc-text">1753. 移除石子的最大得分</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">166.</span> <span class="toc-text">1754、构造字典序最大的合并字符串⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%9E%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">167.</span> <span class="toc-text">1759、统计同构子字符串的数目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83"><span class="toc-number">168.</span> <span class="toc-text">1760、袋子里最少数目的球⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%BF%9E%E6%8E%A5%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84"><span class="toc-number">169.</span> <span class="toc-text">1764. 通过连接另一个数组的子数组得到一个数组⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80kmp"><span class="toc-number">169.1.</span> <span class="toc-text">方法一、KMP⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BE%8E%E4%B8%BD%E5%80%BC%E4%B9%8B%E5%92%8C"><span class="toc-number">170.</span> <span class="toc-text">1781、所有子字符串美丽值之和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5"><span class="toc-number">171.</span> <span class="toc-text">1784、检查二进制字符串字段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%AD%A3%E5%B8%B8%E6%80%9D%E8%B7%AF"><span class="toc-number">171.1.</span> <span class="toc-text">方法一、正常思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">171.2.</span> <span class="toc-text">方法二、一行代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E6%88%90%E7%89%B9%E5%AE%9A%E5%92%8C%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%9C%80%E5%B0%91%E5%85%83%E7%B4%A0"><span class="toc-number">172.</span> <span class="toc-text">1785. 构成特定和需要添加的最少元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%85%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E6%8D%A2%E8%83%BD%E5%90%A6%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89"><span class="toc-number">173.</span> <span class="toc-text">1790、仅执行一次字符串交换能否使两个字符串相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87"><span class="toc-number">174.</span> <span class="toc-text">1792. 最大平均通过率⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tips-1"><span class="toc-number">174.1.</span> <span class="toc-text">tips</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AA%8C%E8%AF%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">175.</span> <span class="toc-text">1797. 设计一个验证系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%A0%E8%83%BD%E6%9E%84%E9%80%A0%E5%87%BA%E8%BF%9E%E7%BB%AD%E5%80%BC%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE"><span class="toc-number">176.</span> <span class="toc-text">1798. 你能构造出连续值的最大数目⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">176.1.</span> <span class="toc-text">方法一、动态规划+贪心算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#n-%E6%AC%A1%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E6%95%B0%E5%92%8C"><span class="toc-number">177.</span> <span class="toc-text">1799. N 次操作后的最大分数和⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-number">178.</span> <span class="toc-text">1800、最大升序子数组和</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%AF%E5%8E%8B%E8%AE%A2%E5%8D%95%E4%B8%AD%E7%9A%84%E8%AE%A2%E5%8D%95%E6%80%BB%E6%95%B0"><span class="toc-number">179.</span> <span class="toc-text">1801、积压订单中的订单总数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80hashmap-%E6%90%9C%E7%B4%A2arraylist-%E6%8E%92%E5%BA%8F"><span class="toc-number">179.1.</span> <span class="toc-text">方法一、HashMap 搜索+ArrayList 排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E9%A2%98%E8%A7%A3"><span class="toc-number">179.2.</span> <span class="toc-text">方法二、题解🐶</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%89%E7%95%8C%E6%95%B0%E7%BB%84%E4%B8%AD%E6%8C%87%E5%AE%9A%E4%B8%8B%E6%A0%87%E5%A4%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">180.</span> <span class="toc-text">1802. 有界数组中指定下标处的最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%98%E5%8E%9F%E6%8E%92%E5%88%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AD%A5%E6%95%B0"><span class="toc-number">181.</span> <span class="toc-text">1806、还原排列的最少操作步数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%86%85%E5%AE%B9"><span class="toc-number">182.</span> <span class="toc-text">1807. 替换字符串中的括号内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%A5%E5%AD%90%E7%9B%B8%E4%BC%BC%E6%80%A7-iii"><span class="toc-number">182.1.</span> <span class="toc-text">1813、句子相似性 III⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%BD%E5%AF%B9%E5%AD%90%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">183.</span> <span class="toc-text">1814. 统计一个数组中好对子的数目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%94%A8%E6%88%B7%E6%B4%BB%E8%B7%83%E5%88%86%E9%92%9F%E6%95%B0"><span class="toc-number">184.</span> <span class="toc-text">1817. 查找用户活跃分钟数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">185.</span> <span class="toc-text">1819. 序列中不同最大公约数的数目⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9E%9A%E4%B8%BE"><span class="toc-number">185.1.</span> <span class="toc-text">方法一、枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%9E%9A%E4%B8%BE%E4%BC%98%E5%8C%96"><span class="toc-number">185.2.</span> <span class="toc-text">方法二、枚举优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E6%9C%80%E5%BC%BA%E4%BC%98%E5%8C%96"><span class="toc-number">185.3.</span> <span class="toc-text">方法三、最强优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7"><span class="toc-number">186.</span> <span class="toc-text">1822、数组元素积的符号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%91%E4%BE%A7%E8%B7%B3%E6%AC%A1%E6%95%B0"><span class="toc-number">187.</span> <span class="toc-text">1824. 最少侧跳次数⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BA%8C%E7%BB%B4"><span class="toc-number">187.1.</span> <span class="toc-text">方法一、动态规划（二维）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96%E4%B8%80%E7%BB%B4"><span class="toc-number">187.2.</span> <span class="toc-text">方法二、动态规划优化（一维）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E5%9C%86%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">188.</span> <span class="toc-text">1828. 统计一个圆中点的数目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E6%9A%B4%E5%8A%9B-1"><span class="toc-number">188.1.</span> <span class="toc-text">方法一、暴力</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8E%8B%E7%BC%A9%E6%90%9C%E7%B4%A2"><span class="toc-number">188.2.</span> <span class="toc-text">方法二、压缩搜索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%A5%E5%AD%90%E7%9B%B8%E4%BC%BC%E6%80%A7iii"><span class="toc-number">189.</span> <span class="toc-text">1913、句子相似性III</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B7%AF%E5%BE%84"><span class="toc-number">190.</span> <span class="toc-text">1971. 寻找图中是否存在路径</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%80%BC"><span class="toc-number">191.</span> <span class="toc-text">2011. 执行操作后的变量值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC"><span class="toc-number">192.</span> <span class="toc-text">2016、增量元素之间的最大差值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0"><span class="toc-number">193.</span> <span class="toc-text">2027. 转换字符串的最少操作次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%9C%80%E5%A4%A7%E5%AD%AA%E7%94%9F%E5%92%8C"><span class="toc-number">194.</span> <span class="toc-text">2130、链表最大孪生和</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%B8%B8%E8%A7%84%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">194.1.</span> <span class="toc-text">方法一、常规遍历+数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">194.2.</span> <span class="toc-text">方法二、双端队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%B3%E5%B0%91%E5%9C%A8%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E5%80%BC"><span class="toc-number">195.</span> <span class="toc-text">2032. 至少在两个数组中出现的值</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80hashmap%E4%BD%8D%E8%AE%B0%E5%BD%95"><span class="toc-number">195.1.</span> <span class="toc-text">方法一、HashMap+位记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8Chashmap%E6%8E%92%E5%BA%8F%E6%95%B0%E9%87%8F%E8%AE%B0%E5%BD%95"><span class="toc-number">195.2.</span> <span class="toc-text">方法二、HashMap+排序+数量记录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E6%AF%8F%E4%BD%8D%E5%AD%A6%E7%94%9F%E9%83%BD%E6%9C%89%E5%BA%A7%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">196.</span> <span class="toc-text">2037. 使每位学生都有座位的最少移动次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E9%80%92%E5%A2%9E"><span class="toc-number">197.</span> <span class="toc-text">2042. 检查句子中的数字是否递增</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-number">198.</span> <span class="toc-text">2180. 统计各位数字之和为偶数的整数个数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%89%8D%E7%BC%80%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">199.</span> <span class="toc-text">2185. 统计包含给定前缀的字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%A4%A7%E4%BA%8E%E9%9B%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%84%E5%90%88"><span class="toc-number">200.</span> <span class="toc-text">2275、按位与结果大于零的最长组合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%E6%98%AF%E5%90%A6%E7%AD%89%E4%BA%8E%E6%95%B0%E4%BD%8D%E7%9A%84%E5%80%BC"><span class="toc-number">201.</span> <span class="toc-text">2283. 判断一个数的数字计数是否等于数位的值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%AD%97%E7%AC%A6%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">202.</span> <span class="toc-text">2287. 重排字符形成目标字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E6%B8%B8%E6%88%8F"><span class="toc-number">203.</span> <span class="toc-text">2293、极大极小游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80list-%E6%93%8D%E4%BD%9C"><span class="toc-number">203.1.</span> <span class="toc-text">方法一、list 操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%95%B0%E7%BB%84%E5%8E%9F%E5%9C%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">203.2.</span> <span class="toc-text">方法二、数组原地操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%BA%E5%AF%86%E7%A0%81%E6%A3%80%E9%AA%8C%E5%99%A8-ii"><span class="toc-number">204.</span> <span class="toc-text">2299. 强密码检验器 II</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BA%94%E7%BC%B4%E7%A8%8E%E6%AC%BE%E6%80%BB%E9%A2%9D"><span class="toc-number">205.</span> <span class="toc-text">2303. 计算应缴税款总额</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%BC%E5%85%B7%E5%A4%A7%E5%B0%8F%E5%86%99%E7%9A%84%E6%9C%80%E5%A5%BD%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D"><span class="toc-number">206.</span> <span class="toc-text">2309. 兼具大小写的最好英文字母</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%98%9F%E5%8F%B7"><span class="toc-number">207.</span> <span class="toc-text">2315. 统计星号</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%9F%A9%E9%98%B5%E6%98%AF%E5%90%A6%E6%98%AF%E4%B8%80%E4%B8%AA-x-%E7%9F%A9%E9%98%B5"><span class="toc-number">208.</span> <span class="toc-text">2319. 判断矩阵是否是一个 X 矩阵</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%AF%86%E6%B6%88%E6%81%AF"><span class="toc-number">209.</span> <span class="toc-text">2325. 解密消息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B8%83%E5%B0%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%80%BC"><span class="toc-number">210.</span> <span class="toc-text">2331. 计算布尔二叉树的值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%85%E6%BB%A1%E6%9D%AF%E5%AD%90%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E7%9F%AD%E6%80%BB%E6%97%B6%E9%95%BF"><span class="toc-number">211.</span> <span class="toc-text">2335. 装满杯子需要的最短总时长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%83%BD%E5%BD%A2%E6%88%90%E5%A4%9A%E5%B0%91%E6%95%B0%E5%AF%B9"><span class="toc-number">212.</span> <span class="toc-text">2341. 数组能形成多少数对</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD%E7%9A%84%E6%89%91%E5%85%8B%E6%89%8B%E7%89%8C"><span class="toc-number">213.</span> <span class="toc-text">2347. 最好的扑克手牌</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%87%BA%E7%8E%B0%E4%B8%A4%E6%AC%A1%E7%9A%84%E5%AD%97%E6%AF%8D"><span class="toc-number">214.</span> <span class="toc-text">2351. 第一个出现两次的字母</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E7%AD%89%E4%BA%8E%E9%9B%B6"><span class="toc-number">215.</span> <span class="toc-text">2357. 使数组中所有元素都等于零</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E7%9B%B8%E4%BC%BC%E7%9A%84%E7%89%A9%E5%93%81"><span class="toc-number">216.</span> <span class="toc-text">2363. 合并相似的物品</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">217.</span> <span class="toc-text">2367. 算术三元组的数目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">218.</span> <span class="toc-text">2373. 矩阵中的局部最大值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%97%E5%88%B0-k-%E4%B8%AA%E9%BB%91%E5%9D%97%E7%9A%84%E6%9C%80%E5%B0%91%E6%B6%82%E8%89%B2%E6%AC%A1%E6%95%B0"><span class="toc-number">219.</span> <span class="toc-text">2379. 得到 K 个黑块的最少涂色次数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B5%A2%E5%BE%97%E6%AF%94%E8%B5%9B%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E8%AE%AD%E7%BB%83%E6%97%B6%E9%95%BF"><span class="toc-number">220.</span> <span class="toc-text">2383、赢得比赛需要的最少训练时长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8C%E6%9C%89%E9%99%90%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">221.</span> <span class="toc-text">2389. 和有限的最长子序列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">222.</span> <span class="toc-text">2395. 和相等的子数组</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E7%9B%B8%E5%90%8C%E5%AD%97%E6%AF%8D%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB"><span class="toc-number">223.</span> <span class="toc-text">2399. 检查相同字母间的距离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%9C%80%E9%A2%91%E7%B9%81%E7%9A%84%E5%81%B6%E6%95%B0%E5%85%83%E7%B4%A0"><span class="toc-number">224.</span> <span class="toc-text">2404. 出现最频繁的偶数元素</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E5%85%B1%E5%90%8C%E5%BA%A6%E8%BF%87%E7%9A%84%E6%97%A5%E5%AD%90%E6%95%B0"><span class="toc-number">225.</span> <span class="toc-text">2409. 统计共同度过的日子数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%81%B6%E5%80%8D%E6%95%B0"><span class="toc-number">226.</span> <span class="toc-text">2413. 最小偶倍数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%89%E8%BA%AB%E9%AB%98%E6%8E%92%E5%BA%8F"><span class="toc-number">227.</span> <span class="toc-text">2418. 按身高排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%BD%BF%E9%A2%91%E7%8E%87%E7%9B%B8%E5%90%8C"><span class="toc-number">228.</span> <span class="toc-text">2423. 删除字符使频率相同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E5%9B%A0%E5%AD%90%E7%9A%84%E6%95%B0%E7%9B%AE"><span class="toc-number">229.</span> <span class="toc-text">2427. 公因子的数目</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B8%A9%E5%BA%A6%E8%BD%AC%E6%8D%A2"><span class="toc-number">230.</span> <span class="toc-text">2469. 温度转换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%B8%AD%E4%BD%8D%E6%95%B0%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">231.</span> <span class="toc-text">2488. 统计中位数为 K 的子数组⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-01.02.-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92"><span class="toc-number">232.</span> <span class="toc-text">面试题 01.02. 判定是否互为字符重排⭐</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="toc-number">233.</span> <span class="toc-text">剑指 Offer 47. 礼物的最大价值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9801.05.%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91"><span class="toc-number">234.</span> <span class="toc-text">面试题01.05.一次编辑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-01.08%E9%9B%B6%E7%9F%A9%E9%98%B5"><span class="toc-number">235.</span> <span class="toc-text">面试题 01.08、零矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E4%B8%A4%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">235.1.</span> <span class="toc-text">方法一、两次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%B8%A4%E4%B8%AA%E6%A0%87%E8%AE%B0%E5%8F%98%E9%87%8F"><span class="toc-number">235.2.</span> <span class="toc-text">方法二、两个标记变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-01.09%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC"><span class="toc-number">236.</span> <span class="toc-text">面试题 01.09、字符串轮转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%88%A9%E7%94%A8%E5%AD%90%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-number">236.1.</span> <span class="toc-text">方法一、利用子串匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E6%8C%87%E9%92%88%E7%A7%BB%E5%8A%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">236.2.</span> <span class="toc-text">方法二、指针移动关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-05.02.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">237.</span> <span class="toc-text">面试题 05.02. 二进制数转字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-17.05.-%E5%AD%97%E6%AF%8D%E4%B8%8E%E6%95%B0%E5%AD%97"><span class="toc-number">238.</span> <span class="toc-text">面试题 17.05. 字母与数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E5%89%8D%E7%BC%80%E5%92%8C%E5%AE%9A%E9%95%BF"><span class="toc-number">238.1.</span> <span class="toc-text">方法一、前缀和+定长</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%89%8D%E7%BC%80%E5%92%8C%E5%93%88%E5%B8%8C"><span class="toc-number">238.2.</span> <span class="toc-text">方法二、前缀和+哈希⭐</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9817.09%E7%AC%ACk%E4%B8%AA%E6%95%B0"><span class="toc-number">239.</span> <span class="toc-text">面试题17.09、第k个数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E7%A1%AC%E7%AE%97"><span class="toc-number">239.1.</span> <span class="toc-text">方法一、硬算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="toc-number">239.2.</span> <span class="toc-text">方法二、小根堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="toc-number">239.2.1.</span> <span class="toc-text">小根堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">239.2.2.</span> <span class="toc-text">Set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hashset"><span class="toc-number">239.2.2.1.</span> <span class="toc-text">HashSet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E5%A4%9A%E6%8C%87%E9%92%88%E6%96%B9%E6%B3%95%E4%B8%80%E4%BC%98%E5%8C%96"><span class="toc-number">239.3.</span> <span class="toc-text">方法三、多路归并（多指针）（方法一优化）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-6"><span class="toc-number">239.3.1.</span> <span class="toc-text">注意</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-17.19%E6%B6%88%E5%A4%B1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="toc-number">240.</span> <span class="toc-text">面试题 17.19、消失的两个数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E7%A1%AC%E7%AE%97%E4%B8%8D%E5%90%88%E8%A7%84%E7%9F%A9"><span class="toc-number">240.1.</span> <span class="toc-text">方法一、硬算（不合规矩）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%BC%82%E6%88%96%E5%AE%98%E6%96%B9"><span class="toc-number">240.2.</span> <span class="toc-text">方法二、异或（官方）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E6%B1%82%E5%92%8C"><span class="toc-number">240.3.</span> <span class="toc-text">方法三、求和</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/%E5%B0%81%E9%9D%A2%E5%9B%BE2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By 火星架构师</div><div class="footer_custom_text">In me the tiger sniffs the rose.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><script async src="//at.alicdn.com/t/c/font_3880675_zk98w3veu9n.js"></script><script async src="/js/fps.js"></script><script async src="//at.alicdn.com/t/c/font_3880675_w3xksiojrkh.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(/img/封面图2.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/人工智能/&quot;);" href="javascript:void(0);">人工智能</a><span class="categoryBar-list-count">23</span><span class="categoryBar-list-descr">LeetCode</span></li><li class="categoryBar-list-item" style="background:url(/img/封面图2.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/LeetCode/&quot;);" href="javascript:void(0);">LeetCode</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">人工智能</span></li><li class="categoryBar-list-item" style="background:url(/img/封面图2.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/SpringBoot/&quot;);" href="javascript:void(0);">SpringBoot</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">数据库</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库/&quot;);" href="javascript:void(0);">数据库</a><span class="categoryBar-list-count">5</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/服务器/&quot;);" href="javascript:void(0);">服务器</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/骚操作/&quot;);" href="javascript:void(0);">骚操作</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>