<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>心脏疾病预测</title>
      <link href="/2023/05/02/%E5%BF%83%E8%84%8F%E7%96%BE%E7%97%85%E9%A2%84%E6%B5%8B/"/>
      <url>/2023/05/02/%E5%BF%83%E8%84%8F%E7%96%BE%E7%97%85%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据集：<a href="https://www.kaggle.com/datasets/ketangangal/heart-disease-dataset-uci">Kaggle-Heart Disease Dataset UCI</a></p></blockquote><h1 id="导包">导包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paddle</span><br><span class="line"><span class="keyword">from</span> paddle.nn <span class="keyword">import</span> Linear</span><br><span class="line"><span class="keyword">import</span> paddle.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br></pre></td></tr></table></figure><h1 id="数据分析">数据分析</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(file_path)</span><br></pre></td></tr></table></figure><p>可以看出有多个特征，然后用这些特征预测一个结果，是一个典型的分类问题。看 <code>target</code> 标签内容可知，这是一个二分类问题——我们自然想到要使用 sigmoid 函数。</p><h1 id="数据处理">数据处理</h1><p>通过数据分析，我们可以看到数据中包含文字，但是每一个特征的内容其实就是那个几种，所以我们对每个特征进行标号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">change_df</span>(<span class="params">df</span>):</span><br><span class="line">    df[<span class="string">&quot;sex&quot;</span>].replace(&#123;<span class="string">&quot;Male&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&quot;Female&quot;</span> : <span class="number">0</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;chest_pain_type&quot;</span>].replace(&#123;<span class="string">&quot;Typical angina&quot;</span> : <span class="number">0</span>,</span><br><span class="line">                                    <span class="string">&quot;Atypical angina&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                                    <span class="string">&quot;Non-anginal pain&quot;</span> : <span class="number">2</span>,</span><br><span class="line">                                    <span class="string">&quot;Asymptomatic&quot;</span> : <span class="number">3</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;fasting_blood_sugar&quot;</span>].replace(&#123;<span class="string">&quot;Greater than 120 mg/ml&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                                    <span class="string">&quot;Lower than 120 mg/ml&quot;</span> : <span class="number">0</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;rest_ecg&quot;</span>].replace(&#123;<span class="string">&quot;Normal&quot;</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">&quot;ST-T wave abnormality&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&quot;Left ventricular hypertrophy&quot;</span> : <span class="number">2</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;exercise_induced_angina&quot;</span>].replace(&#123;<span class="string">&quot;Yes&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                                        <span class="string">&quot;No&quot;</span> : <span class="number">0</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;slope&quot;</span>].replace(&#123;<span class="string">&quot;Upsloping&quot;</span> : <span class="number">0</span>,</span><br><span class="line">                        <span class="string">&quot;Flat&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&quot;Downsloping&quot;</span> : <span class="number">3</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;vessels_colored_by_flourosopy&quot;</span>].replace(&#123;<span class="string">&quot;Zero&quot;</span> : <span class="number">0</span>,</span><br><span class="line">                                                <span class="string">&quot;One&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                                                <span class="string">&quot;Two&quot;</span> : <span class="number">2</span>,</span><br><span class="line">                                                <span class="string">&quot;Three&quot;</span> : <span class="number">3</span>,</span><br><span class="line">                                                <span class="string">&quot;Four&quot;</span> : <span class="number">4</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    df[<span class="string">&quot;thalassemia&quot;</span>].replace(&#123;<span class="string">&quot;Normal&quot;</span> : <span class="number">1</span>,</span><br><span class="line">                            <span class="string">&quot;Fixed Defect&quot;</span> : <span class="number">2</span>,</span><br><span class="line">                            <span class="string">&quot;Reversable Defect&quot;</span> : <span class="number">3</span>,</span><br><span class="line">                            <span class="string">&quot;No&quot;</span> : <span class="number">0</span>&#125;, inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><p>在这之后，数据就很漂亮了，即根据一些数字和权重进行预测的二分类问题。</p><p>将 data 文件按照 8: 2 分为 train 和 test 两个文件。对于 train 和 test，将其前面 13 个特征放在一个变量，最后一个特征（target）放在一个变量，即构造 train_x，train_y，test_x，test_y。</p><h1 id="建模">建模</h1><p>对于表格数据，最好用的神经网络其实就是 ANN 模型（MLP），它简单快速，更加契合表格的分析。</p><p>这里需要注意的是第一层 Linear 层的输入维度需要是 13，最后一层 Linear 层的输出维度需要是 2（因为这是 2 分类）。对最后一层输出的结果作 sigmoid，结果就是预测的分类。</p><p>模型如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mymodel</span>(paddle.nn.Layer):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Mymodel, self).__init__()</span><br><span class="line">        self.layer1 = Linear(<span class="number">13</span>, <span class="number">20</span>)</span><br><span class="line">        self.relu1 = paddle.nn.ReLU()</span><br><span class="line">        self.dropout1 = paddle.nn.Dropout(<span class="number">0.2</span>)</span><br><span class="line">        self.layer2 = Linear(<span class="number">20</span>, <span class="number">25</span>)</span><br><span class="line">        self.relu2 = paddle.nn.ReLU()</span><br><span class="line">        self.dropout2 = paddle.nn.Dropout(<span class="number">0.5</span>)</span><br><span class="line">        self.layer3 = Linear(<span class="number">25</span>, <span class="number">10</span>)</span><br><span class="line">        self.relu3 = paddle.nn.ReLU()</span><br><span class="line">        self.output_layer = Linear(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">        self.sigmoid = paddle.nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.layer1(x)</span><br><span class="line">        x = self.relu1(x)</span><br><span class="line">        x = self.dropout1(x)</span><br><span class="line">        x = self.layer2(x)</span><br><span class="line">        x = self.relu2(x)</span><br><span class="line">        x = self.dropout2(x)</span><br><span class="line">        x = self.layer3(x)</span><br><span class="line">        x = self.relu3(x)</span><br><span class="line">        x = self.output_layer(x)</span><br><span class="line">        x = self.sigmoid(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><h1 id="参数准备">参数准备</h1><h3 id="模型实例化">模型实例化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Mymodel()</span><br></pre></td></tr></table></figure><h3 id="定义参数">定义参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt = paddle.optimizer.AdamW(learning_rate=<span class="number">0.001</span>, parameters=model.parameters())</span><br></pre></td></tr></table></figure><h3 id="定义-gpu">定义 GPU</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_gpu = <span class="literal">True</span></span><br><span class="line">paddle.device.set_device(<span class="string">&#x27;gpu:0&#x27;</span>) <span class="keyword">if</span> use_gpu <span class="keyword">else</span> paddle.device.set_device(<span class="string">&#x27;cpu&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="训练">训练</h1><p>放在 model 种进行训练的需要时 tensor 张量形式。在转成张量之前，需要将数据先转为 numpy 形式，再利用 <code>paddle.to_tensor</code> 函数转为张量。这里需要注意，target 需要 dtype 为 int64 类型，因为在计算 loss 时，使用的是用于分类问题的 <code>F.cross_entropy</code> 函数，这需要接收两个<strong>整数</strong>张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EPOCH_NUM = <span class="number">500</span>   <span class="comment"># 设置外层循环次数</span></span><br><span class="line">BATCH_SIZE = <span class="number">32</span>  <span class="comment"># 设置batch大小</span></span><br><span class="line"></span><br><span class="line">model.train()</span><br><span class="line"><span class="keyword">for</span> epoch_id <span class="keyword">in</span> <span class="built_in">range</span>(EPOCH_NUM):</span><br><span class="line">    np.random.shuffle(train_data)</span><br><span class="line">    mini_batches = [train_data[k:k+BATCH_SIZE] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(train_data), BATCH_SIZE)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> iter_id, mini_batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(mini_batches):</span><br><span class="line">        x = np.array(mini_batch[:, :-<span class="number">1</span>]) <span class="comment"># 获得当前批次训练数据     [10,13]</span></span><br><span class="line">        y = np.array(mini_batch[:, -<span class="number">1</span>:]) <span class="comment"># 获得当前批次训练标签      [10,1]</span></span><br><span class="line">        x_feature = paddle.to_tensor(x)     <span class="comment"># [10,13]</span></span><br><span class="line">        target = paddle.to_tensor(y, dtype=<span class="string">&#x27;int64&#x27;</span>)    <span class="comment"># [10,1]</span></span><br><span class="line">        </span><br><span class="line">        predicts = model(x_feature)</span><br><span class="line">        </span><br><span class="line">        loss = F.cross_entropy(predicts, target)    <span class="comment"># [10,1]</span></span><br><span class="line">        avg_loss = paddle.mean(loss)</span><br><span class="line">        <span class="keyword">if</span> iter_id%<span class="number">20</span>==<span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;&#125;, iter: &#123;&#125;, loss is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch_id, iter_id, avg_loss.numpy()))</span><br><span class="line">        </span><br><span class="line">        avg_loss.backward()</span><br><span class="line">        opt.step()</span><br><span class="line">        opt.clear_grad()</span><br></pre></td></tr></table></figure><p>训练完成后保存模型，方便进行预测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paddle.save(model.state_dict(), <span class="string">&#x27;H_model.pdparams&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="预测">预测</h1><p>先导入模型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">param_dict = paddle.load(<span class="string">&#x27;H_model.pdparams&#x27;</span>)</span><br><span class="line">model.load_dict(param_dict)</span><br></pre></td></tr></table></figure><p>改为预测模式在将 test_x 数据进行预测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">eval</span>()</span><br><span class="line">predictions=[]</span><br><span class="line"><span class="keyword">for</span> i,dt <span class="keyword">in</span> <span class="built_in">enumerate</span>(test_x):</span><br><span class="line">    y_pred=model(paddle.to_tensor(dt))</span><br><span class="line">    predictions.append(y_pred.argmax().item())</span><br></pre></td></tr></table></figure><p>计算准确率：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accuracy = accuracy_score(test_y,predictions)</span><br></pre></td></tr></table></figure><h1 id="结果">结果</h1><p><strong>The accuracy of model is 87.8048780487805 %</strong></p><h1 id="相关链接">相关链接</h1><p>数据集：<a href="https://www.kaggle.com/datasets/ketangangal/heart-disease-dataset-uci">Kaggle-Heart Disease Dataset UCI</a></p><p>github：<a href="https://github.com/Wang-Ruiyang/Heart_Disease_Datase_UCI_By_Paddle">Heart_Disease_Datase_UCI_By_Paddle</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器操作（1）</title>
      <link href="/2023/03/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%B3%E8%BD%AC%E7%99%BB%E5%BD%95/"/>
      <url>/2023/03/06/%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%B3%E8%BD%AC%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>实验室 8 号机不知道为什么崩了，利用 Termius 无法登录。通过与管理员学长一番交谈得知，是在过去配置静态 ip 时遗留的问题（具体我也不太懂），总之最近无法恢复……因为自己有很多文件存储在这个服务器中，且曾经花费了很多时间配置文件，所以在学长的介绍下，推荐<strong>使用 VSCode 进行跨跳板机连接服务器</strong>。</p><h1 id="安装-vscode">安装 VSCode</h1><p>这就不用多说了吧……点击下载连接，无脑安装即可 <a href="https://code.visualstudio.com/">⟦下载链接⟧</a></p><h1 id="安装插件">安装插件</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061455599.png" /></p><h1 id="配置-ssh">配置 ssh</h1><ol type="1"><li>输入 <code>Ctrl+Shift+P</code>，或者如下图点击：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061456078.png" /></p><ol start="2" type="1"><li>找到下图，并点击：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061457079.png" /></p><ol start="3" type="1"><li>点击进入 config</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061458616.png" /></p><ol start="4" type="1"><li>点击进入文件：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061458209.png" /></p><ol start="5" type="1"><li>配置文件内容：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061500920.png" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Host jump          </span><br><span class="line">  HostName  </span><br><span class="line">  Port            </span><br><span class="line">  User </span><br><span class="line"></span><br><span class="line">Host target        </span><br><span class="line">  HostName   </span><br><span class="line">  User     </span><br><span class="line">  Port </span><br><span class="line">  ProxyCommand ssh -W %h:%p jump</span><br></pre></td></tr></table></figure><p><code>Ctrl+C</code> 保存。</p><h1 id="进入服务器">进入服务器</h1><ol type="1"><li>右击目标服务器，进行连接。</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061503394.png" /></p><ol start="2" type="1"><li>点击 Linux：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061504490.png" /></p><ol start="3" type="1"><li>再输入两个服务器的密码：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061504357.png" /></p><ol start="4" type="1"><li>显示文件夹：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061505729.png" /></p><h1 id="安装-jupyter-插件">安装 jupyter 插件</h1><p>在服务器上安装 jupyter 的插件：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061507103.png" /></p><p>这样就可以成功使用服务器资源啦！</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch基础系列（5）</title>
      <link href="/2023/03/02/5-LSTM/"/>
      <url>/2023/03/02/5-LSTM/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1><p><strong>LSTM（Long Short-Term Memory Networks）</strong>，翻译过来是<strong>长时间的短期记忆网络</strong>，它的本质就是能够记住很长时期内的信息（能记的长度长，但是保存的时间短）。</p><p>在普通 RNN 中，循环神经网络结构都是由结构完全相同的模块进行复制而成的。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021125573.png" /></p><p>LSTM 也有类似的结构，唯一的区别就是中间的部分，LSTM 不再只是一个单一的 tanh 层，而使用了四个相互作用的层。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021127384.png" /></p><p>这里解释图中的符号。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021130897.png" /></p><ul><li>黄色的矩阵：表示的是一个神经网络层。</li><li>粉红色的圆圈：表示逐点操作，如向量乘法、加法等。</li><li>线：表示传递着一个向量，从一个节点中输入到另一个节点。</li><li>合并的线：表示把两条线上所携带的向量进行合并（比如一个是 <span class="math inline">\(ℎ_{t−1}\)</span>，另一个是 <span class="math inline">\(x_t\)</span>，那么合并后的输出就是 <span class="math inline">\([h_{t-1},x_t]\)</span>）。</li><li>分开的线：表示将线上传递的向量复制一份，传给两个地方。</li></ul><h1 id="lstm-核心思想">LSTM 核心思想</h1><p>LSTM 的关键是 cell 状态，即贯穿图顶部的水平线。<br />cell 状态的传输就像一条传送带，向量从整个 cell 中穿过，只是做了少量的线性操作，这<strong>种结构能很轻松地实现信息从整个 cell 中穿过而不做改变（这样就可以实现长时期地记忆保留）。</strong></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021134444.png" /></p><p>LSTM 也有能力向 cell 状态中添加或删除信息，这是由称为<strong>门（gates）</strong> 的结构仔细控制的。<strong>门</strong>可以选择性的让信息通过，它们由 sigmoid 神经网络层和逐点相乘实现。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021512406.png" /></p><p>每个 LSTM 有三个这样的<strong>门</strong>结构来实现控制信息： - forget gate 遗忘门 - input gate 输入门 - output gate 输出门</p><h2 id="遗忘门">遗忘门</h2><p>LSTM 的第一步是<strong>决定要从 cell 状态中丢弃什么信息</strong>，这个决定是由一个名为 <code>forget gate layer</code> 的 sigmoid 神经层来实现的。</p><p>它的输入是 <span class="math inline">\(h_{t-1}\)</span> 和 <span class="math inline">\(x_t\)</span>，输出是一个数值都在 0~1 之间的向量（向量长度和 <span class="math inline">\(C_{t-1}\)</span> 一样），表示让 <span class="math inline">\(C_{t-1}\)</span> 的各部分信息通过的比重，0 表示不让任何信息通过，1 表示让所有信息通过</p><p>思考一个具体的例子：假设一个语言模型试图基于前面所有的词预测下一个单词，在这种情况下，每个 cell 状态都应该包含了当前主语的性别（<strong>保留信息</strong>），这样接下来我们才能正确使用代词；但是当我们又开始描述一个新的主语时，就应该把旧主语的性别给忘了才对（<strong>忘记信息</strong>）</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021522968.png" /></p><h2 id="输入门">输入门</h2><p>第二步是<strong>决定要让多少新的信息加入到 cell 状态中。</strong><br />实现这个需要包括两个步骤： 1. 首先，一个叫做 <code>input gate layer</code> 的 sigmoid 层决定哪些信息需要更新。另一个 tanh 层创建一个新的 candidate 向量 <span class="math inline">\(C_t\)</span>。 2. 之后，我们把这两个部分联合起来对 cell 状态进行更新。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021524401.png" /></p><p>在我们的语言模型的例子中，我们想把新的主语性别信息添加到 cell 状态中，替换掉老的状态信息。<br />有了上述的结构，我们就能够更新 cell 状态了，即把 <span class="math inline">\(C_{t-1}\)</span> 更新为 <span class="math inline">\(C_t\)</span>。<br />从结构图中应该能一目了然，首先我们把旧的状态 <span class="math inline">\(C_{t-1}\)</span> 和 <span class="math inline">\(f_t\)</span> 相乘，把一些不想保留的信息忘掉，然后加上 <span class="math inline">\(i_{t}* C_t\)</span>。这部分信息就是我们要添加的新内容。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021527016.png" /></p><h2 id="输出门">输出门</h2><p>最后，需要决定输出什么值。这个输出主要是依赖于 cell 状态 <span class="math inline">\(C_t\)</span>，但是是经过筛选的版本。</p><p>首先，经过一个 sigmoid 层，它决定 <span class="math inline">\(C_t\)</span> 中的哪些部分将会被输出。接着，我们把 <span class="math inline">\(C_t\)</span> 通过一个 tanh 层（把数值归一化到 - 1 和 1 之间），然后把 tanh 层的输出和 simoid 层计算出来的权重相乘，这样就得到了最后的输出结果。</p><p>在语言模型例子中，假设我们的模型刚刚接触了一个代词，接下来可能要输出一个动词，这个输出可能就和代词的信息有关了。比如说，这个动词应该采用单数形式还是复数形式，那么我们就得把刚学到的和代词相关的信息都加入到 cell 状态中来，才能够进行正确的预测。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021548085.png" /></p><h1 id="原理示例">原理示例</h1><p>假设传入到 cell 的 input 叫做 <span class="math inline">\(z\)</span>，操控 input gate 的信号记为 <span class="math inline">\(z_i\)</span>，控制 forget gate 的信号记为 <span class="math inline">\(z_f\)</span>，控制 output gate 的信号记为 <span class="math inline">\(z_o\)</span>，综合这些东西得到的 output 记为 <span class="math inline">\(a\)</span>，假设 memory 里面已经存了一个值 <span class="math inline">\(c\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021601710.png" /></p><p>先看下图具体的 cell，每条线上面的值就是 <span class="math inline">\(weight\)</span>，绿色框和线构成 <span class="math inline">\(bias\)</span>，<code>input gate</code> 和 <code>forget gate</code> 的 activation function 都是 sigmoid，为了方便，<span class="math inline">\(z_i,z_o,z_f\)</span> 直接利用输入的 vector，<span class="math inline">\(g\)</span> 和 <span class="math inline">\(h\)</span> 假设都是 Linear（这样计算比较方便），假设存到 memory 里面的初值是 0。</p><p>在实际运算前，我们先根据它的 input 以及其它参数，分析可能会得到的结果。<br />底下这个从外界传入的 cell，<span class="math inline">\(x_1\)</span> 乘以 1，其它 <span class="math inline">\(x\)</span> 乘以 0，相当于直接把 <span class="math inline">\(x_1\)</span> 当做输入。<br />在 <code>input gate</code> 中，<span class="math inline">\(x_2\)</span> 乘以 100，<span class="math inline">\(bias\)</span> 是 -10。<br />在 <code>forget gate</code> 中，也是 <span class="math inline">\(x_2\)</span> 乘以 100， <span class="math inline">\(bias\)</span> 是 10。<br />在 <code>output gate</code> 中，<span class="math inline">\(x_3\)</span> 乘以 100，<span class="math inline">\(bias\)</span> 是 - 10。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021604324.png" /></p><h2 id="例-1">例 1</h2><p>带入一个实际的 input([3, 1, 0]) 。<br /><code>input</code> 这里 3*1=3。<br /><code>input gate</code> 这边是 1*100-10=90，但是由于要经过一个 sigmoid，所以 ≈1，那么 <span class="math inline">\(g(z)*f(z_i)=3\)</span>。<br /><code>forget gate</code> 这边是 1*100+10=110，也要经过一个 sigmoid，所以 ≈1，那么此时 memory 的值 <span class="math inline">\(c\)</span> 就更新为 <span class="math inline">\(c&#39;=g(z)*f(z_i)+c*f(z_f)=3+0∗1=3\)</span>。<br /><code>output gate</code> 这边是 0*100-10=-10，经过 sigmoid 以后 ≈0。<br />最终输出 <span class="math inline">\(a=h(c&#39;)*f(z_o)=0\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021628865.png" /></p><p>掐他案例同理~（注意更新后的 <span class="math inline">\(c\)</span> 依赖于更新前的 <span class="math inline">\(c\)</span>）</p><h1 id="pytorch-实现">PyTorch 实现</h1><p>这里给出 LSTM 的 Api 链接：<a href="https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html#torch.nn.LSTM">LSTM — PyTorch 1.13 documentation</a></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021652474.png" /></p><p>输入数据格式：</p><ul><li>input：<code>[seq_len, batch, input_size]</code></li><li><span class="math inline">\(ℎ_0\)</span> ：<code>[num_layers * num_directions, batch, hidden_size]</code></li><li><span class="math inline">\(c_0\)</span> ：<code>[num_layers * num_directions, batch, hidden_size]</code></li></ul><p>输出数据格式：</p><ul><li>output：<code>[seq_len, batch, hidden_size * num_directions]</code></li><li><span class="math inline">\(h_n\)</span> ：<code>[num_layers * num_directions, batch, hidden_size]</code></li><li><span class="math inline">\(c_n\)</span> ：<code>[num_layers * num_directions, batch, hidden_size]</code></li></ul><h2 id="导包">导包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br></pre></td></tr></table></figure><h2 id="调用">调用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lstm = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">20</span>, num_layers=<span class="number">4</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个句子10个单词，送进去3条句子，每个单词用一个100维的vector表示  </span></span><br><span class="line">X = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">100</span>)       </span><br><span class="line"></span><br><span class="line">out, (h_n, c_n) = lstm(X)  </span><br><span class="line"><span class="built_in">print</span>(out.shape, h_n.shape, c_n.shape)</span><br></pre></td></tr></table></figure><blockquote><p>torch. Size ([10, 3, 20])<br />torch. Size ([4, 3, 20])<br />torch. Size ([4, 3, 20])</p></blockquote><h2 id="lstmcell">LSTMCell</h2><h3 id="lstm-和-lstmcell">LSTM 和 LSTMCell</h3><p>LSTMCEll 就是 LSTM 的物理结构，即：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021936740.png" /></p><p>而 LSTM 则是 LSTMcell 在时间上的扩展，即：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303021127384.png" /></p><p>输入 <code>input_size</code> 的 shape 是 <code>[batch, input_size]</code><br />输出 <span class="math inline">\(h_t\)</span> 和 <span class="math inline">\(c_t\)</span> 的 shape 是 <code>[batch, hidden_size]</code></p><h3 id="单层-lstm">单层 LSTM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cell = nn.LSTMCell(input_size=<span class="number">100</span>, hidden_size=<span class="number">20</span>)  </span><br><span class="line">x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">100</span>)  </span><br><span class="line">h = torch.zeros(<span class="number">3</span>,<span class="number">20</span>)  </span><br><span class="line">c = torch.zeros(<span class="number">3</span>,<span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> xt <span class="keyword">in</span> x:  </span><br><span class="line">    h, c = cell(xt, [h,c])  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(h.shape, c.shape)</span><br></pre></td></tr></table></figure><blockquote><p>torch. Size ([3, 20])<br />torch. Size ([3, 20])</p></blockquote><h3 id="双层-lstm">双层 LSTM</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cell1 = nn.LSTMCell(input_size=<span class="number">100</span>, hidden_size=<span class="number">30</span>)  </span><br><span class="line">cell2 = nn.LSTMCell(input_size=<span class="number">30</span>, hidden_size=<span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line">x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">100</span>)  </span><br><span class="line">  </span><br><span class="line">h1 = torch.zeros(<span class="number">3</span>, <span class="number">30</span>)  </span><br><span class="line">c1 = torch.zeros(<span class="number">3</span>, <span class="number">30</span>)  </span><br><span class="line">h2 = torch.zeros(<span class="number">3</span>,<span class="number">20</span>)  </span><br><span class="line">c2 = torch.zeros(<span class="number">3</span>,<span class="number">20</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> xt <span class="keyword">in</span> x:  </span><br><span class="line">    h1, c1 = cell1(xt, [h1,c1])  </span><br><span class="line">    h2, c2 = cell2(h1, [h2,c2])  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(h2.shape, c2.shape)</span><br></pre></td></tr></table></figure><blockquote><p>torch. Size ([3, 20])<br />torch. Size ([3, 20])</p></blockquote><h1 id="bilstm-实现文本预测">BiLSTM 实现文本预测</h1><h2 id="导包-1">导包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim  </span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data  </span><br><span class="line">  </span><br><span class="line">dtype = torch.FloatTensor</span><br></pre></td></tr></table></figure><h2 id="准备数据">准备数据</h2><p>构建词向量索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sentence = (  </span><br><span class="line">    <span class="string">&#x27;GitHub Actions makes it easy to automate all your software workflows &#x27;</span>  </span><br><span class="line">    <span class="string">&#x27;from continuous integration and delivery to issue triage and more&#x27;</span>)    <span class="comment"># 实际上是一句话  </span></span><br><span class="line">  </span><br><span class="line">word2idx = &#123;w: i <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(sentence.split())))&#125;  </span><br><span class="line">idx2word = &#123;i: w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(sentence.split())))&#125;  </span><br><span class="line">  </span><br><span class="line">n_class = <span class="built_in">len</span>(word2idx)  </span><br><span class="line">max_len = <span class="built_in">len</span>(sentence.split())  </span><br><span class="line">  </span><br><span class="line">n_hidden = <span class="number">5</span></span><br></pre></td></tr></table></figure><blockquote><p>sentence<br />&gt; 'GitHub Actions makes it easy to automate all your software workflows from continuous integration and delivery to issue triage and more'<br />word2idx<br />&gt; {'issue': 0,'integration': 1,'from': 2,'workflows': 3,'and': 4,'continuous': 5,'your': 6,<br />&gt; 'software': 7,'GitHub': 8,'automate': 9,'easy': 10,'to': 11,'triage': 12, makes': 13,<br />&gt; 'Actions': 14,'more': 15,'all': 16,'it': 17,'delivery': 18}<br />idx2word<br />&gt; {0: 'issue', 1: 'integration', 2: 'from', 3: 'workflows', 4: 'and', 5: 'continuous', 6: 'your',<br />&gt; 7: 'software', 8: 'GitHub', 9: 'automate', 10: 'easy', 11: 'to', 12: 'triage', 13: 'makes',<br />&gt; 14: 'Actions', 15: 'more', 16: 'all', 17: 'it', 18: 'delivery'}<br />n_class<br />&gt; 19<br />max_len<br />&gt; 21</p></blockquote><h2 id="数据预处理">数据预处理</h2><p>定义 dataset，构建 dataloader。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_data</span>(<span class="params">sentence</span>):  </span><br><span class="line">    input_batch = []  </span><br><span class="line">    target_batch = []  </span><br><span class="line">  </span><br><span class="line">    words = sentence.split()  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_len-<span class="number">1</span>):  </span><br><span class="line">        <span class="built_in">input</span> = [word2idx[w] <span class="keyword">for</span> w <span class="keyword">in</span> words[:(i+<span class="number">1</span>)]]     <span class="comment"># (i+1)位置取不到  </span></span><br><span class="line">        <span class="built_in">input</span> = <span class="built_in">input</span> + [<span class="number">0</span>] * (max_len - <span class="built_in">len</span>(<span class="built_in">input</span>))     </span><br><span class="line">        input_batch.append(np.eye(n_class)[<span class="built_in">input</span>])  </span><br><span class="line">        target = word2idx[words[i+<span class="number">1</span>]]  </span><br><span class="line">        target_batch.append(target)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> torch.Tensor(input_batch), torch.LongTensor(target_batch)  </span><br><span class="line">  </span><br><span class="line">input_batch, target_batch = make_data(sentence)  </span><br><span class="line">dataset = Data.TensorDataset(input_batch, target_batch)  </span><br><span class="line">dataloader = Data.DataLoader(dataset, <span class="number">16</span> ,<span class="literal">True</span>)     <span class="comment"># 中间参数是batch_size</span></span><br></pre></td></tr></table></figure><p>注意这里 <code>n_class==19</code>，表示词向量字典的长度。</p><p>首先开始循环，<code>input</code> 的第一个赋值语句会将第一个词 "Github"对应的索引存起来。<code>input</code> 的第二个赋值语句会将剩下的 <code>max_len-len(input)</code> 都用 0 去填充。<br />第二次循环，<code>input</code> 的第一个赋值语句会将前两个词 "Github" 和 "Actions" 对应的索引存起来。<code>input</code> 的第二个赋值语句会将剩下的 <code>max_len-len(input)</code> 都用 0 去填充……</p><p>在本例中，<code>input_batch</code> 中的向量分别表示"GitHub"，"GitHub Actions", "GitHub Actions makes"……<code>target_batch</code> 中的向量分别表示"Actions"，"makes"，"it"……</p><p><code>np.eye(n_class)[input]</code> 表示构建一个 <code>len(input)*n_class</code> 的矩阵，<code>input</code> 表示在适当的位置填 1。</p><p>最终 <code>input_batch</code> 的维度是 <code>[max_len - 1, max_len, n_class]</code>。</p><h2 id="定义网络">定义网络</h2><p>Bi-LSTM 的网络结构图如下所示，其中 Backward Layer 意思不是 "反向传播"，而是 <strong>"将句子反向输入"</strong>。</p><p>具体流程就是，现有有由四个词构成的一句话 "i like your friends"。 - 常规单向 LSTM 的做法就是直接输入 "i like your"，然后预测出 "friends"。 - 双向 LSTM 会同时输入 "i like your" 和 "your like i"，然后将 Forward Layer 和 Backward Layer 的 <code>output</code> 进行 concat（这样做可以理解为同时 "汲取" 正向和反向的信息），最后预测出 "friends"。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303022237270.png" /></p><p>因为多了一个反向的输入，所以整个网络结构中很多隐藏层的输入和输出的某些维度会变为原来的两倍，具体如下图所示。对于双向 LSTM 来说：<code>num_directions = 2</code>。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303022245351.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BiLSTM</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">super</span>(BiLSTM, self).__init__()  </span><br><span class="line">        <span class="comment"># input_size表示每个词用input_size维的vector表示  </span></span><br><span class="line">        self.lstm = nn.LSTM(input_size=n_class, hidden_size=n_hidden, bidirectional=<span class="literal">True</span>)  </span><br><span class="line">        self.fc = nn.Linear(n_hidden * <span class="number">2</span>, n_class)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):  </span><br><span class="line">        <span class="comment"># X: [batch_size, max_len, n_class]  </span></span><br><span class="line">        batch_size = X.shape[<span class="number">0</span>]  </span><br><span class="line">        <span class="comment"># input: [max_len, batch_size, n_class]  </span></span><br><span class="line">        <span class="built_in">input</span> = X.transpose(<span class="number">0</span>,<span class="number">1</span>)  </span><br><span class="line">        <span class="comment"># [num_layers(=1) * num_directions(=2), batch_size, n_hidden]  </span></span><br><span class="line">        hidden_state = torch.randn(<span class="number">1</span>*<span class="number">2</span>, batch_size, n_hidden)  </span><br><span class="line">        <span class="comment"># [num_layers(=1) * num_directions(=2), batch_size, n_hidden]  </span></span><br><span class="line">        cell_state = torch.randn(<span class="number">1</span>*<span class="number">2</span>, batch_size, n_hidden)  </span><br><span class="line">  </span><br><span class="line">        outputs, (_,_) = self.lstm(<span class="built_in">input</span>, (hidden_state, cell_state))  </span><br><span class="line">        <span class="comment"># outputs: [batch_size, n_hidden * 2]  </span></span><br><span class="line">        outputs = outputs[-<span class="number">1</span>]  </span><br><span class="line">        <span class="comment"># model: [batch_size, n_class]  </span></span><br><span class="line">        model = self.fc(outputs)  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> model  </span><br><span class="line">  </span><br><span class="line">model = BiLSTM()  </span><br><span class="line">criterion = nn.CrossEntropyLoss()  </span><br><span class="line">optimizer = optim.Adam(modol.parameters(), lr=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><h2 id="训练">训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">epoch = <span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> dataloader:  </span><br><span class="line">        pred = model(x)  </span><br><span class="line">        loss = criterion(pred, y)  </span><br><span class="line">        <span class="keyword">if</span> (epoch + <span class="number">1</span>)% <span class="number">1000</span> == <span class="number">0</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Epoch:&#x27;</span>, <span class="string">&#x27;%04d&#x27;</span> % (epoch + <span class="number">1</span>), <span class="string">&#x27;cost =&#x27;</span>, <span class="string">&#x27;&#123;:.6f&#125;&#x27;</span>.<span class="built_in">format</span>(loss))  </span><br><span class="line">  </span><br><span class="line">        optimizer.zero_grad()  </span><br><span class="line">        loss.backward()  </span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predict = model(input_batch).data.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]  </span><br><span class="line"><span class="built_in">print</span>(sentence)  </span><br><span class="line"><span class="built_in">print</span>([idx2word[n.item()] <span class="keyword">for</span> n <span class="keyword">in</span> predict.squeeze()])</span><br></pre></td></tr></table></figure><blockquote><p>GitHub Actions makes it easy to automate all your software workflows from continuous integration and delivery to issue triage and more<br />['to', 'to', 'easy', 'to', 'to', 'to', 'to', 'your', 'software', 'workflows', 'from', 'continuous', 'integration', 'delivery', 'delivery', 'to', 'issue', 'triage', 'more', 'more']</p></blockquote><h1 id="相关链接">相关链接</h1><p><a href="https://wmathor.com/index.php/archives/1397/">LSTM - mathor</a><br /><a href="https://wmathor.com/index.php/archives/1399/">LSTM Example - mathor</a><br /><a href="https://wmathor.com/index.php/archives/1447/">BiLSTM的PyTorch应用 - mathor</a><br /><a href="https://www.bilibili.com/video/BV1tf4y117hA/?spm_id_from=333.999.0.0&amp;vd_source=ec8fb32942c22665057156952ef080c7">BiLSTM的PyTorch应用_哔哩哔哩_bilibili</a><br /><a href="https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html#torch.nn.LSTM">LSTM — PyTorch 1.13 documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch基础系列（4）</title>
      <link href="/2023/03/01/4-RNN%EF%BC%88TextRNN%EF%BC%89/"/>
      <url>/2023/03/01/4-RNN%EF%BC%88TextRNN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简介">简介</h1><ul><li>循环神经网络的输出取决于当下输入和前一时间的隐变量</li><li>应用到语言模型中时，循环神经网络根据当前词预测下一次时刻词</li><li>通常使用困惑度来衡量语言模型的好坏</li></ul><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303010851513.png" /></p><h1 id="torch-实现">torch 实现</h1><p>torch 给出了 rnn 的 api 接口定义</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303011033212.png" /></p><blockquote><p><strong><span class="math inline">\(x\)</span> 的维度为[seq_len, batch, input_size]</strong><br /><strong><span class="math inline">\(x_t\)</span> 的维度为[batch, input_size]</strong><br /><strong><span class="math inline">\(h_t\)</span> 的维度 为[batch, hidden_len]</strong></p></blockquote><p>这里假设为 x 的 shape 为[10, 3, 100]： - 10 表示 10 个单词 - 3 表示每次训练 3 句话 - 100 表示每个单词用 100 维的 tensor 表达</p><p>所以：<span class="math inline">\(x_t\)</span> 的 shape为[3, 100]。</p><p>假设 hidden_len（memory 的维度）为 20，所以每个 <span class="math inline">\(h_t\)</span> 的维度为[3, 20]。</p><p>根据公式下面给出代码：</p><p><span class="math display">\[h_t​=tanh(x_tW_{ih}^T​+b_{ih}​+h_{t−1}​W_{hh}^T​+b_{hh}​)\]</span></p><h1 id="复现">复现</h1><p>这里 <code>rnn = nn. RNN (100, 20)</code> ，指的是用一个长度为 100 的向量表示一个单词，hidden_size 为 20。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line">rnn = nn.RNN(<span class="number">100</span>,<span class="number">20</span>)     <span class="comment"># 定义input_size 和 hidden_size</span></span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(rnn._parameters.keys())  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(rnn.weight_ih_l0.shape)  </span><br><span class="line"><span class="built_in">print</span>(rnn.weight_hh_l0.shape)  </span><br><span class="line"><span class="built_in">print</span>(rnn.bias_ih_l0.shape)  </span><br><span class="line"><span class="built_in">print</span>(rnn.bias_hh_l0.shape)</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>odict_keys (['weight_ih_l0', 'weight_hh_l0', 'bias_ih_l0', 'bias_hh_l0'])<br />torch. Size ([20, 100])<br />torch. Size ([20, 20])<br />torch. Size ([20])<br />torch. Size ([20])</p></blockquote><p>对于 input 的定义：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303011044380.png" /></p><ul><li>必选参数 <code>input_size</code>，指定输入序列中单个样本的尺寸大小，例如可能用一个 100 长度的向量表示一个单词，则 <code>input_size=100</code></li><li>必选参数 <code>hidden_size</code>，指的是隐藏层中输出特征的大小，假设为 20</li><li>必选参数 <code>num_layers</code>，指的是纵向的隐藏层个数，一般设置为 1~10，default=1</li></ul><blockquote><p>如果 num_layers 为 1：<br /><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303011111409.png" /></p><p>如果 num_layers 为 2：<br /><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303011112254.png" /></p></blockquote><p><span class="math display">\[h_t​=tanh(x_tW_{ih}^T​+b_{ih}​+h_{t−1}​W_{hh}^T​+b_{hh}​)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  </span><br><span class="line">  </span><br><span class="line">rnn = nn.RNN(input_size=<span class="number">100</span>, hidden_size=<span class="number">20</span>, num_layers=<span class="number">1</span>)  </span><br><span class="line">x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">100</span>)  </span><br><span class="line">out, h_t = rnn(x, torch.zeros(<span class="number">1</span>, <span class="number">3</span>, <span class="number">20</span>))  </span><br><span class="line"><span class="built_in">print</span>(out.shape) </span><br><span class="line"><span class="built_in">print</span>(h_t.shape) </span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>torch. Size ([10, 3, 20])<br />torch. Size ([1, 3, 20])</p></blockquote><p>对于多层 RNN 堆叠：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  </span><br><span class="line">  </span><br><span class="line">rnn = nn.RNN(input_size=<span class="number">100</span>, hidden_size=<span class="number">20</span>, num_layers=<span class="number">4</span>)  </span><br><span class="line">x = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">100</span>)  </span><br><span class="line">out, h_t = rnn(x)  </span><br><span class="line"><span class="built_in">print</span>(out.shape)  </span><br><span class="line"><span class="built_in">print</span>(h_t.shape)</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>torch. Size ([10, 3, 20])<br />torch. Size ([4, 3, 20])</p></blockquote><h1 id="实战">实战</h1><p>问题背景：有 n 句话，每句话都由且仅由 3 个单词组成。我做的是，将每句话的前两个单词作为输入，最后一词作为输出，利用 pytorch 训练一个 TextRNN。</p><h2 id="导包">导包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn  </span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim  </span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data  </span><br><span class="line">  </span><br><span class="line">dtype = torch.FloatTensor</span><br></pre></td></tr></table></figure><h2 id="数据处理构建字典和索引">数据处理（构建字典和索引）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sentences = [<span class="string">&quot;i like dog&quot;</span>, <span class="string">&quot;i love coffee&quot;</span>, <span class="string">&quot;i hate milk&quot;</span>]  </span><br><span class="line">word_list = <span class="string">&quot; &quot;</span>.join(sentences).split()  </span><br><span class="line">vocab = <span class="built_in">list</span>(<span class="built_in">set</span>(word_list))  </span><br><span class="line">word2idx = &#123;w:i <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(vocab)&#125;  </span><br><span class="line">idx2word = &#123;i:w <span class="keyword">for</span> i, w <span class="keyword">in</span> <span class="built_in">enumerate</span>(vocab)&#125;  </span><br><span class="line">n_class = <span class="built_in">len</span>(vocab)</span><br></pre></td></tr></table></figure><blockquote><p>vocab<br />&gt; ['i', 'dog', 'like', 'milk', 'love', 'hate', 'coffee']<br />word2idx<br />&gt; {'i': 0, 'dog': 1, 'like': 2, 'milk': 3, 'love': 4, 'hate': 5, 'coffee': 6}<br />idx2word<br />&gt; {0: 'i', 1: 'dog', 2: 'like', 3: 'milk', 4: 'love', 5: 'hate', 6: 'coffee'}<br />n_class<br />&gt; 7</p></blockquote><h2 id="dataset-和-dataloader">DataSet 和 DataLoader</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">batch_size = <span class="number">2</span>  </span><br><span class="line">n_step = <span class="number">2</span>  </span><br><span class="line">n_hidden = <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_data</span>(<span class="params">sentences</span>):  </span><br><span class="line">    input_batch = []  </span><br><span class="line">    target_batch = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> sen <span class="keyword">in</span> sentences:  </span><br><span class="line">        word = sen.split()  </span><br><span class="line">        <span class="built_in">input</span> = [word2idx[n] <span class="keyword">for</span> n <span class="keyword">in</span> word[:-<span class="number">1</span>]]    <span class="comment"># 除了最后一个单词  </span></span><br><span class="line">        target = word2idx[word[-<span class="number">1</span>]]                 <span class="comment"># 最后一个单词当作预测值  </span></span><br><span class="line">        input_batch.append(np.eye(n_class)[<span class="built_in">input</span>])     </span><br><span class="line">        target_batch.append(target)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> input_batch, target_batch  </span><br><span class="line">  </span><br><span class="line">input_batch, target_batch = make_data(sentences)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># torch.FloatTensor是32位浮点类型数据，torch.LongTensor是64位整型  </span></span><br><span class="line">input_batch = torch.Tensor(input_batch)  </span><br><span class="line">target_batch = torch.LongTensor(target_batch)  </span><br><span class="line"></span><br><span class="line">dataset = Data.TensorDataset(input_batch, target_batch)  </span><br><span class="line">dataloader = Data.DataLoader(dataset, batch_size, <span class="literal">True</span>)  </span><br></pre></td></tr></table></figure><blockquote><p>list (dataset)<br />&gt; [(tensor ([[1., 0., 0., 0., 0., 0., 0.], [0., 0., 1., 0., 0., 0., 0.]]), tensor (1)),<br />&gt; (tensor ([[1., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 1., 0., 0.]]), tensor (6)),<br />&gt; (tensor ([[1., 0., 0., 0., 0., 0., 0.], [0., 0., 0., 0., 0., 1., 0.]]), tensor (3))]<br />list (dataloader)<br />&gt; [[tensor ([[[1., 0., 0., 0., 0., 0., 0.],[0., 0., 1., 0., 0., 0., 0.]],<br />&gt; [[1., 0., 0., 0., 0., 0., 0.],[0., 0., 0., 0., 1., 0., 0.]]]),<br />&gt; tensor ([1, 6])],<br />&gt; [tensor ([[[1., 0., 0., 0., 0., 0., 0.],[0., 0., 0., 0., 0., 1., 0.]]]),<br />&gt; tensor ([3])]]</p></blockquote><p>把函数核心部分进行分解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">input_batch = []  </span><br><span class="line">target_batch = []  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> sen <span class="keyword">in</span> sentences:  </span><br><span class="line">    word = sen.split()  </span><br><span class="line">    <span class="built_in">input</span> = [word2idx[n] <span class="keyword">for</span> n <span class="keyword">in</span> word[:-<span class="number">1</span>]]    <span class="comment"># 除了最后一个单词，返回的是id  </span></span><br><span class="line">    target = word2idx[word[-<span class="number">1</span>]]                 <span class="comment"># 最后一个单词当作预测值，返回的是id  </span></span><br><span class="line">    input_batch.append(np.eye(n_class)[<span class="built_in">input</span>])  </span><br><span class="line">    <span class="comment"># print(np.eye(n_class)[input])  </span></span><br><span class="line">    target_batch.append(target)  </span><br></pre></td></tr></table></figure><blockquote><p>input<br />&gt; [0, 2]<br />&gt; [0, 4]<br />&gt; [0, 5]<br />np. eye(n_class)[input]<br />&gt; [[1. 0. 0. 0. 0. 0. 0.]<br />&gt; [0. 0. 1. 0. 0. 0. 0.]]<br />&gt; [[1. 0. 0. 0. 0. 0. 0.]<br />&gt; [0. 0. 0. 0. 1. 0. 0.]]<br />&gt; [[1. 0. 0. 0. 0. 0. 0.]<br />&gt; [0. 0. 0. 0. 0. 1. 0.]]<br />input_batch<br />&gt; [array ([[1., 0., 0., 0., 0., 0., 0.],[0., 0., 1., 0., 0., 0., 0.]]),<br />&gt; array ([[1., 0., 0., 0., 0., 0., 0.],[0., 0., 0., 0., 1., 0., 0.]]),<br />&gt; array ([[1., 0., 0., 0., 0., 0., 0.],[0., 0., 0., 0., 0., 1., 0.]])]<br />target_batch<br />&gt; [1, 6, 3]</p></blockquote><h2 id="定义网络架构">定义网络架构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextRNN</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">super</span>(TextRNN, self).__init__()  </span><br><span class="line">        self.rnn = nn.RNN(input_size=n_class, hidden_size=n_hidden)  </span><br><span class="line">        self.fc = nn.Linear(n_hidden, n_class)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, hidden, X</span>):  </span><br><span class="line">        <span class="comment"># 最初：输入的X为[batch_size, n_step, n_class]  </span></span><br><span class="line">        X = X.transpose(<span class="number">0</span>,<span class="number">1</span>)     </span><br><span class="line">        <span class="comment"># np.transpose是替换轴，之后X变成变成 [n_step, batch_size, n_class] </span></span><br><span class="line">        out, hidden = self.rnn(X, hidden)  </span><br><span class="line">        out = out[-<span class="number">1</span>]  </span><br><span class="line">        model = self.fc(out)  </span><br><span class="line">        <span class="keyword">return</span> model  </span><br></pre></td></tr></table></figure><p>首先是 <code>nn.RNN(input_size, hidden_size)</code> 的两个参数： - <code>input_size</code> 表示每个词的编码维度，由于这里用的 one-hot 编码（不是 WordEmbedding），所以 <code>input_size</code> 就等于词库的大小 <code>len(vocab)</code>，即 <code>n_class</code>。 -  <code>hidden_size</code>，这个参数没有固定的要求，想将输入数据的维度转为多少维，就设定多少</p><p>因为对于一半神经网路而言，输入数据 X 的第一个维度都是 <code>batch_size</code>，但是 pytorch 的 <code>nn.RNN()</code> 要求将 <code>batch_size</code> 放在第二个维度上，所以代码中用 <code>X.transpose(0,1)</code> 将数据的第一个维度和第二个维度互换。</p><p>rnn 的输出：rnn 会返回两个结果，即代码中的 <code>out</code> 和 <code>hidden</code>。这里简单说就是，out 指的是下图的红框框起来的所有值；hidden 指的是下图蓝框框起来的所有值。我们需要的是最后时刻的最后一层输出，即 <span class="math inline">\(Y_3\)</span> 的值，所以使用 <code>out=out[-1]</code> 将其获取。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303012344138.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>定义好模型后，就是调用模型、定义优化器 optimizer。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = TextRNN()</span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><h2 id="训练">训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">epoch = <span class="number">5000</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> dataloader:  </span><br><span class="line">    <span class="comment"># hidden : [num_layers * num_directions, batch, hidden_size]  </span></span><br><span class="line">        hidden = torch.zeros(<span class="number">1</span>, x.shape[<span class="number">0</span>], n_hidden)     </span><br><span class="line">        pred = model(hidden, x)      <span class="comment"># X : [batch_size, n_step, n_class]  </span></span><br><span class="line">        loss = criterion(pred, y)  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># if (e + 1) % 1000 == 0:  </span></span><br><span class="line">        <span class="comment">#     print(&#x27;Epoch:&#x27;, &#x27;%04d&#x27; % (e + 1), &#x27;cost =&#x27;, &#x27;&#123;:.6f&#125;&#x27;.format(loss))  </span></span><br><span class="line">        </span><br><span class="line">        optimizer.zero_grad()  </span><br><span class="line">        loss.backward()  </span><br><span class="line">        optimizer.step()</span><br></pre></td></tr></table></figure><blockquote><p>Epoch: 1000 cost = 0.000000<br />Epoch: 1000 cost = 0.000000<br />Epoch: 2000 cost = 0.000000<br />Epoch: 2000 cost = 0.000000<br />Epoch: 3000 cost = 0.000000<br />Epoch: 3000 cost = 0.000000<br />Epoch: 4000 cost = 0.000000<br />Epoch: 4000 cost = 0.000000<br />Epoch: 5000 cost = 0.000000<br />Epoch: 5000 cost = 0.000000</p></blockquote><h2 id="预测">预测</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span> = [sen.split()[:<span class="number">2</span>] <span class="keyword">for</span> sen <span class="keyword">in</span> sentences]  </span><br><span class="line">hidden = torch.zeros(<span class="number">1</span>, <span class="built_in">len</span>(<span class="built_in">input</span>), n_hidden)  </span><br><span class="line">predict = model(hidden, input_batch).data.<span class="built_in">max</span>(<span class="number">1</span>, keepdim=<span class="literal">True</span>)[<span class="number">1</span>]  </span><br><span class="line"><span class="built_in">print</span>([sen.split()[:<span class="number">2</span>] <span class="keyword">for</span> sen <span class="keyword">in</span> sentences], <span class="string">&#x27;-&gt;&#x27;</span>, [idx2word[n.item()] <span class="keyword">for</span> n <span class="keyword">in</span> predict.squeeze()])</span><br></pre></td></tr></table></figure><blockquote><p>input<br />&gt; [['i', 'like'], ['i', 'love'], ['i', 'hate']]<br />hidden<br />&gt; tensor ([[[0., 0., 0., 0., 0.],<br />&gt; [0., 0., 0., 0., 0.],<br />&gt; [0., 0., 0., 0., 0.]]])<br />predict<br />&gt; tensor ([[2], [4], [1]])<br />输出：<br />&gt; [['i', 'like'], ['i', 'love'], ['i', 'hate']] -&gt; ['dog', 'coffee', 'milk']</p></blockquote><h1 id="其他">其他</h1><p>nn. RNNCell</p><h1 id="相关链接">相关链接</h1><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.RNN.html#torch.nn.RNN">RNN — PyTorch 1.13 documentation</a><br /><a href="https://wmathor.com/index.php/archives/1446/">TextRNN的PyTorch实现 - mathor</a><br /><a href="https://wmathor.com/index.php/archives/1392/">RNN Layer - mathor</a><br /><a href="https://blog.csdn.net/lwgkzl/article/details/88717678">pytorch中RNN参数的详细解释_pytorch rnn_lwgkzl的博客-CSDN博客</a><br /><a href="https://blog.csdn.net/SHU15121856/article/details/104387209">【PyTorch学习笔记】21：nn.RNN和nn.RNNCell的使用_LauZyHou的博客-CSDN博客</a><br /><a href="https://blog.csdn.net/m0_43455312/article/details/123270031">【Python学习】transpose函数_python transpose函数_isLauraL的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch基础系列（3）</title>
      <link href="/2023/02/28/3-%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86-%E6%9E%84%E5%BB%BAVocab/"/>
      <url>/2023/02/28/3-%E6%96%87%E6%9C%AC%E9%A2%84%E5%A4%84%E7%90%86-%E6%9E%84%E5%BB%BAVocab/</url>
      
        <content type="html"><![CDATA[<h1 id="导包">导包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections  </span><br><span class="line"><span class="keyword">import</span> re  </span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l  </span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h1 id="读取数据集">读取数据集</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">d2l.DATA_HUB[<span class="string">&#x27;time_machine&#x27;</span>] = (d2l.DATA_URL + <span class="string">&#x27;timemachine.txt&#x27;</span>,  </span><br><span class="line">                                <span class="string">&#x27;090b5e7e70c295757f55df93cb0a180b9691891a&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_time_machine</span>(): </span><br><span class="line">    <span class="string">&quot;&quot;&quot;将时间机器数据集加载到文本行的列表中&quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(d2l.download(<span class="string">&#x27;time_machine&#x27;</span>,cache_dir=os.path.join(<span class="string">&#x27;..&#x27;</span>,<span class="string">&#x27;pytorch&#x27;</span>,<span class="string">&#x27;data&#x27;</span>)), <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        lines = f.readlines()     <span class="comment"># lines是一个list，每一行占一个下标   </span></span><br><span class="line">    <span class="comment"># 将所有不是字母的都转为空格；再将首位空格删除，全部转为小写  </span></span><br><span class="line">    <span class="keyword">return</span> [re.sub(<span class="string">&#x27;[^A-Za-z]+&#x27;</span>, <span class="string">&#x27; &#x27;</span>, line).strip().lower() <span class="keyword">for</span> line <span class="keyword">in</span> lines]  </span><br><span class="line">  </span><br><span class="line">lines = read_time_machine()  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(lines[:<span class="number">10</span>])  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;# 文本总行数: <span class="subst">&#123;<span class="built_in">len</span>(lines)&#125;</span>&#x27;</span>)  </span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;the time machine by h g wells&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;i&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;the time traveller for so it will be convenient to speak of him&#x27;, &#x27;was expounding a recondite matter to us his grey eyes shone and&#x27;]</span><br><span class="line"></span><br><span class="line">文本总行数: 3221</span><br></pre></td></tr></table></figure><h1 id="词元化">词元化</h1><p>将文本行列表（<code>lines</code>）作为输入，列表中的每个元素是一个文本序列（如一条文本行）。<br />每个文本序列又被拆分成一个词元列表，<strong>词元（<code>token</code>）</strong> 是文本的基本单位。<br />最后，<strong>返回一个由词元列表组成的列表</strong>，其中的每个词元都是一个字符串（string）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize</span>(<span class="params">lines, token=<span class="string">&#x27;word&#x27;</span></span>):  </span><br><span class="line">    <span class="string">&quot;&quot;&quot;将文本行拆分为单词或字符词元&quot;&quot;&quot;</span>  </span><br><span class="line">    <span class="keyword">if</span> token == <span class="string">&#x27;word&#x27;</span>:  </span><br><span class="line">        <span class="keyword">return</span> [line.split() <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line != <span class="string">&quot;&quot;</span>]  </span><br><span class="line">    <span class="keyword">elif</span> token == <span class="string">&#x27;char&#x27;</span>:  </span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">list</span>(line) <span class="keyword">for</span> line <span class="keyword">in</span> lines]  </span><br><span class="line">    <span class="keyword">else</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;错误：未知词元类型：&#x27;</span> + token)  </span><br><span class="line"></span><br><span class="line">tokens = tokenize(lines)  </span><br><span class="line"><span class="built_in">print</span>(tokens[:<span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>实际上，本例子种只将每次词作为一个词元，所以 <code>token == 'char'</code> 是不会有的。因此，tokenize 在本例中可以简化为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">tokenize</span>(<span class="params">lines</span>):  </span><br><span class="line"><span class="keyword">return</span> [line.split() <span class="keyword">for</span> line <span class="keyword">in</span> lines <span class="keyword">if</span> line != <span class="string">&quot;&quot;</span>] </span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[[&#x27;the&#x27;, &#x27;time&#x27;, &#x27;machine&#x27;, &#x27;by&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;wells&#x27;], </span><br><span class="line">[&#x27;i&#x27;], </span><br><span class="line">[&#x27;the&#x27;, &#x27;time&#x27;, &#x27;traveller&#x27;, &#x27;for&#x27;, &#x27;so&#x27;, &#x27;it&#x27;, &#x27;will&#x27;, &#x27;be&#x27;, &#x27;convenient&#x27;, &#x27;to&#x27;, &#x27;speak&#x27;, &#x27;of&#x27;, &#x27;him&#x27;], </span><br><span class="line">[&#x27;was&#x27;, &#x27;expounding&#x27;, &#x27;a&#x27;, &#x27;recondite&#x27;, &#x27;matter&#x27;, &#x27;to&#x27;, &#x27;us&#x27;, &#x27;his&#x27;, &#x27;grey&#x27;, &#x27;eyes&#x27;, &#x27;shone&#x27;, &#x27;and&#x27;], </span><br><span class="line">[&#x27;twinkled&#x27;, &#x27;and&#x27;, &#x27;his&#x27;, &#x27;usually&#x27;, &#x27;pale&#x27;, &#x27;face&#x27;, &#x27;was&#x27;, &#x27;flushed&#x27;, &#x27;and&#x27;, &#x27;animated&#x27;, &#x27;the&#x27;], </span><br><span class="line">[&#x27;fire&#x27;, &#x27;burned&#x27;, &#x27;brightly&#x27;, &#x27;and&#x27;, &#x27;the&#x27;, &#x27;soft&#x27;, &#x27;radiance&#x27;, &#x27;of&#x27;, &#x27;the&#x27;, &#x27;incandescent&#x27;], </span><br><span class="line">[&#x27;lights&#x27;, &#x27;in&#x27;, &#x27;the&#x27;, &#x27;lilies&#x27;, &#x27;of&#x27;, &#x27;silver&#x27;, &#x27;caught&#x27;, &#x27;the&#x27;, &#x27;bubbles&#x27;, &#x27;that&#x27;, &#x27;flashed&#x27;, &#x27;and&#x27;], </span><br><span class="line">[&#x27;passed&#x27;, &#x27;in&#x27;, &#x27;our&#x27;, &#x27;glasses&#x27;, &#x27;our&#x27;, &#x27;chairs&#x27;, &#x27;being&#x27;, &#x27;his&#x27;, &#x27;patents&#x27;, &#x27;embraced&#x27;, &#x27;and&#x27;], </span><br><span class="line">[&#x27;caressed&#x27;, &#x27;us&#x27;, &#x27;rather&#x27;, &#x27;than&#x27;, &#x27;submitted&#x27;, &#x27;to&#x27;, &#x27;be&#x27;, &#x27;sat&#x27;, &#x27;upon&#x27;, &#x27;and&#x27;, &#x27;there&#x27;, &#x27;was&#x27;, &#x27;that&#x27;], </span><br><span class="line">[&#x27;luxurious&#x27;, &#x27;after&#x27;, &#x27;dinner&#x27;, &#x27;atmosphere&#x27;, &#x27;when&#x27;, &#x27;thought&#x27;, &#x27;roams&#x27;, &#x27;gracefully&#x27;]]</span><br></pre></td></tr></table></figure><h1 id="记录词频">记录词频</h1><blockquote><p><code>isinstance(A, B)</code> ：判断 A 是不是 B 类型的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_corpus</span>(<span class="params">tokens</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tokens) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">isinstance</span>(tokens[<span class="number">0</span>],<span class="built_in">list</span>):    </span><br><span class="line">        tokens = [token <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]  </span><br><span class="line">    <span class="keyword">return</span> collections.Counter(tokens)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># counter = count_corpus(tokens)  </span></span><br><span class="line"><span class="comment"># print(dict(counter))</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;the&#x27;: 2261, &#x27;time&#x27;: 200, &#x27;machine&#x27;: 85, &#x27;by&#x27;: 103, &#x27;h&#x27;: 1, &#x27;g&#x27;: 1, &#x27;wells&#x27;: 9, &#x27;i&#x27;: 1267, &#x27;traveller&#x27;: 61, &#x27;for&#x27;: 221, &#x27;so&#x27;: 112, &#x27;it&#x27;: 437, &#x27;will&#x27;: 37, &#x27;be&#x27;: 93, &#x27;convenient&#x27;: 5, &#x27;to&#x27;: 695, &#x27;speak&#x27;: 6, &#x27;of&#x27;: 1155, &#x27;him&#x27;: 40, &#x27;was&#x27;: 552, &#x27;expounding&#x27;: 2, &#x27;a&#x27;: 816, &#x27;recondite&#x27;: 1, &#x27;matter&#x27;: 6, &#x27;us&#x27;: 35, &#x27;his&#x27;: 129, &#x27;grey&#x27;: 11, &#x27;eyes&#x27;: 35, &#x27;shone&#x27;: 8, &#x27;and&#x27;: 1245, &#x27;twinkled&#x27;: 1, &#x27;usually&#x27;: 3, &#x27;pale&#x27;: 10, &#x27;face&#x27;: 38, &#x27;flushed&#x27;: 2, &#x27;animated&#x27;: 3, &#x27;fire&#x27;: 30, &#x27;burned&#x27;: 6, &#x27;brightly&#x27;: 4, &#x27;soft&#x27;: 16, &#x27;radiance&#x27;: 1, &#x27;incandescent&#x27;: 1, &#x27;lights&#x27;: 1, &#x27;in&#x27;: 541, &#x27;lilies&#x27;: 1, &#x27;silver&#x27;: 6, &#x27;caught&#x27;: 10, &#x27;bubbles&#x27;: 1, &#x27;that&#x27;: 443, &#x27;flashed&#x27;: 4, &#x27;passed&#x27;: 13, &#x27;our&#x27;: 57, &#x27;glasses&#x27;: 1, &#x27;chairs&#x27;: 2, &#x27;being&#x27;: 14, &#x27;patents&#x27;: 1, &#x27;embraced&#x27;: 1, &#x27;caressed&#x27;: 2, &#x27;rather&#x27;: 18, &#x27;than&#x27;: 34, &#x27;submitted&#x27;: 1, &#x27;sat&#x27;: 22, &#x27;upon&#x27;: 113, &#x27;there&#x27;: 127, &#x27;luxurious&#x27;: 1, &#x27;after&#x27;: 37, &#x27;dinner&#x27;: 13, &#x27;atmosphere&#x27;: 2, &#x27;when&#x27;: 55, &#x27;thought&#x27;: 57, &#x27;roams&#x27;: 1, &#x27;gracefully&#x27;: 1,……&#125;</span><br></pre></td></tr></table></figure><h1 id="构建词表">构建词表</h1><blockquote><p><code>tokens</code>：是一个嵌套 list，里面每个 list 表示一行，内部的 list 种是各种单词<br /><code>min_freq</code> ：表示最小出现次数，低于这个次数的单词就会被删除<br /><code>counter</code> ：记录着基于原文的词频统计信息 <code>_token_freqs</code> ：根据词频排序，返回字典，key 是单词 (token)，value 是次数<br /><code>idx_to_token</code> ：是一个 list，用来记录已经加进去的词频满足要求的词 <code>enumerate()</code> ：同时列出数据下标和数据，这里保存的是原文种所有单词再 idx_to_token 的下标</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vocab</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tokens=<span class="literal">None</span>, min_freq=<span class="number">0</span>, reserved_tokens=<span class="literal">None</span></span>):  </span><br><span class="line">        <span class="keyword">if</span> tokens <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            tokens = []  </span><br><span class="line">        <span class="keyword">if</span> reserved_tokens <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            reserved_tokens = []  </span><br><span class="line">        counter = count_corpus(tokens)   </span><br><span class="line">  </span><br><span class="line">        self._token_freqs = <span class="built_in">sorted</span>(counter.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)   </span><br><span class="line">        self.idx_to_token = [<span class="string">&#x27;&lt;unk&gt;&#x27;</span>] + reserved_tokens </span><br><span class="line">        self.token_to_idx = &#123;token: idx <span class="keyword">for</span> idx,token <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.idx_to_token)&#125;   </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> token, freq <span class="keyword">in</span> self._token_freqs:  </span><br><span class="line">        <span class="comment"># 因为已经排好序了，所以如果当前token的次数已经小于min_freq，那后面的一定会更小  </span></span><br><span class="line">            <span class="keyword">if</span> freq &lt; min_freq:  </span><br><span class="line">                <span class="keyword">break</span>     </span><br><span class="line">            <span class="comment"># 当前token词频足够，且没有加入token_to_idx </span></span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.token_to_idx:    </span><br><span class="line">                self.idx_to_token.append(token)  </span><br><span class="line">                self.token_to_idx[token] = <span class="built_in">len</span>(self.idx_to_token) - <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.idx_to_token)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, tokens</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tokens, (<span class="built_in">list</span>,<span class="built_in">tuple</span>)):     <span class="comment"># 如果不是长句  </span></span><br><span class="line">            <span class="keyword">return</span> self.token_to_idx.get(tokens,self.unk)  </span><br><span class="line">        <span class="keyword">return</span> [self.__getitem__(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_tokens</span>(<span class="params">self, indices</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(indices, (<span class="built_in">list</span>,<span class="built_in">tuple</span>)):  </span><br><span class="line">            <span class="keyword">return</span> self.idx_to_token[indices]  </span><br><span class="line">        <span class="keyword">return</span> [self.idx_to_token[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unk</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">token_freqs</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> self._token_freqs  </span><br></pre></td></tr></table></figure><p>下面是我照着自己的想法进行的一点修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vocab</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, tokens=<span class="literal">None</span>, min_freq=<span class="number">0</span>, reserved_tokens=<span class="literal">None</span></span>):  </span><br><span class="line">        <span class="keyword">if</span> tokens <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            tokens = []  </span><br><span class="line">        <span class="keyword">if</span> reserved_tokens <span class="keyword">is</span> <span class="literal">None</span>:  </span><br><span class="line">            reserved_tokens = []  </span><br><span class="line">        counter = count_corpus(tokens)  </span><br><span class="line">  </span><br><span class="line">        self._token_freqs = <span class="built_in">sorted</span>(counter.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        self.idx_to_token = [<span class="string">&#x27;&lt;unk&gt;&#x27;</span>] + reserved_tokens    </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> token, freq <span class="keyword">in</span> self._token_freqs:  </span><br><span class="line">        <span class="comment"># 因为已经排好序了，所以如果当前token的次数已经小于min_freq，那后面的一定会更小  </span></span><br><span class="line">            <span class="keyword">if</span> freq &lt; min_freq:  </span><br><span class="line">                <span class="keyword">break</span>     </span><br><span class="line">        <span class="comment"># 当前token词频足够，且没有加入token_to_idx</span></span><br><span class="line">            <span class="keyword">if</span> token <span class="keyword">not</span> <span class="keyword">in</span> self.idx_to_token:     </span><br><span class="line">                self.idx_to_token.append(token)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里统一生成token_to_idx</span></span><br><span class="line">        self.token_to_idx = &#123;token: idx <span class="keyword">for</span> idx,token <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.idx_to_token)&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.idx_to_token)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, tokens</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(tokens, (<span class="built_in">list</span>,<span class="built_in">tuple</span>)):     <span class="comment"># 如果不是长句  </span></span><br><span class="line">            <span class="keyword">return</span> self.token_to_idx.get(tokens,self.unk)  </span><br><span class="line">        <span class="keyword">return</span> [self.__getitem__(token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">to_tokens</span>(<span class="params">self, indices</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(indices, (<span class="built_in">list</span>,<span class="built_in">tuple</span>)):  </span><br><span class="line">            <span class="keyword">return</span> self.idx_to_token[indices]  </span><br><span class="line">        <span class="keyword">return</span> [self.idx_to_token[index] <span class="keyword">for</span> index <span class="keyword">in</span> indices]  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">unk</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @property  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">token_freqs</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> self._token_freqs</span><br></pre></td></tr></table></figure><h2 id="调用">调用</h2><blockquote><p><strong>注意：</strong> 要想查看 vocab 的内容，需要调用方法并转为 list，即 <code>list(vocab.token_to_idx.items())</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vocab = Vocab(tokens)   </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(vocab.token_to_idx.items()))</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(&#x27;&lt;unk&gt;&#x27;, 0), (&#x27;the&#x27;, 1), (&#x27;i&#x27;, 2), (&#x27;and&#x27;, 3), (&#x27;of&#x27;, 4), (&#x27;a&#x27;, 5), (&#x27;to&#x27;, 6), (&#x27;was&#x27;, 7), (&#x27;in&#x27;, 8), (&#x27;that&#x27;, 9), (&#x27;my&#x27;, 10), (&#x27;it&#x27;, 11), (&#x27;had&#x27;, 12), (&#x27;me&#x27;, 13), (&#x27;as&#x27;, 14), (&#x27;at&#x27;, 15), (&#x27;for&#x27;, 16), (&#x27;with&#x27;, 17), (&#x27;but&#x27;, 18), (&#x27;time&#x27;, 19), (&#x27;were&#x27;, 20), (&#x27;this&#x27;, 21), (&#x27;you&#x27;, 22), (&#x27;on&#x27;, 23), (&#x27;then&#x27;, 24), (&#x27;his&#x27;, 25), (&#x27;there&#x27;, 26), (&#x27;he&#x27;, 27), (&#x27;have&#x27;, 28), (&#x27;they&#x27;, 29), (&#x27;from&#x27;, 30), (&#x27;one&#x27;, 31), (&#x27;all&#x27;, 32), (&#x27;not&#x27;, 33), (&#x27;into&#x27;, 34), (&#x27;upon&#x27;, 35), (&#x27;little&#x27;, 36), (&#x27;so&#x27;, 37), (&#x27;is&#x27;, 38), (&#x27;came&#x27;, 39), (&#x27;by&#x27;, 40), (&#x27;some&#x27;, 41), (&#x27;be&#x27;, 42), (&#x27;no&#x27;, 43), (&#x27;could&#x27;, 44), (&#x27;their&#x27;, 45), (&#x27;said&#x27;, 46), (&#x27;saw&#x27;, 47), (&#x27;down&#x27;, 48), (&#x27;them&#x27;, 49), (&#x27;machine&#x27;, 50), (&#x27;which&#x27;, 51), (&#x27;very&#x27;, 52), (&#x27;or&#x27;, 53), (&#x27;an&#x27;, 54), (&#x27;we&#x27;, 55), (&#x27;now&#x27;, 56), (&#x27;what&#x27;, 57), (&#x27;been&#x27;, 58), (&#x27;these&#x27;, 59), (&#x27;like&#x27;, 60), (&#x27;her&#x27;, 61), (&#x27;out&#x27;, 62), (&#x27;seemed&#x27;, 63), (&#x27;up&#x27;, 64), (&#x27;man&#x27;, 65), (&#x27;about&#x27;, 66), (&#x27;s&#x27;, 67), (&#x27;its&#x27;, 68), (&#x27;thing&#x27;, 69), (&#x27;again&#x27;, 70), (&#x27;traveller&#x27;, 71), (&#x27;would&#x27;, 72), (&#x27;more&#x27;, 73), (&#x27;white&#x27;, 74), (&#x27;our&#x27;, 75), (&#x27;thought&#x27;, 76), (&#x27;felt&#x27;, 77), (&#x27;when&#x27;, 78), (&#x27;over&#x27;, 79), (&#x27;weena&#x27;, 80), (&#x27;still&#x27;, 81), (&#x27;world&#x27;, 82), (&#x27;myself&#x27;, 83), (&#x27;even&#x27;, 84), (&#x27;must&#x27;, 85), (&#x27;through&#x27;, 86), (&#x27;if&#x27;, 87),……]</span><br></pre></td></tr></table></figure><h2 id="转索引">转索引</h2><p>将每条文本行转为一个数字索引列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;文本：&#x27;</span>,tokens[i])  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;索引：&#x27;</span>,vocab[tokens[i]])</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x27;, &#x27;time&#x27;, &#x27;machine&#x27;, &#x27;by&#x27;, &#x27;h&#x27;, &#x27;g&#x27;, &#x27;wells&#x27;]</span><br><span class="line">索引： [1, 19, 50, 40, 2183, 2184, 400]</span><br><span class="line">文本： [&#x27;i&#x27;]</span><br><span class="line">索引： [2]</span><br><span class="line">文本： [&#x27;the&#x27;, &#x27;time&#x27;, &#x27;traveller&#x27;, &#x27;for&#x27;, &#x27;so&#x27;, &#x27;it&#x27;, &#x27;will&#x27;, &#x27;be&#x27;, &#x27;convenient&#x27;, &#x27;to&#x27;, &#x27;speak&#x27;, &#x27;of&#x27;, &#x27;him&#x27;]</span><br><span class="line">索引： [1, 19, 71, 16, 37, 11, 115, 42, 680, 6, 586, 4, 108]</span><br><span class="line">文本： [&#x27;was&#x27;, &#x27;expounding&#x27;, &#x27;a&#x27;, &#x27;recondite&#x27;, &#x27;matter&#x27;, &#x27;to&#x27;, &#x27;us&#x27;, &#x27;his&#x27;, &#x27;grey&#x27;, &#x27;eyes&#x27;, &#x27;shone&#x27;, &#x27;and&#x27;]</span><br><span class="line">索引： [7, 1420, 5, 2185, 587, 6, 126, 25, 330, 127, 439, 3]</span><br><span class="line">文本： [&#x27;twinkled&#x27;, &#x27;and&#x27;, &#x27;his&#x27;, &#x27;usually&#x27;, &#x27;pale&#x27;, &#x27;face&#x27;, &#x27;was&#x27;, &#x27;flushed&#x27;, &#x27;and&#x27;, &#x27;animated&#x27;, &#x27;the&#x27;]</span><br><span class="line">索引： [2186, 3, 25, 1044, 362, 113, 7, 1421, 3, 1045, 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="整合">整合</h1><p>将所有功能打包到<code>load_corpus_time_machine</code>函数中， 该函数返回<code>corpus</code>（词元索引列表）和<code>vocab</code>（时光机器语料库的词表）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">load_corpus_time_machine</span>(<span class="params">max_tokens=-<span class="number">1</span></span>):  </span><br><span class="line">    lines = read_time_machine()    <span class="comment"># 读取文件  </span></span><br><span class="line">    tokens = tokenize(lines,<span class="string">&#x27;word&#x27;</span>)     <span class="comment"># 将文章划分为单词  </span></span><br><span class="line">    <span class="comment"># print(tokens)  </span></span><br><span class="line">    vocab = Vocab(tokens)      <span class="comment"># 生成词典  </span></span><br><span class="line">    corpus = [vocab[token] <span class="keyword">for</span> line <span class="keyword">in</span> tokens <span class="keyword">for</span> token <span class="keyword">in</span> line]    <span class="comment"># line是一个list，里面存放一行的所有单词，token是每个单词，最后输出全文的所有单词的索引  </span></span><br><span class="line">    <span class="keyword">if</span> max_tokens &gt; <span class="number">0</span>:  </span><br><span class="line">        corpus = corpus[:max_tokens]  </span><br><span class="line">    <span class="keyword">return</span> corpus,vocab  </span><br><span class="line">  </span><br><span class="line">corpus,vocab = load_corpus_time_machine()  </span><br><span class="line"><span class="comment"># print(corpus)  </span></span><br><span class="line"><span class="comment"># print(vocab.token_to_idx.items())</span></span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://zh-v2.d2l.ai/chapter_recurrent-neural-networks/text-preprocessing.html">文本预处理-documentation</a><br /><a href="https://www.bilibili.com/video/BV1Fo4y1Q79L/?spm_id_from=333.999.0.0&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch基础系列（2）</title>
      <link href="/2023/02/28/2-%E6%B1%A0%E5%8C%96%E5%B1%82/"/>
      <url>/2023/02/28/2-%E6%B1%A0%E5%8C%96%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ul><li>池化层返回窗口中最大或者平均值</li><li>缓解卷积层对位置的敏感性</li><li>同样有窗口大小、填充、步幅作为超参数</li></ul><p>最大池化：每次输出窗口内最大值（不是求和了）</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302280955610.png" /></p><h1 id="复现">复现</h1><h2 id="导包">导包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br></pre></td></tr></table></figure><h2 id="构建">构建</h2><blockquote><p>start=0, end=16, step=1，返回一维张量，其值介于区间 [start, end]，步长为 step</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>))    </span><br><span class="line">X</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[[[ 0.,  1.,  2.,  3.],</span></span><br><span class="line"><span class="comment">#           [ 4.,  5.,  6.,  7.],</span></span><br><span class="line"><span class="comment">#           [ 8.,  9., 10., 11.],</span></span><br><span class="line"><span class="comment">#           [12., 13., 14., 15.]]]])</span></span><br></pre></td></tr></table></figure><blockquote><p>3 表示是 3*3 的窗口，pytorch 种步幅和窗口大小相同，即每个窗口之间没有重叠</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>)    </span><br><span class="line">pool2d(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[[[10.]]]])</span></span><br></pre></td></tr></table></figure><h3 id="自定义填充和步长">自定义填充和步长</h3><blockquote><p>padding=1 表示四周都填上一行（一列）, stride=2 表示步幅为 2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>, padding=<span class="number">1</span>, stride=<span class="number">2</span>)     </span><br><span class="line">pool2d(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[[[ 5.,  7.],</span></span><br><span class="line"><span class="comment">#          [13., 15.]]]])</span></span><br></pre></td></tr></table></figure><h3 id="自定义窗口大小和步长">自定义窗口大小和步长</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d((<span class="number">2</span>,<span class="number">3</span>),padding=(<span class="number">1</span>,<span class="number">1</span>),stride=(<span class="number">2</span>,<span class="number">3</span>))  </span><br><span class="line">pool2d(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[[[ 1.,  3.],</span></span><br><span class="line"><span class="comment">#          [ 9., 11.],</span></span><br><span class="line"><span class="comment">#          [13., 15.]]]])</span></span><br></pre></td></tr></table></figure><h3 id="多维度池化">多维度池化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">X = torch.arange(<span class="number">16</span>, dtype=torch.float32).reshape((<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>))  </span><br><span class="line">  </span><br><span class="line">X = torch.cat((X,X+<span class="number">1</span>),<span class="number">1</span>)      <span class="comment"># 1表示X和X+1横着拼  </span></span><br><span class="line">X</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[[[ 0.,  1.,  2.,  3.],</span></span><br><span class="line"><span class="comment">#          [ 4.,  5.,  6.,  7.],</span></span><br><span class="line"><span class="comment">#          [ 8.,  9., 10., 11.],</span></span><br><span class="line"><span class="comment">#          [12., 13., 14., 15.]],</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         [[ 1.,  2.,  3.,  4.],</span></span><br><span class="line"><span class="comment">#          [ 5.,  6.,  7.,  8.],</span></span><br><span class="line"><span class="comment">#          [ 9., 10., 11., 12.],</span></span><br><span class="line"><span class="comment">#          [13., 14., 15., 16.]]]])</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool2d = nn.MaxPool2d(<span class="number">3</span>,padding=<span class="number">1</span>,stride=<span class="number">2</span>)  </span><br><span class="line">pool2d(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor([[[[ 5.,  7.],</span></span><br><span class="line"><span class="comment">#          [13., 15.]],</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#         [[ 6.,  8.],</span></span><br><span class="line"><span class="comment">#          [14., 16.]]]])</span></span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1EV411j7nX/?spm_id_from=333.999.0.0&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch基础系列（1）</title>
      <link href="/2023/02/27/1-%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/02/27/1-%E6%9E%84%E5%BB%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>下面是来自 ChatGPT 关于 <code>nn. Sequential</code> 的介绍</p><blockquote><p><code>nn.Sequential</code> 是 PyTorch 深度学习库中的一个模块，它允许用户按照顺序将多个层堆叠在一起创建神经网络。<br />在顺序神经网络中，一层的输出作为下一层的输入，因此每一层都可以看作是上一层的输出和下一层的输入之间的一个连接。<br />使用 <code>nn.Sequential</code> 创建神经网络时，用户只需要将所需的层按照顺序传递给 <code>nn.Sequential</code> 即可创建一个神经网络。</p></blockquote><h1 id="导包">导包</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch  </span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn  </span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> functional <span class="keyword">as</span> F</span><br></pre></td></tr></table></figure><h1 id="定义类">定义类</h1><blockquote><p><code>X = torch. rand (2, 20)</code> 这行代码会生成一个大小为 2x20 的张量，其中包含了 40 个在区间 [0, 1) 内均匀分布的随机数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">20</span>,<span class="number">256</span>), nn.ReLU(), nn.Linear(<span class="number">256</span>,<span class="number">10</span>))  </span><br><span class="line">X = torch.rand(<span class="number">2</span>,<span class="number">20</span>)     <span class="comment"># 输入  </span></span><br><span class="line">net(X)   <span class="comment"># 输出</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.0574,  0.3315,  0.1166,  0.0199,  0.3483, -0.1876, -0.1673,  0.0476,</span><br><span class="line">         -0.1516, -0.1820],</span><br><span class="line">        [-0.1105,  0.1474,  0.0903, -0.0106,  0.4121, -0.1440, -0.1650,  0.0741,</span><br><span class="line">         -0.1555, -0.1497]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h2 id="自定义-module">自定义 Module</h2><blockquote><p><strong><code>nn. Module</code> 里面定义的 <code>__call__</code> 方法会调用 <code>forward</code> 方法</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMLP</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        self.hidden = nn.Linear(<span class="number">20</span>,<span class="number">256</span>)  </span><br><span class="line">        self.out = nn.Linear(<span class="number">256</span>,<span class="number">10</span>)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.out(F.relu((self.hidden(X))))      <span class="comment"># 将三个层链接起来  </span></span><br><span class="line">  </span><br><span class="line">net = MyMLP()  </span><br><span class="line">X = torch.rand(<span class="number">2</span>,<span class="number">20</span>)  </span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[-0.1130, -0.2605, -0.0028, -0.1315,  0.2831, -0.0219, -0.1388, -0.3198,</span><br><span class="line">          0.0520,  0.1621],</span><br><span class="line">        [-0.1664, -0.2344, -0.0618, -0.1139,  0.2405,  0.1695, -0.1188, -0.3584,</span><br><span class="line">          0.0692,  0.0633]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h2 id="自定义-sequential">自定义 Sequential</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySequential</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,*args</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> args:  </span><br><span class="line">            <span class="built_in">print</span>(block)  </span><br><span class="line">            self._modules[block] = block  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,X</span>):  </span><br><span class="line">        <span class="keyword">for</span> block <span class="keyword">in</span> self._modules.values():  </span><br><span class="line">            X = block(X)  </span><br><span class="line">        <span class="keyword">return</span> X  </span><br><span class="line">  </span><br><span class="line">net = MySequential(nn.Linear(<span class="number">20</span>,<span class="number">256</span>),nn.ReLU(),nn.Linear(<span class="number">256</span>,<span class="number">10</span>))  </span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Linear(in_features=20, out_features=256, bias=True)</span><br><span class="line">ReLU()</span><br><span class="line">Linear(in_features=256, out_features=10, bias=True)</span><br><span class="line"></span><br><span class="line">tensor([[ 0.1493, -0.0089,  0.2427, -0.0798,  0.0935,  0.0015,  0.1714,  0.1016,</span><br><span class="line">         -0.2196, -0.0520],</span><br><span class="line">        [ 0.0919, -0.0402,  0.1483, -0.0247, -0.0209,  0.0968,  0.0856,  0.1403,</span><br><span class="line">         -0.2901, -0.1206]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h2 id="自定义嵌套网络">自定义嵌套网络</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestMLP</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        self.net = nn.Sequential(nn.Linear(<span class="number">20</span>,<span class="number">64</span>),nn.ReLU(),  </span><br><span class="line">                                 nn.Linear(<span class="number">64</span>,<span class="number">32</span>),nn.ReLU())  </span><br><span class="line">        self.linear = nn.Linear(<span class="number">32</span>,<span class="number">16</span>)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,X</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.linear(self.net(X))  </span><br><span class="line">  </span><br><span class="line">chimera = nn.Sequential(NestMLP(),nn.Linear(<span class="number">16</span>,<span class="number">20</span>),MyMLP())  </span><br><span class="line">X = torch.rand(<span class="number">2</span>,<span class="number">20</span>)  </span><br><span class="line">chimera(X)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tensor([[ 0.0210,  0.1105,  0.0292,  0.0055, -0.1473, -0.1418,  0.0247, -0.0770,</span><br><span class="line">          0.0096, -0.0914],</span><br><span class="line">        [ 0.0166,  0.1126,  0.0327, -0.0024, -0.1452, -0.1435,  0.0254, -0.0761,</span><br><span class="line">          0.0077, -0.0984]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h1 id="参数管理">参数管理</h1><h2 id="具有单隐藏层的多层感知机">具有单隐藏层的多层感知机</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>,<span class="number">1</span>))  </span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>,<span class="number">4</span>))  </span><br><span class="line">net(X)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.0310],</span><br><span class="line">        [0.0198]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h3 id="查看某一层状态">查看某一层状态</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].state_dict())  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(net[<span class="number">2</span>].bias))        </span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias)                      <span class="comment"># .bias表示偏移</span></span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].bias.data)</span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.grad==<span class="literal">None</span>)         <span class="comment"># .grad表示访问梯度</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([(&#x27;weight&#x27;, tensor([[-0.0261, -0.2381,  0.2371,  0.3306,  0.0700,  0.2761, -0.1394,  0.1811]])), (&#x27;bias&#x27;, tensor([0.0377]))])</span><br><span class="line"></span><br><span class="line">&lt;class &#x27;torch.nn.parameter.Parameter&#x27;&gt;</span><br><span class="line"></span><br><span class="line">Parameter containing:</span><br><span class="line">tensor([0.0377], requires_grad=True)</span><br><span class="line"></span><br><span class="line">tensor([0.0377])</span><br><span class="line"></span><br><span class="line">True</span><br></pre></td></tr></table></figure><blockquote><p>Parameter 表示定义的是一个可以优化的参数</p></blockquote><h3 id="一次性访问所有参数">一次性访问所有参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># * 表示解压缩</span></span><br><span class="line"><span class="built_in">print</span>(*[(name,param.shape)<span class="keyword">for</span> name,param <span class="keyword">in</span> net[<span class="number">0</span>].named_parameters()])  </span><br><span class="line"><span class="built_in">print</span>(*[(name, param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> net.named_parameters()])  </span><br><span class="line"><span class="built_in">print</span>(net.state_dict()[<span class="string">&#x27;2.bias&#x27;</span>].data)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&#x27;weight&#x27;, torch.Size([8, 4])) (&#x27;bias&#x27;, torch.Size([8]))</span><br><span class="line"></span><br><span class="line">(&#x27;0.weight&#x27;, torch.Size([8, 4])) (&#x27;0.bias&#x27;, torch.Size([8])) (&#x27;2.weight&#x27;, torch.Size([1, 8])) (&#x27;2.bias&#x27;, torch.Size([1]))</span><br><span class="line"></span><br><span class="line">tensor([0.0377])</span><br></pre></td></tr></table></figure><blockquote><p>返回的是 parameters（可优化参数），但 1 是 ReLU，是没有参数的，所以只会输出 0、2 两个全连接层 Linear。</p></blockquote><h2 id="从嵌套块收集参数">从嵌套块收集参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">block1</span>():  </span><br><span class="line">    <span class="keyword">return</span> nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>,<span class="number">4</span>), nn.ReLU())  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">block2</span>():  </span><br><span class="line">    net = nn.Sequential()  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  </span><br><span class="line">        net.add_module(<span class="string">f&#x27;block <span class="subst">&#123;i&#125;</span>&#x27;</span>,block1())  </span><br><span class="line">    <span class="keyword">return</span> net  </span><br><span class="line">  </span><br><span class="line">rgnet = nn.Sequential(block2(), nn.Linear(<span class="number">4</span>,<span class="number">1</span>))  </span><br><span class="line">rgnet(X)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.1841],</span><br><span class="line">        [0.1841]], grad_fn=&lt;AddmmBackward&gt;)</span><br></pre></td></tr></table></figure><h3 id="查看整个网络">查看整个网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(rgnet)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Sequential(</span><br><span class="line">  (0): Sequential(</span><br><span class="line">    (block 0): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 1): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 2): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">    (block 3): Sequential(</span><br><span class="line">      (0): Linear(in_features=4, out_features=8, bias=True)</span><br><span class="line">      (1): ReLU()</span><br><span class="line">      (2): Linear(in_features=8, out_features=4, bias=True)</span><br><span class="line">      (3): ReLU()</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  (1): Linear(in_features=4, out_features=1, bias=True)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="初始化-module">初始化 module</h2><blockquote><p>传入的 <code>m</code> 表示是一个 <code>module</code><br /><code>_</code>表示无需返回值，直接原地替换。</p></blockquote><h3 id="例-1">例 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_normal</span>(<span class="params">m</span>):    </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:     <span class="comment"># 如果是线性层  </span></span><br><span class="line">        nn.init.normal_(m.weight, mean=<span class="number">0</span>, std=<span class="number">0.01</span>)   <span class="comment"># 这里将weight变成均值为0，标准差为0.01  </span></span><br><span class="line">        nn.init.zeros_(m.bias)    <span class="comment"># 将bias偏移替换为0  </span></span><br><span class="line">  </span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>,<span class="number">1</span>))  </span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>,<span class="number">4</span>))  </span><br><span class="line">net(X)  </span><br><span class="line"></span><br><span class="line">net.apply(init_normal)      <span class="comment"># 将网络遍历一遍，用init_normal进行更新  </span></span><br><span class="line">net[<span class="number">0</span>].weight.data[<span class="number">0</span>], net[<span class="number">0</span>].bias.data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([-0.0028, -0.0195,  0.0069, -0.0052]), tensor(0.))</span><br></pre></td></tr></table></figure><h3 id="例-2">例 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_constant</span>(<span class="params">m</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:  </span><br><span class="line">        nn.init.constant_(m.weight, <span class="number">1</span>)  </span><br><span class="line">        nn.init.zeros_(m.bias)  </span><br><span class="line">  </span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>,<span class="number">1</span>))  </span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>,<span class="number">4</span>))  </span><br><span class="line">net(X)  </span><br><span class="line">  </span><br><span class="line">net.apply(init_constant)  </span><br><span class="line">net[<span class="number">0</span>].weight.data[<span class="number">0</span>], net[<span class="number">0</span>].bias.data[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([1., 1., 1., 1.]), tensor(0.))</span><br></pre></td></tr></table></figure><h3 id="对不同层做不同初始化">对不同层做不同初始化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xavier</span>(<span class="params">m</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:  </span><br><span class="line">        nn.init.xavier_uniform_(m.weight)      <span class="comment"># 对weight做xavier均值化  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_42</span>(<span class="params">m</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:  </span><br><span class="line">        nn.init.constant_(m.weight, <span class="number">42</span>)        <span class="comment"># 全部赋值42  </span></span><br><span class="line"></span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>,<span class="number">1</span>))  </span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>,<span class="number">4</span>))  </span><br><span class="line">net(X)</span><br><span class="line"></span><br><span class="line">net[<span class="number">0</span>].apply(xavier)  </span><br><span class="line">net[<span class="number">2</span>].apply(init_42)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">0</span>].weight.data[<span class="number">0</span>])  </span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.data)</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([ 0.0871, -0.1821, -0.5227, -0.4939])</span><br><span class="line">tensor([[42., 42., 42., 42., 42., 42., 42., 42.]])</span><br></pre></td></tr></table></figure><h2 id="自定义初始化">自定义初始化</h2><blockquote><p><code>m.weight.data *= m.weight.data.abs()&gt;=5</code> 表示如果 <code>m.weight.data.abs() &gt;= 5</code> 成立，相当于乘以 1；不成立相当于乘以 0 。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_init</span>(<span class="params">m</span>):  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(m) == nn.Linear:  </span><br><span class="line">        <span class="built_in">print</span>(  </span><br><span class="line">            <span class="string">&quot;Init&quot;</span>,  </span><br><span class="line">            *[(name,param.shape) <span class="keyword">for</span> name, param <span class="keyword">in</span> m.named_parameters()][<span class="number">0</span>]  </span><br><span class="line">        )  </span><br><span class="line">        nn.init.uniform_(m.weight, -<span class="number">10</span>, <span class="number">10</span>)      <span class="comment"># (-10,10)之间的均匀分布填充  </span></span><br><span class="line">        m.weight.data *= m.weight.data.<span class="built_in">abs</span>()&gt;=<span class="number">5</span>     </span><br><span class="line">  </span><br><span class="line">net = nn.Sequential(nn.Linear(<span class="number">4</span>,<span class="number">8</span>), nn.ReLU(), nn.Linear(<span class="number">8</span>,<span class="number">1</span>))  </span><br><span class="line">X = torch.rand(size=(<span class="number">2</span>,<span class="number">4</span>))  </span><br><span class="line">net(X)  </span><br><span class="line">  </span><br><span class="line">net.apply(my_init)  </span><br><span class="line">net[<span class="number">0</span>].weight[:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Init weight torch.Size([8, 4])</span><br><span class="line">Init weight torch.Size([1, 8])</span><br><span class="line"></span><br><span class="line">tensor([[0.0000, 0.0000, 7.5092, -0.0000],</span><br><span class="line">        [0.0000, 5.3086, 7.6778, 0.0000]], grad_fn=&lt;SliceBackward&gt;)</span><br></pre></td></tr></table></figure><h3 id="直接操作">直接操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net[<span class="number">0</span>].weight.data[:] += <span class="number">1</span>     <span class="comment"># 所有值+1  </span></span><br><span class="line">net[<span class="number">0</span>].weight.data[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">42</span>     <span class="comment"># 第一行的第一个元素为42  </span></span><br><span class="line">net[<span class="number">0</span>].weight.data[<span class="number">0</span>]      <span class="comment"># 第一行元素</span></span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([42.0000,  1.0000,  8.5092,  1.0000])</span><br></pre></td></tr></table></figure><h2 id="参数绑定">参数绑定</h2><blockquote><p>下面的例子可以看出，第二层和第四层都指向 shared，这相当于指向同一个内存空间，所以第二层和第四层会同时变化，永远一样。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">shared = nn.Linear(<span class="number">8</span>,<span class="number">8</span>)  </span><br><span class="line">net = nn.Sequential(  </span><br><span class="line">    nn.Linear(<span class="number">4</span>,<span class="number">8</span>),nn.ReLU(),shared,nn.ReLU(),shared,nn.ReLU(),nn.Linear(<span class="number">8</span>,<span class="number">1</span>)  </span><br><span class="line">)  </span><br><span class="line">net(X)  </span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.data[<span class="number">0</span>] == net[<span class="number">4</span>].weight.data[<span class="number">0</span>])  </span><br><span class="line">  </span><br><span class="line">net[<span class="number">2</span>].weight.data[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">100</span>  </span><br><span class="line"><span class="built_in">print</span>(net[<span class="number">2</span>].weight.data[<span class="number">0</span>] == net[<span class="number">4</span>].weight.data[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([True, True, True, True, True, True, True, True])</span><br><span class="line">tensor([True, True, True, True, True, True, True, True])</span><br></pre></td></tr></table></figure><h1 id="自定义层">自定义层</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CenteredLayer</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):  </span><br><span class="line">        <span class="keyword">return</span> X - X.mean()  </span><br><span class="line">  </span><br><span class="line">layer = CenteredLayer()  </span><br><span class="line">layer(torch.FloatTensor([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([-2., -1.,  0.,  1.,  2.])</span><br></pre></td></tr></table></figure><h2 id="利用自定义层构建-module">利用自定义层构建 Module</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(nn.Linear(<span class="number">8</span>,<span class="number">128</span>), CenteredLayer())  </span><br><span class="line">  </span><br><span class="line">Y = net(torch.rand(<span class="number">4</span>,<span class="number">8</span>))  </span><br><span class="line">Y.mean()</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor(7.4506e-09, grad_fn=&lt;MeanBackward0&gt;)</span><br></pre></td></tr></table></figure><h2 id="自定义带参数的层">自定义带参数的层</h2><blockquote><p><code>torch.randn(in_units,units)</code> 表示均值为 0，方差为 1 的正态分布，模型形状为 in_units*units</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinear</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, in_units, units</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        self.weight = nn.Parameter(torch.randn(in_units,units))  </span><br><span class="line">        self.bias = nn.Parameter(torch.zeros(units))  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,X</span>):  </span><br><span class="line">        linear = torch.matmul(X, self.weight.data) + self.bias.data  </span><br><span class="line">        <span class="keyword">return</span> F.relu(linear)  </span><br><span class="line">  </span><br><span class="line">dense = MyLinear(<span class="number">5</span>,<span class="number">3</span>)  </span><br><span class="line">dense.weight</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parameter containing:</span><br><span class="line">tensor([[-1.4344,  0.5694, -0.6562],</span><br><span class="line">        [ 0.8137,  0.1474, -1.5661],</span><br><span class="line">        [-0.4021,  0.6279,  0.7612],</span><br><span class="line">        [-0.3380, -1.6948,  0.6764],</span><br><span class="line">        [-0.6898,  0.9873,  1.0886]], requires_grad=True)</span><br></pre></td></tr></table></figure><h3 id="直接执行正向传播计算">直接执行正向传播计算</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dense(torch.rand(<span class="number">2</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.2325, 0.0000, 0.0000],</span><br><span class="line">        [0.0000, 0.5239, 0.9386]])</span><br></pre></td></tr></table></figure><h3 id="直接构建module">直接构建Module</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(MyLinear(<span class="number">64</span>,<span class="number">8</span>), MyLinear(<span class="number">8</span>,<span class="number">1</span>))  </span><br><span class="line">net(torch.rand(<span class="number">2</span>,<span class="number">64</span>))</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tensor([[0.],</span><br><span class="line">        [0.]])</span><br></pre></td></tr></table></figure><h1 id="读写文件">读写文件</h1><blockquote><p>训练好的东西如何存储下来？</p></blockquote><h2 id="简单存储">简单存储</h2><blockquote><p><code>torch.save()</code> 存储文件；<code>torch.load()</code> 读取文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = torch.arange(<span class="number">4</span>)  </span><br><span class="line">torch.save(x, <span class="string">&#x27;x-file&#x27;</span>)      <span class="comment"># 保存数据到文件  </span></span><br><span class="line">  </span><br><span class="line">x2 = torch.load(<span class="string">&quot;x-file&quot;</span>)    <span class="comment"># 从文件读取数据  </span></span><br><span class="line">x2</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensor([0, 1, 2, 3])</span><br></pre></td></tr></table></figure><h3 id="存一个张量列表再读回内存">存一个张量列表，再读回内存</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y = torch.zeros(<span class="number">4</span>)  </span><br><span class="line">torch.save([x,y], <span class="string">&#x27;x-files&#x27;</span>)  </span><br><span class="line">x2, y2 = torch.load(<span class="string">&#x27;x-files&#x27;</span>)  </span><br><span class="line">(x2, y2)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(tensor([0, 1, 2, 3]), tensor([0., 0., 0., 0.]))</span><br></pre></td></tr></table></figure><h3 id="写入或读取字符串映射到张量的字典">写入或读取字符串映射到张量的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mydict = &#123;<span class="string">&#x27;x&#x27;</span>: x, <span class="string">&#x27;y&#x27;</span>: y&#125;  </span><br><span class="line">torch.save(mydict, <span class="string">&#x27;mydict&#x27;</span>)  </span><br><span class="line">mydict2 = torch.load(<span class="string">&#x27;mydict&#x27;</span>)  </span><br><span class="line">mydict2</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;x&#x27;: tensor([0, 1, 2, 3]), &#x27;y&#x27;: tensor([0., 0., 0., 0.])&#125;</span><br></pre></td></tr></table></figure><h2 id="加载和保存模型参数">加载和保存模型参数</h2><h3 id="存储">存储</h3><blockquote><p>只保存权重，不保存计算部分</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMLP</span>(nn.Module):  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="built_in">super</span>().__init__()  </span><br><span class="line">        self.hidden = nn.Linear(<span class="number">20</span>,<span class="number">256</span>)  </span><br><span class="line">        self.output = nn.Linear(<span class="number">256</span>,<span class="number">10</span>)  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, X</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.output(F.relu((self.hidden(X))))      <span class="comment"># 将三个层链接起来  </span></span><br><span class="line">  </span><br><span class="line">net = MyMLP()  </span><br><span class="line">X = torch.randn(size=(<span class="number">2</span>,<span class="number">20</span>))  </span><br><span class="line">Y = net(X)  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(net.state_dict())  </span><br><span class="line"></span><br><span class="line">torch.save(net.state_dict(),<span class="string">&#x27;mlp.params&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">OrderedDict([</span><br><span class="line">(&#x27;hidden.weight&#x27;, tensor([</span><br><span class="line">[ 0.0971, -0.1579,  0.0044,  ..., -0.0998,  0.0737, -0.1686],</span><br><span class="line">        [ 0.0530,  0.0414,  0.1216,  ...,  0.1181, -0.0419,  0.2201],</span><br><span class="line">        [-0.1028, -0.1758, -0.1662,  ..., -0.0928,  0.1294,  0.0587],</span><br><span class="line">        ...,</span><br><span class="line">        [-0.1926, -0.1774,  0.2134,  ..., -0.2065, -0.1961, -0.0740],</span><br><span class="line">        [ 0.1167,  0.1235,  0.0281,  ..., -0.2233, -0.1973,  0.2134],</span><br><span class="line">        [ 0.1455,  0.0599,  0.1002,  ...,  0.0954, -0.1207, -0.1105]])), </span><br><span class="line">        (&#x27;hidden.bias&#x27;, tensor([</span><br><span class="line">        -0.0302, -0.0348,  0.0281,  0.0997, -0.0086,  0.1300,  0.0476, -0.2219,</span><br><span class="line">         0.1233,  0.0026, -0.0673,  0.0856, -0.1732,  0.1215, -0.1404, -0.1227,</span><br><span class="line">         0.2165,  0.1321, -0.0280,  0.0206, -0.0785, -0.2105, -0.0730,  0.1728,</span><br><span class="line">         0.0761,  0.1807,  0.1850,  0.1304,  0.1791, -0.1322, -0.1459, -0.2088,</span><br><span class="line">         0.1379,  0.0745, -0.1551,  0.1028, -0.0318, -0.0190,  0.0452, -0.1210,</span><br><span class="line">        -0.1974,  0.0848, -0.1211, -0.0029, -0.0758, -0.1973, -0.1604,  0.1820,</span><br><span class="line">         0.1789,  0.0604,  0.2105,  0.1426, -0.2211,  0.0429, -0.0488, -0.0870,</span><br><span class="line">         0.0529, -0.1741, -0.1400,  0.0548, -0.1349,  0.0981,  0.2169, -0.0210,</span><br><span class="line">        -0.1844,  0.0077,  0.0834,  0.2054, -0.2228, -0.0648,  0.0173,  0.0247,</span><br><span class="line">        -0.1176,  0.1128,  0.1654, -0.0504,  0.1098,  0.1063, -0.0364, -0.1849,</span><br><span class="line">        -0.1402,  0.1194, -0.0215, -0.0185, -0.2194,  0.0617, -0.1944,  0.1957,</span><br><span class="line">        -0.0532,  0.1535,  0.2023, -0.1782,  0.2102, -0.1350,  0.0877, -0.0950,</span><br><span class="line">        -0.1563, -0.0329,  0.0251,  0.0778,  0.1942, -0.1021,  0.0153,  0.1390,</span><br><span class="line">         0.1445,  0.0628,  0.0339,  0.2018, -0.0993,  0.0693, -0.2129,  0.0332,</span><br><span class="line">        -0.0043,  0.0372, -0.0691,  0.2017, -0.0454, -0.0628, -0.1467,  0.0851,</span><br><span class="line">         0.1321, -0.2065, -0.0110,  0.0214, -0.0256,  0.1904,  0.0079, -0.0249,</span><br><span class="line">        -0.1835, -0.1258, -0.0364,  0.0382,  0.0364,  0.0556,  0.0968, -0.0379,</span><br><span class="line">        -0.0573, -0.0327,  0.2173, -0.1410,  0.0369, -0.0393,  0.0957, -0.0846,</span><br><span class="line">         0.1420, -0.0529,  0.0196, -0.1414,  0.0247,  0.0764, -0.0029,  0.1371,</span><br><span class="line">         0.0078,  0.0094,  0.1526, -0.0658, -0.1047, -0.0852,  0.1926,  0.1918,</span><br><span class="line">         0.1632, -0.0534,  0.0203,  0.1192,  0.0354, -0.1002,  0.2012, -0.1022,</span><br><span class="line">         0.1445,  0.1265,  0.1041,  0.0924, -0.0209,  0.0056, -0.1787,  0.0652,</span><br><span class="line">        -0.1389, -0.0571, -0.1906, -0.2193, -0.0129,  0.0469, -0.0718,  0.2137,</span><br><span class="line">        -0.0676,  0.2137, -0.0784, -0.0154,  0.0074, -0.0139,  0.2043,  0.1941,</span><br><span class="line">        -0.0824,  0.0544, -0.2138, -0.0478, -0.1863, -0.2089,  0.1727,  0.0725,</span><br><span class="line">         0.0170,  0.2099, -0.2147, -0.2158, -0.1833, -0.1895, -0.1178, -0.0157,</span><br><span class="line">        -0.1715, -0.0400,  0.0310, -0.2036, -0.1314,  0.1275,  0.0224, -0.1556,</span><br><span class="line">        -0.0607, -0.0977,  0.0341, -0.0254, -0.1512,  0.1797, -0.0274, -0.0814,</span><br><span class="line">        -0.1371,  0.0022, -0.1917, -0.1770,  0.0264,  0.0580,  0.0983,  0.0687,</span><br><span class="line">         0.0243,  0.1223,  0.1731, -0.0675,  0.0962,  0.1003, -0.1203,  0.2133,</span><br><span class="line">        -0.2032,  0.0220, -0.0204,  0.0468, -0.1539,  0.0375,  0.0204, -0.0473,</span><br><span class="line">        -0.0527,  0.0048, -0.1396, -0.0565,  0.0003,  0.0638, -0.0141, -0.1569])),</span><br><span class="line">        (&#x27;output.weight&#x27;, tensor([</span><br><span class="line">        [-0.0125,  0.0369, -0.0440,  ...,  0.0466, -0.0250,  0.0114],</span><br><span class="line">        [ 0.0407, -0.0135,  0.0389,  ...,  0.0151,  0.0203,  0.0166],</span><br><span class="line">        [ 0.0319, -0.0301,  0.0393,  ...,  0.0548, -0.0589, -0.0623],</span><br><span class="line">        ...,</span><br><span class="line">        [-0.0496, -0.0027, -0.0179,  ...,  0.0543,  0.0416, -0.0003],</span><br><span class="line">        [ 0.0338, -0.0056, -0.0475,  ...,  0.0057, -0.0026,  0.0187],</span><br><span class="line">        [ 0.0377,  0.0057, -0.0228,  ..., -0.0383, -0.0076,  0.0280]])), </span><br><span class="line">        (&#x27;output.bias&#x27;, tensor([ </span><br><span class="line">        0.0501,  0.0566,  0.0253, -0.0438, -0.0322, </span><br><span class="line">        -0.0575, -0.0386, -0.0467,-0.0455, -0.0255]))])</span><br></pre></td></tr></table></figure><h3 id="读取">读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clone = MyMLP()               <span class="comment"># 先声明一个MyMLP，此时网络已经初始化  </span></span><br><span class="line">clone.load_state_dict(torch.load(<span class="string">&quot;mlp.params&quot;</span>))      <span class="comment"># 更新权重  </span></span><br><span class="line"><span class="built_in">print</span>(clone.<span class="built_in">eval</span>())  </span><br><span class="line">  </span><br><span class="line">Y_clone = clone(X)  </span><br><span class="line"><span class="built_in">print</span>(Y_clone == Y)</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyMLP(</span><br><span class="line">  (hidden): Linear(in_features=20, out_features=256, bias=True)</span><br><span class="line">  (output): Linear(in_features=256, out_features=10, bias=True)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">tensor([[True, True, True, True, True, True, True, True, True, True],</span><br><span class="line">        [True, True, True, True, True, True, True, True, True, True]])</span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1AK4y1P7vs/?spm_id_from=333.999.0.0&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a><br /><a href="http://www.feiguyunai.com/index.php/2019/09/11/pytorch-char03/">Pytorch神经网络工具箱</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（9）</title>
      <link href="/2023/02/26/9-Optimizer%E4%BC%98%E5%8C%96%E5%99%A8/"/>
      <url>/2023/02/26/9-Optimizer%E4%BC%98%E5%8C%96%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><h2 id="sgd-优化器">SGD 优化器</h2><p>新的参数 = 当前参数 - 学习率 * 梯度</p><h1 id="pytoch-使用">pytoch 使用</h1><h2 id="导包">导包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> opt</span><br></pre></td></tr></table></figure><p>其中包含多个优化器包：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302261945696.png" /></p><h1 id="msgd">MSGD</h1><h2 id="公式">公式</h2><p><span class="math display">\[v_{t+1}=uv_t-lr*\bigtriangledown weight\]</span><br /><span class="math display">\[weight=weight+v_{t+1}\]</span></p><h2 id="对应代码">对应代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_num,out_num</span>):  </span><br><span class="line">        self.weight = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(in_num, out_num))  </span><br><span class="line">        self.u = <span class="number">0.3</span>  </span><br><span class="line">        self.vt = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">return</span> self.x @ self.weight  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        delta_weight = self.x.T @ G  </span><br><span class="line">        delta_x = G @ self.weight.T  </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># ----------------------------SGD----------------------------  </span></span><br><span class="line">        <span class="comment"># self.weight -= lr * delta_weight     # 优化器的内容，梯度下降优化器 SGD  </span></span><br><span class="line">        <span class="comment"># ----------------------------MSGD----------------------------        </span></span><br><span class="line">        self.vt = self.u * self.vt - lr * delta_weight  </span><br><span class="line">        self.weight = self.weight + self.vt</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> delta_x  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):    <span class="comment"># 类似于重载  </span></span><br><span class="line">        <span class="keyword">return</span> self.forward(x)</span><br></pre></td></tr></table></figure><h2 id="结果">结果</h2><p>左边为 MSGD，右边为 SGD</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302262045028.png" /></p><h2 id="sigmoid-溢出">Sigmoid 溢出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line"><span class="comment"># 防止-x太大导致数据溢出，所以进行切片，如果超出范围则取边界值  </span></span><br><span class="line">    x = np.clip(x,-<span class="number">100</span>,<span class="number">10000000</span>)    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br></pre></td></tr></table></figure><h2 id="softmax-溢出">Softmax 溢出</h2><p>我们看到 <strong>BP 神经网络</strong>中有这样的例子：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302222043006.png" /></p><p>针对 Softmax 的公式：<span class="math display">\[S_i=\frac{e^{V_i}} {\sum_{j} e^{V_i}}\]</span></p><p>其特点显示再 v 极大会产生溢出。所以做出如下改变：<strong>所有数同时减去最大的数</strong>，这样能保证相对大小没有变化。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302262118936.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="comment"># x是batch_size * 分类数  </span></span><br><span class="line">    max_x = np.<span class="built_in">max</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)    <span class="comment"># batch_size * 1 ， 表示的是每个batch_size（一行）的最大值  </span></span><br><span class="line">    ex = np.exp(x-max_x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    <span class="keyword">return</span> ex/sum_ex</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> <code>max_x = np.max(x,axis=1,keepdims=True)</code> 中需要加上 <code>keepdims=True</code><br />如果不加：shape 为 (batchsize, ) ，表示是一个一维数组，数组中有 batchsize 个元素<br />如果加上：shape 为 (batchsize, 1)，表示一个二维数组，batchsize 行，1 列</p></blockquote><h2 id="loss-溢出">Loss 溢出</h2><p>根据 <strong>5 逻辑回归</strong> 中可知 Loss 公式：<span class="math display">\[Loss=Label·log(pre)+(1-Label)·log(1-pre)\]</span><br />可以得到 Loss 的图像为：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302262155814.jpg" /></p><p>可以看出当 x 接近 0 时，会有<strong>下溢</strong>的可能。所以不能让 x 太接近 0。</p><p>通过代码可以看出，x 最后来自 softmax，所以还需要修改 softmax 的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="comment"># x是batch_size * 分类数  </span></span><br><span class="line">    max_x = np.<span class="built_in">max</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)    <span class="comment"># batch_size * 1 ， 表示的是每个batch_size（一行）的最大值  </span></span><br><span class="line">    ex = np.exp(x-max_x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    result = ex/sum_ex  </span><br><span class="line">    result = np.clip(result,<span class="number">1e-100</span>,<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">8</span>:]), dtype=np.int32)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    magic_number, num_items, rows, cols = struct.unpack(<span class="string">&quot;&gt;iiii&quot;</span>, data[:<span class="number">16</span>])  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">16</span>:]), dtype=np.uint8).reshape(num_items, -<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将label变成矩阵（60000*10）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">labels,class_num=<span class="number">10</span></span>):  </span><br><span class="line">    result = np.zeros((<span class="built_in">len</span>(labels),class_num))  </span><br><span class="line">    <span class="keyword">for</span> index,lab <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):     <span class="comment"># enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据  </span></span><br><span class="line">        result[index][lab] = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    x = np.clip(x,-<span class="number">100</span>,<span class="number">10000000</span>)    <span class="comment"># 防止-x太大导致数据溢出，所以进行切片，如果超出范围则取边界值  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="comment"># x是batch_size * 分类数  </span></span><br><span class="line">    max_x = np.<span class="built_in">max</span>(x,axis=<span class="number">1</span>,keepdims=<span class="literal">True</span>)    <span class="comment"># batch_size * 1 ， 表示的是每个batch_size（一行）的最大值  </span></span><br><span class="line">    ex = np.exp(x-max_x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    result = ex/sum_ex  </span><br><span class="line">    result = np.clip(result,<span class="number">1e-100</span>,<span class="number">1</span>)  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_datas</span>():  </span><br><span class="line">    train_datas = load_images(<span class="string">&quot;data/train-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>     <span class="comment"># (60000, 784)  </span></span><br><span class="line">    train_label = make_one_hot(load_labels(<span class="string">&quot;data/train-labels.idx1-ubyte&quot;</span>),<span class="number">10</span>)          <span class="comment"># #  (60000,)  </span></span><br><span class="line">  </span><br><span class="line">    test_datas = load_images(<span class="string">&quot;data/t10k-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>  </span><br><span class="line">    test_label = load_labels(<span class="string">&quot;data/t10k-labels.idx1-ubyte&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> train_datas,train_label,test_datas,test_label  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_num,out_num</span>):  </span><br><span class="line">        self.weight = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(in_num, out_num))  </span><br><span class="line">        self.u = <span class="number">0.9</span>  </span><br><span class="line">        self.vt = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">return</span> self.x @ self.weight  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        delta_weight = self.x.T @ G  </span><br><span class="line">        delta_x = G @ self.weight.T  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># ----------------------------SGD----------------------------  </span></span><br><span class="line">        <span class="comment"># self.weight -= lr * delta_weight     # 优化器的内容，梯度下降优化器 SGD        </span></span><br><span class="line">        <span class="comment"># ----------------------------MSGD----------------------------        </span></span><br><span class="line">        self.vt = self.u * self.vt - lr * delta_weight  </span><br><span class="line">        self.weight = self.weight + self.vt  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> delta_x  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):    <span class="comment"># 类似于重载  </span></span><br><span class="line">        <span class="keyword">return</span> self.forward(x)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = sigmoid(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        <span class="keyword">return</span> G * self.r * (<span class="number">1</span>-self.r)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.forward(x)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Softmax</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = softmax(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):   <span class="comment"># 传的是label  </span></span><br><span class="line">        <span class="keyword">return</span> (self.r - G)/self.r.shape[<span class="number">0</span>]    <span class="comment"># batch_size就是第0个维度的shape  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.forward(x)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,layers</span>):  </span><br><span class="line">        self.layers = layers  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x,label=<span class="literal">None</span></span>):  </span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:  </span><br><span class="line">            x = layer(x)  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            self.label = label  </span><br><span class="line">            loss = -np.mean(label * np.log(x)) / x.shape[<span class="number">0</span>]  </span><br><span class="line">            <span class="keyword">return</span> loss  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):  </span><br><span class="line">        G = self.label  </span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers[::-<span class="number">1</span>]:  </span><br><span class="line">            G = layer.backward(G)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):    <span class="comment"># *args变参，数量不变  </span></span><br><span class="line">        <span class="keyword">return</span> self.forward(*args)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    train_datas,train_label,test_datas,test_label = get_datas()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义参数  </span></span><br><span class="line">    epoch = <span class="number">100</span>  </span><br><span class="line">    batch_size = <span class="number">600</span>     <span class="comment"># 一次性处理多少图片  </span></span><br><span class="line">    lr = <span class="number">0.05</span>  </span><br><span class="line">    hidden_num = <span class="number">256</span>     <span class="comment"># 隐层大小  </span></span><br><span class="line">  </span><br><span class="line">    model = MyModel([  </span><br><span class="line">        Linear(<span class="number">784</span>,hidden_num),  </span><br><span class="line">        Sigmoid(),  </span><br><span class="line">        Linear(hidden_num,<span class="number">10</span>),  </span><br><span class="line">        Softmax()  </span><br><span class="line">    ])  </span><br><span class="line">  </span><br><span class="line">    batch_times = <span class="built_in">int</span>(np.ceil(<span class="built_in">len</span>(train_datas) / batch_size))     <span class="comment"># np.ceil 向上取整  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> <span class="built_in">range</span>(batch_times):  </span><br><span class="line">  </span><br><span class="line">            x = train_datas[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]     <span class="comment"># 按行为单位取出，每次取batch_size行  </span></span><br><span class="line">            batch_label = train_label[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># forward  </span></span><br><span class="line">            loss = model.forward(x,batch_label)  </span><br><span class="line">            <span class="comment"># if batch_index%100==0:  </span></span><br><span class="line">            <span class="comment">#     print(f&quot;loss=&#123;loss:.3f&#125;&quot;)            model.backward()  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># backward &amp;&amp; 更新梯度  </span></span><br><span class="line">            model.backward()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 利用测试集计算精确度  </span></span><br><span class="line">        x = test_datas  </span><br><span class="line">        model.forward(x)  </span><br><span class="line">  </span><br><span class="line">        pre = np.argmax(model.x, axis=<span class="number">1</span>)     <span class="comment"># 取一行最大值的下标，最终的pre是一个10000行1列的向量  </span></span><br><span class="line">        acc = np.<span class="built_in">sum</span>(pre==test_label)/<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>&#125;</span> epoch=<span class="subst">&#123;e&#125;</span> <span class="subst">&#123;<span class="string">&#x27;*&#x27;</span>*<span class="number">20</span>&#125;</span> \nacc=<span class="subst">&#123;acc:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=64&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/9_optimizer">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（8）</title>
      <link href="/2023/02/24/8-Linear%E5%B1%82/"/>
      <url>/2023/02/24/8-Linear%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>用 Linear 替换 <code>w1</code> 和 <code>w2</code></li><li>用 forward 替换 <code>x @ w</code></li><li>打包 sigmoid 和 softmax 的 forward</li><li>打包 sigmoid 和 softmax 的 backward</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">8</span>:]), dtype=np.int32)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    magic_number, num_items, rows, cols = struct.unpack(<span class="string">&quot;&gt;iiii&quot;</span>, data[:<span class="number">16</span>])  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">16</span>:]), dtype=np.uint8).reshape(num_items, -<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将label变成矩阵（60000*10）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">labels,class_num=<span class="number">10</span></span>):  </span><br><span class="line">    result = np.zeros((<span class="built_in">len</span>(labels),class_num))  </span><br><span class="line">    <span class="keyword">for</span> index,lab <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):     <span class="comment"># enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据  </span></span><br><span class="line">        result[index][lab] = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    ex = np.exp(x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    <span class="keyword">return</span> ex/sum_ex  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_datas</span>():  </span><br><span class="line">    train_datas = load_images(<span class="string">&quot;data/train-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>     <span class="comment"># (60000, 784)  </span></span><br><span class="line">    train_label = make_one_hot(load_labels(<span class="string">&quot;data/train-labels.idx1-ubyte&quot;</span>),<span class="number">10</span>)          <span class="comment"># #  (60000,)  </span></span><br><span class="line">  </span><br><span class="line">    test_datas = load_images(<span class="string">&quot;data/t10k-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>  </span><br><span class="line">    test_label = load_labels(<span class="string">&quot;data/t10k-labels.idx1-ubyte&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> train_datas,train_label,test_datas,test_label  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_num,out_num</span>):  </span><br><span class="line">        self.weight = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(in_num, out_num))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">return</span> self.x @ self.weight  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        delta_weight = self.x.T @ G  </span><br><span class="line">        delta_x = G @ self.weight.T  </span><br><span class="line">        self.weight -= lr * delta_weight     <span class="comment"># 优化器的内容，梯度下降优化器 SGD        return delta_x  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = sigmoid(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        <span class="keyword">return</span> G * self.r * (<span class="number">1</span>-self.r)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Softmax</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = softmax(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):   <span class="comment"># 传的是label  </span></span><br><span class="line">        <span class="keyword">return</span> (self.r - G)/self.r.shape[<span class="number">0</span>]    <span class="comment"># batch_size就是第0个维度的shape  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    train_datas,train_label,test_datas,test_label = get_datas()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义参数  </span></span><br><span class="line">    epoch = <span class="number">100</span>  </span><br><span class="line">    batch_size = <span class="number">600</span>     <span class="comment"># 一次性处理多少图片  </span></span><br><span class="line">    lr = <span class="number">0.01</span>  </span><br><span class="line">    hidden_num = <span class="number">256</span>     <span class="comment"># 隐层大小  </span></span><br><span class="line">  </span><br><span class="line">    linear1_layer = Linear(<span class="number">784</span>,hidden_num)  </span><br><span class="line">    sigmoid_layer = Sigmoid()  </span><br><span class="line">    linear2_layer = Linear(hidden_num,<span class="number">10</span>)  </span><br><span class="line">    softmax_layer = Softmax()  </span><br><span class="line">  </span><br><span class="line">    batch_times = <span class="built_in">int</span>(np.ceil(<span class="built_in">len</span>(train_datas) / batch_size))     <span class="comment"># np.ceil 向上取整  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> <span class="built_in">range</span>(batch_times):  </span><br><span class="line">  </span><br><span class="line">            batch_x = train_datas[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]     <span class="comment"># 按行为单位取出，每次取batch_size行  </span></span><br><span class="line">            batch_label = train_label[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># forward  </span></span><br><span class="line">            h = linear1_layer.forward(batch_x)  </span><br><span class="line">            sig_h = sigmoid_layer.forward(h)  </span><br><span class="line">            p = linear2_layer.forward(sig_h)  </span><br><span class="line">            pre = softmax_layer.forward(p)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 计算loss  </span></span><br><span class="line">            loss = -np.mean(batch_label * np.log(pre))/batch_size     <span class="comment"># 求平均loss  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># backward &amp;&amp; 更新梯度  </span></span><br><span class="line">            G2 = softmax_layer.backward(batch_label)  </span><br><span class="line">            delta_sig_h = linear2_layer.backward(G2)  </span><br><span class="line">            delta_h = sigmoid_layer.backward(delta_sig_h)  </span><br><span class="line">            linear1_layer.backward(delta_h)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 利用测试集计算精确度  </span></span><br><span class="line">        h = linear1_layer.forward(test_datas)  </span><br><span class="line">        sig_h = sigmoid_layer.forward(h)  </span><br><span class="line">        p = linear2_layer.forward(sig_h)  </span><br><span class="line">        pre = softmax_layer.forward(p)     <span class="comment">#pre是一个10000行1列的向量  </span></span><br><span class="line">        <span class="comment"># print(pre.shape)  </span></span><br><span class="line">        pre = np.argmax(pre, axis=<span class="number">1</span>)     <span class="comment"># 取一行最大值的下标，最终的pre是一个10000行1列的向量  </span></span><br><span class="line">        <span class="comment"># print(pre.shape)  </span></span><br><span class="line">  </span><br><span class="line">        acc = np.<span class="built_in">sum</span>(pre==test_label)/<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(acc)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 画图  </span></span><br><span class="line">    <span class="comment"># t = train_datas[1107]  </span></span><br><span class="line">    <span class="comment"># plt.imshow(t.reshape(28,28))    # plt.show()    # print(train_label[1037])</span></span><br></pre></td></tr></table></figure><ol start="6" type="1"><li>简化变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">8</span>:]), dtype=np.int32)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    magic_number, num_items, rows, cols = struct.unpack(<span class="string">&quot;&gt;iiii&quot;</span>, data[:<span class="number">16</span>])  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">16</span>:]), dtype=np.uint8).reshape(num_items, -<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将label变成矩阵（60000*10）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">labels,class_num=<span class="number">10</span></span>):  </span><br><span class="line">    result = np.zeros((<span class="built_in">len</span>(labels),class_num))  </span><br><span class="line">    <span class="keyword">for</span> index,lab <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):     <span class="comment"># enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据  </span></span><br><span class="line">        result[index][lab] = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    ex = np.exp(x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    <span class="keyword">return</span> ex/sum_ex  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_datas</span>():  </span><br><span class="line">    train_datas = load_images(<span class="string">&quot;data/train-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>     <span class="comment"># (60000, 784)  </span></span><br><span class="line">    train_label = make_one_hot(load_labels(<span class="string">&quot;data/train-labels.idx1-ubyte&quot;</span>),<span class="number">10</span>)          <span class="comment"># #  (60000,)  </span></span><br><span class="line">  </span><br><span class="line">    test_datas = load_images(<span class="string">&quot;data/t10k-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>  </span><br><span class="line">    test_label = load_labels(<span class="string">&quot;data/t10k-labels.idx1-ubyte&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> train_datas,train_label,test_datas,test_label  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_num,out_num</span>):  </span><br><span class="line">        self.weight = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(in_num, out_num))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">return</span> self.x @ self.weight  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        delta_weight = self.x.T @ G  </span><br><span class="line">        delta_x = G @ self.weight.T  </span><br><span class="line">        self.weight -= lr * delta_weight     <span class="comment"># 优化器的内容，梯度下降优化器 SGD        return delta_x  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = sigmoid(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        <span class="keyword">return</span> G * self.r * (<span class="number">1</span>-self.r)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Softmax</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = softmax(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):   <span class="comment"># 传的是label  </span></span><br><span class="line">        <span class="keyword">return</span> (self.r - G)/self.r.shape[<span class="number">0</span>]    <span class="comment"># batch_size就是第0个维度的shape  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    train_datas,train_label,test_datas,test_label = get_datas()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义参数  </span></span><br><span class="line">    epoch = <span class="number">100</span>  </span><br><span class="line">    batch_size = <span class="number">600</span>     <span class="comment"># 一次性处理多少图片  </span></span><br><span class="line">    lr = <span class="number">0.01</span>  </span><br><span class="line">    hidden_num = <span class="number">256</span>     <span class="comment"># 隐层大小  </span></span><br><span class="line">  </span><br><span class="line">    linear1_layer = Linear(<span class="number">784</span>,hidden_num)  </span><br><span class="line">    sigmoid_layer = Sigmoid()  </span><br><span class="line">    linear2_layer = Linear(hidden_num,<span class="number">10</span>)  </span><br><span class="line">    softmax_layer = Softmax()  </span><br><span class="line">  </span><br><span class="line">    batch_times = <span class="built_in">int</span>(np.ceil(<span class="built_in">len</span>(train_datas) / batch_size))     <span class="comment"># np.ceil 向上取整  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> <span class="built_in">range</span>(batch_times):  </span><br><span class="line">  </span><br><span class="line">            batch_x = train_datas[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]     <span class="comment"># 按行为单位取出，每次取batch_size行  </span></span><br><span class="line">            batch_label = train_label[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># forward  </span></span><br><span class="line">            x = batch_x  </span><br><span class="line">            x = linear1_layer.forward(x)  </span><br><span class="line">            x = sigmoid_layer.forward(x)  </span><br><span class="line">            x = linear2_layer.forward(x)  </span><br><span class="line">            x = softmax_layer.forward(x)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 计算loss  </span></span><br><span class="line">            loss = -np.mean(batch_label * np.log(x))/batch_size     <span class="comment"># 求平均loss  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># backward &amp;&amp; 更新梯度  </span></span><br><span class="line">            G = batch_label  </span><br><span class="line">            G = softmax_layer.backward(G)  </span><br><span class="line">            G = linear2_layer.backward(G)  </span><br><span class="line">            G = sigmoid_layer.backward(G)  </span><br><span class="line">            linear1_layer.backward(G)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 利用测试集计算精确度  </span></span><br><span class="line">        x = test_datas  </span><br><span class="line">        x = linear1_layer.forward(x)  </span><br><span class="line">        x = sigmoid_layer.forward(x)  </span><br><span class="line">        x = linear2_layer.forward(x)  </span><br><span class="line">        x = softmax_layer.forward(x)  </span><br><span class="line">  </span><br><span class="line">        pre = np.argmax(x, axis=<span class="number">1</span>)     <span class="comment"># 取一行最大值的下标，最终的pre是一个10000行1列的向量  </span></span><br><span class="line">        <span class="comment"># print(pre.shape)  </span></span><br><span class="line">  </span><br><span class="line">        acc = np.<span class="built_in">sum</span>(pre==test_label)/<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(acc)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 画图  </span></span><br><span class="line">    <span class="comment"># t = train_datas[1107]  </span></span><br><span class="line">    <span class="comment"># plt.imshow(t.reshape(28,28))    # plt.show()    # print(train_label[1037])</span></span><br></pre></td></tr></table></figure><ol start="7" type="1"><li>封装 Linear</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">8</span>:]), dtype=np.int32)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    magic_number, num_items, rows, cols = struct.unpack(<span class="string">&quot;&gt;iiii&quot;</span>, data[:<span class="number">16</span>])  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">16</span>:]), dtype=np.uint8).reshape(num_items, -<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将label变成矩阵（60000*10）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">labels,class_num=<span class="number">10</span></span>):  </span><br><span class="line">    result = np.zeros((<span class="built_in">len</span>(labels),class_num))  </span><br><span class="line">    <span class="keyword">for</span> index,lab <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):     <span class="comment"># enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据  </span></span><br><span class="line">        result[index][lab] = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    ex = np.exp(x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    <span class="keyword">return</span> ex/sum_ex  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_datas</span>():  </span><br><span class="line">    train_datas = load_images(<span class="string">&quot;data/train-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>     <span class="comment"># (60000, 784)  </span></span><br><span class="line">    train_label = make_one_hot(load_labels(<span class="string">&quot;data/train-labels.idx1-ubyte&quot;</span>),<span class="number">10</span>)          <span class="comment"># #  (60000,)  </span></span><br><span class="line">  </span><br><span class="line">    test_datas = load_images(<span class="string">&quot;data/t10k-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>  </span><br><span class="line">    test_label = load_labels(<span class="string">&quot;data/t10k-labels.idx1-ubyte&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> train_datas,train_label,test_datas,test_label  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_num,out_num</span>):  </span><br><span class="line">        self.weight = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(in_num, out_num))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">return</span> self.x @ self.weight  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        delta_weight = self.x.T @ G  </span><br><span class="line">        delta_x = G @ self.weight.T  </span><br><span class="line">        self.weight -= lr * delta_weight     <span class="comment"># 优化器的内容，梯度下降优化器 SGD        return delta_x  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = sigmoid(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        <span class="keyword">return</span> G * self.r * (<span class="number">1</span>-self.r)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Softmax</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = softmax(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):   <span class="comment"># 传的是label  </span></span><br><span class="line">        <span class="keyword">return</span> (self.r - G)/self.r.shape[<span class="number">0</span>]    <span class="comment"># batch_size就是第0个维度的shape  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    train_datas,train_label,test_datas,test_label = get_datas()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义参数  </span></span><br><span class="line">    epoch = <span class="number">100</span>  </span><br><span class="line">    batch_size = <span class="number">600</span>     <span class="comment"># 一次性处理多少图片  </span></span><br><span class="line">    lr = <span class="number">0.01</span>  </span><br><span class="line">    hidden_num = <span class="number">256</span>     <span class="comment"># 隐层大小  </span></span><br><span class="line">  </span><br><span class="line">    layers = [  </span><br><span class="line">        Linear(<span class="number">784</span>,hidden_num),  </span><br><span class="line">        Sigmoid(),  </span><br><span class="line">        Linear(hidden_num,<span class="number">10</span>),  </span><br><span class="line">        Softmax()  </span><br><span class="line">    ]  </span><br><span class="line">  </span><br><span class="line">    batch_times = <span class="built_in">int</span>(np.ceil(<span class="built_in">len</span>(train_datas) / batch_size))     <span class="comment"># np.ceil 向上取整  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> <span class="built_in">range</span>(batch_times):  </span><br><span class="line">  </span><br><span class="line">            x = train_datas[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]     <span class="comment"># 按行为单位取出，每次取batch_size行  </span></span><br><span class="line">            batch_label = train_label[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># forward  </span></span><br><span class="line">            <span class="keyword">for</span> layer <span class="keyword">in</span> layers:  </span><br><span class="line">                x = layer.forward(x)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 计算loss  </span></span><br><span class="line">            loss = -np.mean(batch_label * np.log(x))/batch_size     <span class="comment"># 求平均loss  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># backward &amp;&amp; 更新梯度  </span></span><br><span class="line">            G = batch_label  </span><br><span class="line">            <span class="keyword">for</span> layer <span class="keyword">in</span> layers[::-<span class="number">1</span>]:    <span class="comment"># 表示从后往前  </span></span><br><span class="line">                G = layer.backward(G)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 利用测试集计算精确度  </span></span><br><span class="line">        x = test_datas  </span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> layers:  </span><br><span class="line">            x = layer.forward(x)  </span><br><span class="line">  </span><br><span class="line">        pre = np.argmax(x, axis=<span class="number">1</span>)     <span class="comment"># 取一行最大值的下标，最终的pre是一个10000行1列的向量  </span></span><br><span class="line">        acc = np.<span class="built_in">sum</span>(pre==test_label)/<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(acc)</span><br></pre></td></tr></table></figure><ol start="8" type="1"><li>最终代码（完全封装）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">8</span>:]), dtype=np.int32)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    magic_number, num_items, rows, cols = struct.unpack(<span class="string">&quot;&gt;iiii&quot;</span>, data[:<span class="number">16</span>])  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">16</span>:]), dtype=np.uint8).reshape(num_items, -<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将label变成矩阵（60000*10）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">labels,class_num=<span class="number">10</span></span>):  </span><br><span class="line">    result = np.zeros((<span class="built_in">len</span>(labels),class_num))  </span><br><span class="line">    <span class="keyword">for</span> index,lab <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):     <span class="comment"># enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据  </span></span><br><span class="line">        result[index][lab] = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    ex = np.exp(x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    <span class="keyword">return</span> ex/sum_ex  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_datas</span>():  </span><br><span class="line">    train_datas = load_images(<span class="string">&quot;data/train-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>     <span class="comment"># (60000, 784)  </span></span><br><span class="line">    train_label = make_one_hot(load_labels(<span class="string">&quot;data/train-labels.idx1-ubyte&quot;</span>),<span class="number">10</span>)          <span class="comment"># #  (60000,)  </span></span><br><span class="line">  </span><br><span class="line">    test_datas = load_images(<span class="string">&quot;data/t10k-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>  </span><br><span class="line">    test_label = load_labels(<span class="string">&quot;data/t10k-labels.idx1-ubyte&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> train_datas,train_label,test_datas,test_label  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Linear</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,in_num,out_num</span>):  </span><br><span class="line">        self.weight = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(in_num, out_num))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">return</span> self.x @ self.weight  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        delta_weight = self.x.T @ G  </span><br><span class="line">        delta_x = G @ self.weight.T  </span><br><span class="line">        self.weight -= lr * delta_weight     <span class="comment"># 优化器的内容，梯度下降优化器 SGD        return delta_x  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):    <span class="comment"># 类似于重载  </span></span><br><span class="line">        <span class="keyword">return</span> self.forward(x)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = sigmoid(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):  </span><br><span class="line">        <span class="keyword">return</span> G * self.r * (<span class="number">1</span>-self.r)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.forward(x)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Softmax</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):  </span><br><span class="line">        self.r = softmax(x)  </span><br><span class="line">        <span class="keyword">return</span> self.r  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,G</span>):   <span class="comment"># 传的是label  </span></span><br><span class="line">        <span class="keyword">return</span> (self.r - G)/self.r.shape[<span class="number">0</span>]    <span class="comment"># batch_size就是第0个维度的shape  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, x</span>):  </span><br><span class="line">        <span class="keyword">return</span> self.forward(x)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyModel</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,layers</span>):  </span><br><span class="line">        self.layers = layers  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x,label=<span class="literal">None</span></span>):  </span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers:  </span><br><span class="line">            x = layer(x)  </span><br><span class="line">        self.x = x  </span><br><span class="line">        <span class="keyword">if</span> label <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  </span><br><span class="line">            self.label = label  </span><br><span class="line">            loss = -np.mean(label * np.log(x)) / x.shape[<span class="number">0</span>]  </span><br><span class="line">            <span class="keyword">return</span> loss  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self</span>):  </span><br><span class="line">        G = self.label  </span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers[::-<span class="number">1</span>]:  </span><br><span class="line">            G = layer.backward(G)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args</span>):    <span class="comment"># *args变参，数量不变  </span></span><br><span class="line">        <span class="keyword">return</span> self.forward(*args)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    train_datas,train_label,test_datas,test_label = get_datas()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 定义参数  </span></span><br><span class="line">    epoch = <span class="number">100</span>  </span><br><span class="line">    batch_size = <span class="number">600</span>     <span class="comment"># 一次性处理多少图片  </span></span><br><span class="line">    lr = <span class="number">0.01</span>  </span><br><span class="line">    hidden_num = <span class="number">256</span>     <span class="comment"># 隐层大小  </span></span><br><span class="line">  </span><br><span class="line">    model = MyModel([  </span><br><span class="line">        Linear(<span class="number">784</span>,hidden_num),  </span><br><span class="line">        Sigmoid(),  </span><br><span class="line">        Linear(hidden_num,<span class="number">10</span>),  </span><br><span class="line">        Softmax()  </span><br><span class="line">    ])  </span><br><span class="line">  </span><br><span class="line">    batch_times = <span class="built_in">int</span>(np.ceil(<span class="built_in">len</span>(train_datas) / batch_size))     <span class="comment"># np.ceil 向上取整  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> <span class="built_in">range</span>(batch_times):  </span><br><span class="line">  </span><br><span class="line">            x = train_datas[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]     <span class="comment"># 按行为单位取出，每次取batch_size行  </span></span><br><span class="line">            batch_label = train_label[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># forward  </span></span><br><span class="line">            loss = model.forward(x,batch_label)  </span><br><span class="line">            <span class="keyword">if</span> batch_index%<span class="number">100</span>==<span class="number">0</span>:  </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;loss=<span class="subst">&#123;loss:<span class="number">.3</span>f&#125;</span>&quot;</span>)  </span><br><span class="line">            model.backward()  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># backward &amp;&amp; 更新梯度  </span></span><br><span class="line">            model.backward()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 利用测试集计算精确度  </span></span><br><span class="line">        x = test_datas  </span><br><span class="line">        model.forward(x)  </span><br><span class="line">  </span><br><span class="line">        pre = np.argmax(model.x, axis=<span class="number">1</span>)     <span class="comment"># 取一行最大值的下标，最终的pre是一个10000行1列的向量  </span></span><br><span class="line">        acc = np.<span class="built_in">sum</span>(pre==test_label)/<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;acc=<span class="subst">&#123;acc:<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ChatGPT注册教程</title>
      <link href="/2023/02/24/%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/"/>
      <url>/2023/02/24/%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>需要挂梯子注册</strong></p></blockquote><h1 id="注册">注册</h1><ol type="1"><li>先进入<a href="https://ai.com">网站</a>，点击 <strong>sign up</strong> 进行登录</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241323211.png" /></p><ol start="2" type="1"><li>输入邮箱信息</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241323867.png" /></p><ol start="3" type="1"><li>设置密码</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241324189.png" /></p><ol start="4" type="1"><li>邮箱验证</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241324853.png" /></p><ol start="5" type="1"><li>看到以上界面后打开刚刚注册填入的邮箱，会收到邮件打开后如下图：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241324173.png" /></p><ol start="6" type="1"><li>点击验证后跳转，输入姓名后点击继续</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241324801.png" /></p><p><strong>提示需要手机号验证，国内手机号无法验证，需要进入接码平台。</strong></p><h1 id="接码">接码</h1><ol type="1"><li>点击进入<a href="https://sms-activate.org/">接码平台</a></li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241325639.png" /></p><ol start="2" type="1"><li>点击右上角的注册，输入注册信息，注意密码需要包含大写、小写和数字</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241326445.png" /></p><ol start="3" type="1"><li>点击注册后会受到一封确认邮件，可能需要等一两分钟：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241326598.png" /></p><ol start="4" type="1"><li>点击确认后跳转回主页，点击左下侧的 OpenAI 栏：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241327270.png" /></p><ol start="5" type="1"><li>找到英国，点击右侧的购物车：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241327067.png" /></p><ol start="6" type="1"><li><p>会弹出重置界面，选择下面的支付宝选项，充值 1 美元就够了。</p></li><li><p>充值后返回到主页，再点击那个英国右侧的购物车按钮完成购买，得到了一个英国的手机号码用于之前 chatgpt 的手机号绑定：</p></li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241328558.png" /></p><ol start="8" type="1"><li>将该电话号码输入到之前的手机绑定界面中，注意选中 United kingdom (刚刚注册手机号的国家)，输入的电话号码将前缀（此处为+44）去掉：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241328423.png" /></p><ol start="9" type="1"><li>接受验证码：</li></ol><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241328069.png" /></p><ol start="10" type="1"><li>输入验证码</li></ol><h1 id="注册完毕">注册完毕</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241329635.png" /></p><h1 id="写在最后">写在最后</h1><blockquote><p>感谢同门永琦同学的实践和记录~部分学校校园网（vpn）可以访问外网，当然最稳定的方式是挂梯子。 NewBing 已经接入了 ChatGPT，可以看我之前发的教程进行申请。百度 Ernie 也即将上线文心一言 bot，期待一下！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 骚操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骚操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（7）</title>
      <link href="/2023/02/23/7-%E5%8D%B7%E7%A7%AF/"/>
      <url>/2023/02/23/7-%E5%8D%B7%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><h2 id="单图提取特征">单图提取特征</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302231607857.jpg" /></p><h2 id="多图提取特征">多图提取特征</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302231612533.jpg" /></p><h2 id="多图多卷积提取特征">多图多卷积提取特征</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302231700295.jpg" /></p><h1 id="卷积加速">卷积加速</h1><p>这里介绍最简单的卷积加速：img2col</p><h2 id="低维-img2col">低维 img2col</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241715569.jpg" /></p><h2 id="高维-img2col">高维 img2col</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241714321.jpg" /></p><h2 id="多卷积核">多卷积核</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241731076.jpg" alt="2d15aac0e195d5d57713679c078b5a1.jpg" /><figcaption aria-hidden="true">2d15aac0e195d5d57713679c078b5a1.jpg</figcaption></figure><h1 id="复现">复现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2  </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span>  np  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_imgs</span>(<span class="params">path:<span class="built_in">str</span></span>):  </span><br><span class="line">    img_files = os.listdir(path)  </span><br><span class="line">    result = []  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> img_files:  </span><br><span class="line">        file = os.path.join(path,file)  </span><br><span class="line">        img = cv2.imread(file)  </span><br><span class="line">        img = cv2.resize(img,(<span class="number">150</span>,<span class="number">150</span>))  </span><br><span class="line">        img = img.transpose(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)  </span><br><span class="line">        result.append(img)  </span><br><span class="line">    <span class="keyword">return</span> np.array(result)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv</span>(<span class="params">imgs,kernel</span>):  </span><br><span class="line">    out_channel,in_channel,kernel_h,kernel_w = kernel.shape  </span><br><span class="line">    img_num,_,img_h,img_w = imgs.shape  </span><br><span class="line">  </span><br><span class="line">    c_w = img_w - kernel_w + <span class="number">1</span>  </span><br><span class="line">    c_h = img_h - kernel_h + <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    A = kernel.reshape(out_channel,-<span class="number">1</span>)  </span><br><span class="line">    B = np.zeros((img_num,A.shape[<span class="number">1</span>],c_w*c_h))  </span><br><span class="line">  </span><br><span class="line">    c = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">range</span>(c_h):  </span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(c_w):  </span><br><span class="line">            d = imgs[:,:,h:h+kernel_h,w:w+kernel_w]  </span><br><span class="line">            d = d.reshape(img_num,-<span class="number">1</span>)  </span><br><span class="line">            B[:,:,c] = d  </span><br><span class="line">            c += <span class="number">1</span>  </span><br><span class="line">  </span><br><span class="line">    result = A @ B  </span><br><span class="line">    result = result.reshape(img_num,out_channel,c_h,c_w)  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    kernel = np.array([  </span><br><span class="line">        [  </span><br><span class="line">            [  </span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>],  </span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>],  </span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">10</span>, <span class="number">1</span>]  </span><br><span class="line">            ],  </span><br><span class="line">            [  </span><br><span class="line">                [<span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>],  </span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>],  </span><br><span class="line">                [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]  </span><br><span class="line">            ],  </span><br><span class="line">            [  </span><br><span class="line">                [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],  </span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">9</span>, <span class="number">0</span>],  </span><br><span class="line">                [-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>]  </span><br><span class="line">            ]  </span><br><span class="line">        ],  </span><br><span class="line">        [  </span><br><span class="line">            [  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>]  </span><br><span class="line">            ],  </span><br><span class="line">            [  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>]  </span><br><span class="line">            ],  </span><br><span class="line">            [  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>],  </span><br><span class="line">                [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>]  </span><br><span class="line">            ]  </span><br><span class="line">        ],  </span><br><span class="line">  </span><br><span class="line">    ])  </span><br><span class="line">    <span class="comment"># print(kernel.shape)     # (2, 3, 3, 3)  </span></span><br><span class="line">    imgs = get_imgs(<span class="string">&quot;img&quot;</span>)  </span><br><span class="line">    <span class="comment"># print(imgs.shape)      # (4, 3, 150, 150)  </span></span><br><span class="line">    result = conv(imgs,kernel)     <span class="comment"># (4, 2, 148, 148)  </span></span><br><span class="line">    <span class="comment"># print(result.shape)    for i in result:  </span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i:  </span><br><span class="line">            plt.imshow(j,cmap=<span class="string">&quot;gray&quot;</span>)  </span><br><span class="line">            plt.show()</span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=41&amp;vd_source=ee0c3d58f791481ea0f93acb1c8a35ab">bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/7_%E5%8D%B7%E7%A7%AF">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（6）</title>
      <link href="/2023/02/22/6-BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/02/22/6-BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><strong>BP 神经网路</strong>作为深度学习中的一个重要网络框架，后面的网络都是基于 BP 神经网路，以下是来自 ChatGPT 的回答：</p><blockquote><p>BP 神经网络（Backpropagation neural network）是一种基于误差反向传播算法的人工神经网络模型，常用于分类、回归等任务。它由输入层、隐藏层和输出层构成，其中隐藏层可以有多个。在 BP 神经网络中，神经元之间的连接权重是模型的参数，模型的训练就是通过调整权重来减小模型预测值与真实值之间的误差。</p><p>BP 神经网络的训练过程主要包括前向传播和反向传播两个阶段。前向传播时，输入样本经过输入层的神经元传递到隐藏层和输出层，每个神经元都计算一次加权和并通过激活函数进行非线性转换。输出层的预测值与真实值之间的误差被称为损失函数。</p><p>反向传播时，首先通过损失函数计算输出层的误差，并将误差反向传播回隐藏层和输入层。在每个神经元中，根据误差大小和神经元输入值计算对权重的偏导数，并使用梯度下降法对权重进行更新，以减小损失函数的值。</p><p>BP 神经网络需要大量的数据和计算资源来进行训练，同时容易出现过拟合问题，需要进行合理的正则化和超参数调整。然而，BP 神经网络仍然是一种基本的神经网络模型，被广泛应用于图像识别、自然语言处理、信号处理等领域。</p></blockquote><p><strong>BP 神经网络构造：</strong> 两层线性层+激活函数（两个线性层之间加了一个激活函数） - 第一层线性层：用于特征提取 - 第二层线性层：用于分类（分类器）</p><p><strong>前导知识：</strong> 矩阵运算，矩阵求导</p><p>本文以 Mnist 手写数字识别讲解 BP 神经网络。</p><h1 id="mnist-数据集">Mnist 数据集</h1><p>数字识别是一个 10 分类问题。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302221925936.png" /></p><h1 id="分类流程">分类流程</h1><p>先将 28*28 的图片转为 1*784 的向量，再用这个向量乘以一个 W 矩阵，得到的结果可以判断出所属的分类。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302221955167.png" /></p><h1 id="one-hot">One-hot</h1><p>以下是 Chat-GPT 的介绍：</p><blockquote><p>在机器学习和自然语言处理等领域中，one-hot 是一种将分类变量表示为二进制向量的技术。在这种表示方法中，每个分类变量被编码为一个唯一的二进制向量，其中只有一个元素为 1，其余元素为 0。这个唯一的元素所在的位置对应于该变量的类别。例如，如果有三个类别 A、B、C，它们可以分别表示为 (1, 0, 0)、(0, 1, 0)、(0, 0, 1) 三个向量。</p><p>使用one-hot表示方法有很多好处。首先，它允许我们对分类变量进行数学运算，例如计算向量之间的余弦相似度等。其次，one-hot向量不含有冗余信息，因此可以减少存储和计算的开销。最后，one-hot表示方法可以直接应用于许多机器学习算法中，如逻辑回归、支持向量机等。</p><p>需要注意的是，当类别数量很大时，使用one-hot表示方法会导致向量维度很高，这可能会导致计算和存储的问题。此外，当类别之间存在一定的层次关系时，one-hot表示方法可能不是最优的选择，因为它不能直接反映出类别之间的相似性或差异性。</p></blockquote><p>one-hot 作用在一张图片中时，将一张图片的 label 数字变成一个向量。这样才方便做 Loss 和求导。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302222011426.jpg" /></p><h1 id="softmax">Softmax</h1><p>常用于多分类，其公式为：<span class="math display">\[S_i=\frac{e^{V_i}} {\sum_{j} e^{V_i}}\]</span></p><blockquote><p>这里用指数来进行计算，是为了方便后面求导；此外，也是防止 V 是负数带来的计算的麻烦，这样也能作为正数在式子中运算。</p></blockquote><p>利用 softmax 将预测出来的值映射成为 0~1 之间的向量（归一化），再拿处理过的向量和 label 向量进行 loss。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302222027522.png" /></p><p>softmax 会放大大值，缩小小值，使得每个值之间差距变大。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302222043006.png" /></p><h1 id="bp-模型">BP 模型</h1><h2 id="单数据思路">单数据思路</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302222105746.png" /></p><blockquote><p>act 是激活函数（sigmod/softmax），用来将数据映射到 0~1 之间。</p></blockquote><h2 id="多数据思路">多数据思路</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302231114042.png" /></p><h2 id="loss-对-w2-导数">Loss 对 W2 导数</h2><blockquote><p>想求 Loss 对 <span class="math inline">\(W_2\)</span> 的导数⬅️求 Loss 对 P 导数⬅️求 Loss 对 pre 导数</p></blockquote><p>先求出 Loss 对 pre 的导数，通过联合求导求出 Loss 对 p 的导数，再利用 <span class="math inline">\(A@B =C\)</span> 的求导关系求出 Loss 对 <span class="math inline">\(W_2\)</span> 的导数。</p><p>这里给出 Loss 对 P 的求导公式 ：<span class="math display">\[G_2=\frac{\partial Loss}{\partial P}=\frac{\partial Loss}{\partial pre}·\frac{\partial pre}{\partial P}=pre-Label\]</span></p><blockquote><p>pre 和 Label 是对应位置相减</p></blockquote><p>通过 <span class="math inline">\(A@B =C\)</span> 的求导关系，求出 Loss 对 <span class="math inline">\(W_2\)</span> 的求导公式：<span class="math display">\[\bigtriangleup W_2=\frac{\partial Loss}{\partial W_2}=sig\_h^T@G_2\]</span> 可以更新下一轮的 <span class="math inline">\(W_2\)</span> ：<span class="math display">\[W_2=W_2-lr·\frac{\partial Loss}{\partial W_2}\]</span></p><h2 id="loss-对-w1-导数">Loss 对 W1 导数</h2><p>与求 Loss 对 <span class="math inline">\(W_2\)</span> 导数同理，先求出 Loss 对 sig_h 的导数，再求出 Loss 对 h 导数，再求出 Loss 对 <span class="math inline">\(W_1\)</span> 的导数。</p><p><span class="math display">\[\bigtriangleup sig\_h=\frac{\partial Loss}{\partial sig\_h}=sig\_h^T@G_2\]</span></p><p><span class="math display">\[\bigtriangleup h=G_1=\frac{\partial Loss}{\partial h}=\frac{\partial Loss}{\partial sig\_h}·\frac{\partial sig\_h}{\partial h}\]</span></p><p>其中 sigmoid 公式为：<span class="math display">\[f=\frac {1} {1+e^{-x}}\]</span></p><p>sigmoid 的求导公式：<span class="math display">\[f&#39;=\frac {1} {1+e^{-x}}·(1-\frac {1} {1+e^{-x}})\]</span></p><p>所以 <span class="math inline">\(G_1\)</span> 可以写为：<span class="math display">\[\bigtriangleup h=G_1=\frac{\partial Loss}{\partial sig\_h}·[sig\_h·(1-sig\_h)]\]</span></p><p>所以 Loss 对 <span class="math inline">\(W_1\)</span> 的导数为：<span class="math display">\[\bigtriangleup W_1=\frac{\partial Loss}{\partial W_1}=X^T@G_1 \]</span></p><p>可以更新下一轮的 <span class="math inline">\(W_1\)</span> ：<span class="math display">\[W_1=W_1-lr·\frac{\partial Loss}{\partial W_1}\]</span></p><blockquote><p>上面的两次求 Loss 对 W 的求解过程就是backward</p></blockquote><h1 id="复现">复现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> struct  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">8</span>:]), dtype=np.int32)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file</span>):  <span class="comment"># 加载数据  </span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        data = f.read()  </span><br><span class="line">    magic_number, num_items, rows, cols = struct.unpack(<span class="string">&quot;&gt;iiii&quot;</span>, data[:<span class="number">16</span>])  </span><br><span class="line">    <span class="keyword">return</span> np.asanyarray(<span class="built_in">bytearray</span>(data[<span class="number">16</span>:]), dtype=np.uint8).reshape(num_items, -<span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将label变成举证（60000*10）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">make_one_hot</span>(<span class="params">labels,class_num=<span class="number">10</span></span>):  </span><br><span class="line">    result = np.zeros((<span class="built_in">len</span>(labels),class_num))  </span><br><span class="line">    <span class="keyword">for</span> index,lab <span class="keyword">in</span> <span class="built_in">enumerate</span>(labels):     <span class="comment"># enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据下标和数据  </span></span><br><span class="line">        result[index][lab] = <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> result  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">x</span>):  </span><br><span class="line">    ex = np.exp(x)    <span class="comment"># 整个矩阵的每个元素都求指数  </span></span><br><span class="line">    sum_ex = np.<span class="built_in">sum</span>(ex, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)     <span class="comment"># 按行求指数结果的和，axis=1表示按行，keepdims=True表示保持原来形状  </span></span><br><span class="line">    <span class="keyword">return</span> ex/sum_ex  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    train_datas = load_images(<span class="string">&quot;data/train-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>     <span class="comment"># (60000, 784)  </span></span><br><span class="line">    train_label = make_one_hot(load_labels(<span class="string">&quot;data/train-labels.idx1-ubyte&quot;</span>),<span class="number">10</span>)          <span class="comment"># #  (60000,)  </span></span><br><span class="line">    <span class="comment"># print(train_datas.shape,train_label.shape)    # print(train_label[0])    # 输出一行  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 测试集不做one_hot  </span></span><br><span class="line">    test_datas = load_images(<span class="string">&quot;data/t10k-images.idx3-ubyte&quot;</span>) / <span class="number">255</span>  </span><br><span class="line">    test_label = load_labels(<span class="string">&quot;data/t10k-labels.idx1-ubyte&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    epoch = <span class="number">100</span>  </span><br><span class="line">    batch_size = <span class="number">600</span>     <span class="comment"># 一次性处理多少图片  </span></span><br><span class="line">    lr = <span class="number">0.01</span>  </span><br><span class="line">  </span><br><span class="line">    hidden_num = <span class="number">256</span>     <span class="comment"># 隐层大小  </span></span><br><span class="line">    w1 = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(<span class="number">784</span>,hidden_num))  </span><br><span class="line">    w2 = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(hidden_num,<span class="number">10</span>))  </span><br><span class="line">  </span><br><span class="line">    batch_times = <span class="built_in">int</span>(np.ceil(<span class="built_in">len</span>(train_datas) / batch_size))     <span class="comment"># np.ceil 向上取整  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> batch_index <span class="keyword">in</span> <span class="built_in">range</span>(batch_times):  </span><br><span class="line">  </span><br><span class="line">            batch_x = train_datas[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]     <span class="comment"># 按行为单位取出，每次取batch_size行  </span></span><br><span class="line">            batch_label = train_label[batch_index * batch_size : (batch_index + <span class="number">1</span>) * batch_size]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># forward  </span></span><br><span class="line">            h = batch_x @ w1  </span><br><span class="line">            sig_h = sigmoid(h)  </span><br><span class="line">            p = sig_h @ w2  </span><br><span class="line">            pre = softmax(p)  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 计算数据  </span></span><br><span class="line">            loss = -np.mean(batch_label * np.log(pre))/batch_size     <span class="comment"># 求平均loss  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># backward            G2 = (pre - batch_label)/batch_size     # backward都和G2有关，G2会因为batch_size过大而梯度爆炸，这里除以batch_size可以避免梯度爆炸，  </span></span><br><span class="line">            delta_w2 = sig_h.T @ G2  </span><br><span class="line">            delta_sig_h = G2 @ w2.T  </span><br><span class="line">            delta_h = delta_sig_h * sig_h * (<span class="number">1</span> - sig_h)    <span class="comment"># 1-sig_h是sig_h中每个元素都被1减  </span></span><br><span class="line">            delta_w1 = batch_x.T @ delta_h  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 更新梯度  </span></span><br><span class="line">            w1 = w1 - lr * delta_w1  </span><br><span class="line">            w2 = w2 - lr * delta_w2  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 利用测试集计算精确度  </span></span><br><span class="line">        h = test_datas @ w1  </span><br><span class="line">        sig_h = sigmoid(h)  </span><br><span class="line">        p = sig_h @ w2  </span><br><span class="line">        pre = softmax(p)     <span class="comment">#pre是一个10000行1列的向量  </span></span><br><span class="line">        <span class="comment"># print(pre.shape)  </span></span><br><span class="line">        pre = np.argmax(pre, axis=<span class="number">1</span>)     <span class="comment"># 取一行最大值的下标，最终的pre是一个10000行1列的向量  </span></span><br><span class="line">        <span class="comment"># print(pre.shape)  </span></span><br><span class="line">  </span><br><span class="line">        acc = np.<span class="built_in">sum</span>(pre==test_label)/<span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(acc)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 画图  </span></span><br><span class="line">    <span class="comment"># t = train_datas[1107]  </span></span><br><span class="line">    <span class="comment"># plt.imshow(t.reshape(28,28))    # plt.show()    # print(train_label[1037])</span></span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=28&amp;vd_source=ee0c3d58f791481ea0f93acb1c8a35ab">Bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/6_%E6%89%8B%E5%86%99BP">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（5）</title>
      <link href="/2023/02/22/5-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/"/>
      <url>/2023/02/22/5-%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><strong>逻辑回归 = 线性回归 + 激活函数</strong></p><p>激活函数的功能： 1. 可以满足非线性因子 2. 将值映射到一个小范围内，减少梯度爆炸的可能</p><p>逻辑回归的问题： 1. 回归问题（解答题，根据历史情况和方程计算划分） 2. 分类问题（分类问题，根据已有进行划分）</p><p>sigmod 激活函数多用于二分类问题（公式： <span class="math inline">\(sigmoid(P)=\frac {1} {(1+e^{-P})}\)</span>）<br />softmax 激活函数多用于多分类问题</p><h1 id="计算步骤">计算步骤</h1><ol type="1"><li>先求出计算出来的值：<span class="math display">\[P=X@k\]</span><br /></li><li>利用 sigmoid 激活函数映射出值域为 0~1 的 pre：<span class="math display">\[pre=sig(P)=\frac {1} {(1+e^{-P})}\]</span></li><li>利用 pre 和 Label 分类标签计算 Loss：<span class="math display">\[Loss=Label·log(pre)+(1-Label)·log(1-pre)\]</span> 因为 pre 一直在 0~1 之间，所以 <span class="math inline">\(log (1-pre)\)</span> 和 <span class="math inline">\(log (pre)\)</span> 是负数，所以这里 loss 是负数，但是为了更加方便计算，常常将 Loss 进行取反：<span class="math display">\[Loss=-Label·log(pre)+(1-Label)·log(1-pre)\]</span></li><li>利用 Loss 对 k 进行影响：<span class="math display">\[G=\frac{\partial Loss}{\partial P}=\frac{\partial Loss}{\partial pre}·\frac{\partial pre}{\partial P}=pre-Label\]</span><span class="math display">\[\frac{\partial Loss}{\partial k}=X^T@G\]</span> <span class="math display">\[k=k-lr*\frac{\partial Loss}{\partial k}\]</span></li></ol><h2 id="注意">注意</h2><p>如果需要加上偏置值 b，需要进行更新：<span class="math display">\[\frac{\partial Loss}{\partial b}=sum(G)\]</span> <span class="math display">\[b=b-lr*\frac{\partial Loss}{\partial b}\]</span></p><h1 id="复现">复现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))    <span class="comment"># 利用np对numpy的每个数都单独进行这样的操作  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># [毛发长，腿长]  </span></span><br><span class="line">    dogs = np.array([[<span class="number">8.9</span>,<span class="number">12</span>],[<span class="number">9</span>,<span class="number">11</span>],[<span class="number">10</span>,<span class="number">13</span>],[<span class="number">9.9</span>,<span class="number">11.2</span>],[<span class="number">12.2</span>,<span class="number">10.1</span>],[<span class="number">9.8</span>,<span class="number">13</span>],[<span class="number">8.8</span>,<span class="number">11.2</span>]],dtype = np.float32)   <span class="comment"># 0  </span></span><br><span class="line">    cats = np.array([[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">3.5</span>,<span class="number">5.5</span>],[<span class="number">4.5</span>,<span class="number">5.1</span>],[<span class="number">3.4</span>,<span class="number">4.1</span>],[<span class="number">4.1</span>,<span class="number">5.2</span>],[<span class="number">4.4</span>,<span class="number">4.4</span>]],dtype = np.float32)        <span class="comment"># 1  </span></span><br><span class="line">    labels = np.array([<span class="number">0</span>]*<span class="number">7</span>+[<span class="number">1</span>]*<span class="number">7</span>, dtype=np.int32).reshape(-<span class="number">1</span>,<span class="number">1</span>)  </span><br><span class="line">    <span class="comment"># print(label)  </span></span><br><span class="line">  </span><br><span class="line">    X = np.vstack((dogs,cats))    <span class="comment"># np.vstack返回竖直堆叠后的数组  </span></span><br><span class="line">    <span class="comment"># print(X)  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># np.random.normal能指定生成的数据的均值和方差  </span></span><br><span class="line">    k = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,size=(<span class="number">2</span>,<span class="number">1</span>))    <span class="comment"># 这里规定均值为0，方差为1，2行1列  </span></span><br><span class="line">    b = <span class="number">0</span>    <span class="comment"># 偏置值  </span></span><br><span class="line">    epoch = <span class="number">1000</span>  </span><br><span class="line">    lr = <span class="number">0.05</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        p = X @ k + b    <span class="comment"># 计算结果  </span></span><br><span class="line">  </span><br><span class="line">        pre = sigmoid(p)      <span class="comment"># pre的每个值都在0~1  </span></span><br><span class="line">        loss = -np.mean(labels * np.log(pre) + (<span class="number">1</span>-labels) * np.log((<span class="number">1</span>-pre)))     <span class="comment"># loss是一个标量  </span></span><br><span class="line">        G = pre - labels  </span><br><span class="line">  </span><br><span class="line">        delta_k = X.T @ G  </span><br><span class="line">        delta_b = np.<span class="built_in">sum</span>(G)  </span><br><span class="line">  </span><br><span class="line">        k = k - lr * delta_k  </span><br><span class="line">        b = b - lr * delta_b  </span><br><span class="line">  </span><br><span class="line">        <span class="built_in">print</span>(loss)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        f1 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入毛发长：&quot;</span>))  </span><br><span class="line">        f2 = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入腿长：&quot;</span>))  </span><br><span class="line">  </span><br><span class="line">        text_x = np.array([f1,f2]).reshape(<span class="number">1</span>,<span class="number">2</span>)  </span><br><span class="line">        p = sigmoid(text_x @ k + b)  </span><br><span class="line">        <span class="keyword">if</span> p&gt;<span class="number">0.5</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;类别：猫&quot;</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;类别：狗&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=22&amp;vd_source=ee0c3d58f791481ea0f93acb1c8a35ab">bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/5_%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（4）</title>
      <link href="/2023/02/21/4-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"/>
      <url>/2023/02/21/4-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>矩阵运算在深度学习中多用于<strong>多特征运算</strong>。</p><p>下图中每一列为一个特征，每一行的多个特征组成 Y 的一行结果。将多个特征归结为一个举证，然后按照举证进行计算。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302221128499.jpg" /></p><h2 id="常用公式">常用公式</h2><blockquote><p><span class="math display">\[A·B=C\]</span> <span class="math display">\[G=\frac{\partial L}{\partial C}\]</span> <span class="math display">\[\bigtriangledown A=G·B^T\]</span> <span class="math display">\[\bigtriangledown B=A^T·G\]</span></p></blockquote><h1 id="复现">复现</h1><p>上图可知，这里 A 就是 X，B 就是 K，C 就是 pre。我们已知的是 X 和 pre，未知的是 K。求得 K 后，只要通过各个特征就能算出对应的 pre。</p><p><span class="math inline">\(delta\_k=\frac{\partial Loss}{\partial k}\)</span> 起始就是 <span class="math inline">\(\bigtriangledown K\)</span>，即可以用 <span class="math inline">\(\bigtriangledown K=X^T·G\)</span> 算得。这个式子中的 X 已知，G 可以用 <span class="math inline">\(G=\frac{\partial Loss}{\partial pre}\)</span> 求得。</p><p><code>G = 2 * (pre - y)</code> 中的常数 2 我们一般不要，因为最后它与 lr 进行相乘时，常数可能会导致梯度爆炸。因此可以用 <code>G = 2 * (pre - y)</code> ，但是为了更好地防止梯度爆炸，可以在后面除以 len (X)，计算出平均的梯度，因为 len (X) 是常数，所以对最后的结果准确性并没有影响。最后变成 <code>G= (pre - y)/len(X)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">file</span>):  </span><br><span class="line">    <span class="comment"># skiprows=1表示删除表头，names表示重新加上表头  </span></span><br><span class="line">    data = pd.read_csv(file,names=[<span class="string">&quot;y&quot;</span>,<span class="string">&quot;x1&quot;</span>,<span class="string">&quot;x2&quot;</span>,<span class="string">&quot;x3&quot;</span>,<span class="string">&quot;x4&quot;</span>,<span class="string">&quot;x5&quot;</span>,<span class="string">&quot;x6&quot;</span>],skiprows=<span class="number">1</span>)  </span><br><span class="line">    <span class="comment"># print(data)  </span></span><br><span class="line">  </span><br><span class="line">    y = data[<span class="string">&quot;y&quot;</span>].values.reshape(-<span class="number">1</span>,<span class="number">1</span>)     <span class="comment"># reshape(行数,列表)，-1表示不知道，1表示确定为1列。所以reshape(-1,1)表示变成1列数据  </span></span><br><span class="line">    mean_y = np.mean(y)      <span class="comment"># 求和取平均值  </span></span><br><span class="line">    std_y = np.std(y)        <span class="comment"># 求标准差，即方差开根。列表求方差，需要将每个数与平均值相减再平方，这些平方相加的结果就是方差。  </span></span><br><span class="line">    y = (y - mean_y) / std_y  </span><br><span class="line">    <span class="comment"># print(y)  </span></span><br><span class="line">  </span><br><span class="line">    x = data[[<span class="string">f&quot;x<span class="subst">&#123;i&#125;</span>&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">7</span>)]].values     <span class="comment"># values是直接将数据转化为numpy矩阵形式  </span></span><br><span class="line">    mean_x = np.mean(x,axis=<span class="number">0</span>,keepdims = <span class="literal">True</span>)    <span class="comment"># axis=0为纵向,axis=1为横向；keepidms=True表示保持其二维或者三维的特性(结果保持其原来维数)  </span></span><br><span class="line">    std_x = np.std(x,axis=<span class="number">0</span>,keepdims=<span class="literal">True</span>)  </span><br><span class="line">    x = (x - mean_x) / std_x  </span><br><span class="line">    <span class="comment"># print(x)  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> x,y,mean_y,std_y,mean_x,std_x  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    X,y,mean_y,std_y,mean_x,std_x = get_data(<span class="string">&quot;上海二手房价.csv&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    K = np.random.random((<span class="number">6</span>,<span class="number">1</span>))     <span class="comment"># 生成6行1列的浮点数，浮点数都是从0-1中随机,维度为2  </span></span><br><span class="line">  </span><br><span class="line">    epoch = <span class="number">10000</span>  </span><br><span class="line">    lr = <span class="number">0.001</span>  </span><br><span class="line">    b = <span class="number">1</span>      <span class="comment"># 偏置项  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        pre = X @ K      <span class="comment"># 270*6 @ 6*1 = 270*1  </span></span><br><span class="line">        <span class="comment"># print(pre)        loss = np.sum((pre-y)**2)/len(X)    # y是270*1  </span></span><br><span class="line">        <span class="built_in">print</span>(loss)  </span><br><span class="line">  </span><br><span class="line">        G = (pre - y)/<span class="built_in">len</span>(X)  </span><br><span class="line">        delta_k = X.T @ G  </span><br><span class="line">        delta_b = np.mean(G)         <span class="comment"># 偏置项求导就是G的求平均  </span></span><br><span class="line">  </span><br><span class="line">        K = K - lr * delta_k  </span><br><span class="line">        b = b - lr * delta_b  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        bedroom = (<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入卧室数量:&quot;</span>)))  </span><br><span class="line">        ting = (<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入客厅数量:&quot;</span>)))  </span><br><span class="line">        wei = (<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入卫生间数量:&quot;</span>)))  </span><br><span class="line">        area = (<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入面积:&quot;</span>)))  </span><br><span class="line">        floor = (<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入楼层:&quot;</span>)))  </span><br><span class="line">        year = (<span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入建成年份:&quot;</span>)))  </span><br><span class="line">  </span><br><span class="line">        test_x = (np.array([bedroom, ting, wei, area, floor, year]).reshape(<span class="number">1</span>, -<span class="number">1</span>) - mean_x) / std_x  </span><br><span class="line">  </span><br><span class="line">        p = test_x @ K + b  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;房价为: &quot;</span>, p * std_y + mean_y)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />……<br />0.9240587745570578<br />0.9240567410064711<br />0.9240547079709156<br />0.9240526754502584<br />0.9240506434443663<br />0.9240486119531061<br />0.9240465809763451<br />0.9240445505139503<br />请输入卧室数量: 2<br />请输入客厅数量: 1<br />请输入卫生间数量: 1<br />请输入面积: 80<br />请输入楼层: 4<br />请输入建成年份: 2010<br />房价为: [[76331.47770039]]</p></blockquote><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=20&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/4_%E7%9F%A9%E9%98%B5_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（3）</title>
      <link href="/2023/02/21/3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2023/02/21/3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>模拟 <span class="math inline">\(f = kx + b\)</span>，其中 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(x\)</span> 是已知，<span class="math inline">\(k\)</span> 和 <span class="math inline">\(b\)</span> 是未知。就是利用历史数据训练出 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(b\)</span> ，在未来给出 <span class="math inline">\(x\)</span> 就能直接解出 <span class="math inline">\(y\)</span>。</p><p>线性回归智能确定一条直线 ，不适用于波动很大的情况。</p><blockquote><p><strong>公式：</strong></p><p><span class="math display">\[pre = kx+ b\]</span> <span class="math display">\[Loss=(pre-Label)^2=(kx+b-Label)^2\]</span> <span class="math display">\[{ \frac{\partial Loss} {\partial k} }=2 * (kx+b-Label) * x\]</span> <span class="math display">\[{ \frac{\partial Loss} {\partial b} }=2*(kx+b-Label)\]</span></p><p><strong>更新公式：</strong></p><p><span class="math display">\[k=k-\frac{\partial Loss} {\partial k}*lr\]</span> <span class="math display">\[b=b-\frac{\partial Loss} {\partial b}*lr\]</span></p></blockquote><p>不断循环上述公式，得到稳定的 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(b\)</span>。</p><h1 id="复现">复现</h1><h2 id="理解">理解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 对数据进行归一化（都初一最大的值），否则学习率必须非常小才能保证不越界  </span></span><br><span class="line">years = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>,<span class="number">2022</span>)])/<span class="number">2022</span> <span class="comment"># 年份 2000 ~ 2021</span></span><br><span class="line">prices = np.array([<span class="number">10000</span>,<span class="number">11000</span>,<span class="number">12000</span>,<span class="number">13000</span>,<span class="number">14000</span>,<span class="number">12000</span>,<span class="number">13000</span>,<span class="number">16000</span>,<span class="number">18000</span>,<span class="number">20000</span>,<span class="number">19000</span>,<span class="number">22000</span>,<span class="number">24000</span>,<span class="number">23000</span>,<span class="number">26000</span>,<span class="number">35000</span>,<span class="number">30000</span>,<span class="number">40000</span>,<span class="number">45000</span>,<span class="number">52000</span>,<span class="number">50000</span>,<span class="number">60000</span>])/<span class="number">60000</span>  </span><br><span class="line">  </span><br><span class="line">epoch = <span class="number">100000</span>  </span><br><span class="line">k = <span class="number">1</span>  </span><br><span class="line">b = <span class="number">1</span>  </span><br><span class="line">lr = <span class="number">0.1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">    <span class="keyword">for</span> x,label <span class="keyword">in</span> <span class="built_in">zip</span>(years,prices):  </span><br><span class="line">        pre = k * x + b  </span><br><span class="line">        loss = (pre - label) ** <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">        delta_k = <span class="number">2</span> * (k * x + b - label) * x  </span><br><span class="line">        delta_b = <span class="number">2</span> * (k * x + b - label)  </span><br><span class="line">  </span><br><span class="line">        k = k - delta_k * lr  </span><br><span class="line">        b = b - delta_b * lr  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;k=<span class="subst">&#123;k&#125;</span>,b=<span class="subst">&#123;b&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    year = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年份：&quot;</span>)) / <span class="number">2022</span>    <span class="comment"># 将数据恢复  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;预测房价：&quot;</span>, (k * year +b) * <span class="number">60000</span>)     <span class="comment"># 将数据恢复</span></span><br></pre></td></tr></table></figure><blockquote><p>输出： k=11.583227003108236, b=-10.707528453584919<br />请输入年份：2022<br />预测房价： 52541.91297139904<br />请输入年份：2023<br />预测房价： 52885.62890620945</p></blockquote><p>但是年份在归一化时因为除以 2022 导致数据都是 0.9……，差距很小，所以在有限的 epoch 中无法很好地预估。</p><p>将 <code>years/2022</code> 变成 <code>years = (years-2000)/22</code>，可以将数据先进行均匀分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 对数据进行归一化（都初一最大的值），否则学习率必须非常小才能保证不越界  </span></span><br><span class="line">years = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>,<span class="number">2022</span>)]) <span class="comment"># 年份 2000 ~ 2021</span></span><br><span class="line">years = (years-<span class="number">2000</span>)/<span class="number">22</span>  </span><br><span class="line">prices = np.array([<span class="number">10000</span>,<span class="number">11000</span>,<span class="number">12000</span>,<span class="number">13000</span>,<span class="number">14000</span>,<span class="number">12000</span>,<span class="number">13000</span>,<span class="number">16000</span>,<span class="number">18000</span>,<span class="number">20000</span>,<span class="number">19000</span>,<span class="number">22000</span>,<span class="number">24000</span>,<span class="number">23000</span>,<span class="number">26000</span>,<span class="number">35000</span>,<span class="number">30000</span>,<span class="number">40000</span>,<span class="number">45000</span>,<span class="number">52000</span>,<span class="number">50000</span>,<span class="number">60000</span>])/<span class="number">60000</span>  </span><br><span class="line">  </span><br><span class="line">epoch = <span class="number">10000</span>  </span><br><span class="line">  </span><br><span class="line">k = <span class="number">1</span>  </span><br><span class="line">b = <span class="number">1</span>  </span><br><span class="line">lr = <span class="number">0.1</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">    <span class="keyword">for</span> x,label <span class="keyword">in</span> <span class="built_in">zip</span>(years,prices):  </span><br><span class="line">        pre = k * x + b  </span><br><span class="line">        loss = (pre - label) ** <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">        delta_k = <span class="number">2</span> * (k * x + b - label) * x  </span><br><span class="line">        delta_b = <span class="number">2</span> * (k * x + b - label)  </span><br><span class="line">  </span><br><span class="line">        k = k - delta_k * lr  </span><br><span class="line">        b = b - delta_b * lr  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;k=<span class="subst">&#123;k&#125;</span>,b=<span class="subst">&#123;b&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">    year = (<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年份：&quot;</span>)) - <span class="number">2000</span>)/<span class="number">22</span>    <span class="comment"># 将数据恢复  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;预测房价：&quot;</span>, (k * year +b) * <span class="number">60000</span>)     <span class="comment"># 将数据恢复</span></span><br></pre></td></tr></table></figure><blockquote><p>输出： k=0.9958495409320027, b=-0.029087073213425022<br />请输入年份：2022<br />预测房价： 58005.74806311466<br />请输入年份：2035<br />预测房价： 93313.14087797658</p></blockquote><h2 id="利用-datasetdataloader-整合">利用 dataset+dataloader 整合</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSet</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,years,prices,k,b,lr,batch_size,shuffle=<span class="literal">True</span></span>):  </span><br><span class="line">        self.years = years  </span><br><span class="line">        self.prices = prices  </span><br><span class="line">        self.k = k  </span><br><span class="line">        self.b = b  </span><br><span class="line">        self.lr = lr  </span><br><span class="line">        self.batch_size = batch_size  </span><br><span class="line">        self.shuffle = shuffle  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> DataLoader(self)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(years)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataLoader</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,dataset</span>):  </span><br><span class="line">        self.dataset = dataset  </span><br><span class="line">        self.cursor = <span class="number">0</span>  </span><br><span class="line">        self.index = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.dataset))]  </span><br><span class="line">        <span class="keyword">if</span> self.dataset.shuffle==<span class="literal">True</span>:  </span><br><span class="line">            np.random.shuffle(self.index)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">if</span> self.cursor &gt;= <span class="built_in">len</span>(self.dataset):  </span><br><span class="line">            <span class="keyword">raise</span> StopIteration  </span><br><span class="line">  </span><br><span class="line">        ind = self.index[self.cursor : self.cursor+self.dataset.batch_size]  </span><br><span class="line">        x = self.dataset.years[ind]  </span><br><span class="line">        y = self.dataset.prices[ind]  </span><br><span class="line">        self.cursor += self.dataset.batch_size  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> x, y  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">  </span><br><span class="line">    epoch = <span class="number">10000</span>  </span><br><span class="line">    k = <span class="number">1</span>  </span><br><span class="line">    b = <span class="number">1</span>  </span><br><span class="line">    lr = <span class="number">0.1</span>  </span><br><span class="line">    batch_size = <span class="number">2</span>  </span><br><span class="line">    shuffle = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">    years = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>, <span class="number">2022</span>)])  </span><br><span class="line">    years = (years - <span class="number">2000</span>) / <span class="number">22</span>  </span><br><span class="line">    prices = np.array(  </span><br><span class="line">        [<span class="number">10000</span>, <span class="number">11000</span>, <span class="number">12000</span>, <span class="number">13000</span>, <span class="number">14000</span>, <span class="number">12000</span>, <span class="number">13000</span>, <span class="number">16000</span>, <span class="number">18000</span>, <span class="number">20000</span>, <span class="number">19000</span>, <span class="number">22000</span>, <span class="number">24000</span>, <span class="number">23000</span>, <span class="number">26000</span>, <span class="number">35000</span>,  </span><br><span class="line">         <span class="number">30000</span>, <span class="number">40000</span>, <span class="number">45000</span>, <span class="number">52000</span>, <span class="number">50000</span>, <span class="number">60000</span>]) / <span class="number">60000</span>  </span><br><span class="line">  </span><br><span class="line">    dataset = DataSet(years,prices,k,b,lr,batch_size,shuffle)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> year,price <span class="keyword">in</span> dataset:  </span><br><span class="line">  </span><br><span class="line">            predict = k * year + b  </span><br><span class="line">            loss = (predict - price) ** <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line">            delta_k = <span class="number">2</span> * (k * year + b - price) * year  </span><br><span class="line">            delta_b = <span class="number">2</span> * (k * year + b - price)  </span><br><span class="line">  </span><br><span class="line">            k = k - np.<span class="built_in">sum</span>(delta_k) * lr  </span><br><span class="line">            b = b - np.<span class="built_in">sum</span>(delta_b) * lr  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;k=<span class="subst">&#123;k&#125;</span>,b=<span class="subst">&#123;b&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        year = (<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年份：&quot;</span>)) - <span class="number">2000</span>)/<span class="number">22</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;预测房价：&quot;</span>, (k * year +b) * <span class="number">60000</span>)</span><br></pre></td></tr></table></figure><blockquote><p>输出： k=0.7869334616968109, b=0.0493809221566964<br />请输入年份：2023<br />预测房价： 52325.04519947447<br />请输入年份：2035<br />预测房价： 78079.23121864282</p></blockquote><h2 id="多特征">多特征</h2><p>模拟 <span class="math inline">\(f = ax + by + c\)</span>，即在上面的例题中增加楼层变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataSet</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,years,floors,prices,lr,batch_size,shuffle=<span class="literal">True</span></span>):  </span><br><span class="line">        self.years = years  </span><br><span class="line">        self.floors = floors  </span><br><span class="line">        self.prices = prices  </span><br><span class="line">        self.lr = lr  </span><br><span class="line">        self.batch_size = batch_size  </span><br><span class="line">        self.shuffle = shuffle  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> DataLoader(self)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.years)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataLoader</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,dataset</span>):  </span><br><span class="line">        self.dataset = dataset  </span><br><span class="line">        self.cursor = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">        self.index = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.dataset))]  </span><br><span class="line">        <span class="keyword">if</span> self.dataset.shuffle:  </span><br><span class="line">            np.random.shuffle(self.index)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">if</span> self.cursor &gt;= <span class="built_in">len</span>(self.dataset):  </span><br><span class="line">            <span class="keyword">raise</span> StopIteration  </span><br><span class="line">  </span><br><span class="line">        ind = self.index[self.cursor : self.cursor+self.dataset.batch_size]  </span><br><span class="line">        x = self.dataset.years[ind]  </span><br><span class="line">        y = self.dataset.floors[ind]  </span><br><span class="line">        z = self.dataset.prices[ind]  </span><br><span class="line">        self.cursor += self.dataset.batch_size  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> x, y, z  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">  </span><br><span class="line">    a = <span class="number">1</span>  </span><br><span class="line">    b = -<span class="number">1</span>  </span><br><span class="line">    c = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line">    epoch = <span class="number">10000</span>  </span><br><span class="line">    batch_size = <span class="number">2</span>  </span><br><span class="line">    lr = <span class="number">0.1</span>  </span><br><span class="line">    shuffle = <span class="literal">True</span>  </span><br><span class="line">  </span><br><span class="line">    years = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2000</span>, <span class="number">2022</span>)])  </span><br><span class="line">    years = (years - <span class="number">2000</span>) / <span class="number">22</span>  </span><br><span class="line">  </span><br><span class="line">    floors = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>, <span class="number">1</span>, -<span class="number">1</span>)])  </span><br><span class="line">    floors = floors / <span class="number">23</span>  </span><br><span class="line">  </span><br><span class="line">    prices = np.array(  </span><br><span class="line">        [<span class="number">10000</span>, <span class="number">11000</span>, <span class="number">12000</span>, <span class="number">13000</span>, <span class="number">14000</span>, <span class="number">12000</span>, <span class="number">13000</span>, <span class="number">16000</span>, <span class="number">18000</span>, <span class="number">20000</span>, <span class="number">19000</span>, <span class="number">22000</span>, <span class="number">24000</span>, <span class="number">23000</span>, <span class="number">26000</span>, <span class="number">35000</span>,  </span><br><span class="line">         <span class="number">30000</span>, <span class="number">40000</span>, <span class="number">45000</span>, <span class="number">52000</span>, <span class="number">50000</span>, <span class="number">60000</span>])  </span><br><span class="line">    prices = prices / <span class="number">60000</span>  </span><br><span class="line">  </span><br><span class="line">    dataset = DataSet(years,floors,prices,lr,batch_size,shuffle)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">range</span>(epoch):  </span><br><span class="line">        <span class="keyword">for</span> year,floor,price <span class="keyword">in</span> dataset:  </span><br><span class="line">  </span><br><span class="line">            predict = a * year + b * floor + c  </span><br><span class="line">            loss = np.<span class="built_in">sum</span>((predict - price) ** <span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">            delta_a = <span class="number">2</span> * (predict - price) * year  </span><br><span class="line">            delta_b = <span class="number">2</span> * (predict - price) * floor  </span><br><span class="line">            delta_c = <span class="number">2</span> * (predict - price)  </span><br><span class="line">  </span><br><span class="line">            a = a - np.<span class="built_in">sum</span>(delta_a) * lr  </span><br><span class="line">            b = b - np.<span class="built_in">sum</span>(delta_b) * lr  </span><br><span class="line">            c = c - np.<span class="built_in">sum</span>(delta_c) * lr  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;k=<span class="subst">&#123;a&#125;</span>,b=<span class="subst">&#123;b&#125;</span>,c=<span class="subst">&#123;c&#125;</span>&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  </span><br><span class="line">        year = (<span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入年份：&quot;</span>)) - <span class="number">2000</span>)/<span class="number">22</span>  </span><br><span class="line">        floor = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入楼层：&quot;</span>)) / <span class="number">23</span>  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;预测房价：&quot;</span>, (a * year +b * floor + c) * <span class="number">60000</span>)</span><br></pre></td></tr></table></figure><blockquote><p>输出： k=0.535609459528955, b=-0.2391682413913525, c=0.31663211120152795<br />请输入年份：2023<br />请输入楼层：1<br />预测房价： 51971.33016381589<br />请输入年份：2035<br />请输入楼层：5<br />预测房价： 67004.69841530433</p></blockquote><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=13&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/3_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（2）</title>
      <link href="/2023/02/20/2-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
      <url>/2023/02/20/2-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实例：求解 <span class="math inline">\((x-2)^2=0\)</span></p></blockquote><h1 id="前言">前言</h1><p>面临的两个问题： 1. 往上猜？往下猜？ 2. 大多少？小多少？</p><p>真值 Label、预测值 pre、输入 input的实例看下图：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302202228681.png" /></p><p>Loss：损失，是用来衡量真值和预测值之间的差距，从而确定下一次输入值的大小和方向。用于计算损失的函数叫做<strong>损失函数</strong>。</p><h1 id="均方差损失-mse-loss">均方差损失 MSE Loss</h1><p>利用两个值之间的差的平方来表示两个值之间的差距：<span class="math inline">\((x-y)^2\)</span></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302202245453.png" /></p><h1 id="学习率-lr">学习率 lr</h1><p>学习率一般取值在 0~1，用来影响梯度下降对输入的改变</p><h1 id="复现">复现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from tqdm <span class="keyword">import</span> trange     # 显示进度条  </span><br><span class="line">  </span><br><span class="line">epoch = <span class="number">10000</span>  </span><br><span class="line">lr = <span class="number">0.05</span>  </span><br><span class="line">x = <span class="number">3</span>    # 初始值  </span><br><span class="line">label = <span class="number">0</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> e in <span class="title function_">trange</span><span class="params">(epoch)</span>:  </span><br><span class="line">    pre = (x-<span class="number">2</span>) ** <span class="number">2</span>  </span><br><span class="line">    loss = (pre-label) ** <span class="number">2</span>  </span><br><span class="line">    delta_x = <span class="number">2</span> * (pre-label)*(x-<span class="number">2</span>)  </span><br><span class="line">    x = x - delta_x * lr  </span><br><span class="line">  </span><br><span class="line"><span class="title function_">print</span><span class="params">(x)</span></span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />100%|██████████| 10000/10000 [ 00:00 &lt; 00:00 , 994830.29it/s]<br />2.0223486461768205</p></blockquote><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=7&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a> <a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/2_%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP基础系列（1）</title>
      <link href="/2023/02/20/1-DataSet-DataLoader/"/>
      <url>/2023/02/20/1-DataSet-DataLoader/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下回答来自 ChatGPT</p><p>在深度学习中，Dataset 和 DataLoader 是两个常用的概念，用于将数据加载到模型中进行训练。Dataset 用于加载数据，并将数据转换为模型可以使用的形式；DataLoader 用于批量加载数据，并进行数据增强、shuffle 等操作。下面分别介绍一下它们的作用。</p><p><strong>Dataset</strong> Dataset 是 PyTorch 中用于加载数据的类，它继承自 torch. utils. data. Dataset。 在自定义 Dataset 时，需要实现<code>__len__</code>和<code>__getitem__</code>方法。其中<code>__len__</code>方法用于返回数据集的长度，<code>__getitem__</code>方法用于返回数据集中指定索引的数据。 在自定义 Dataset 时，可以根据实际需求对数据进行预处理、转换格式等操作，以适应模型的输入要求。Dataset 的一个常见应用是对图像进行数据增强，包括随机裁剪、随机翻转、调整亮度对比度等操作。可以使用 torchvision. transforms 中的函数实现数据增强。</p><p><strong>DataLoader</strong> DataLoader 是 PyTorch 中用于批量加载数据的类，它继承自 torch. utils. data. DataLoader。使用 DataLoader 可以将 Dataset 中的数据进行批量加载，并进行 shuffle、数据增强等操作。DataLoader 还可以设置多线程加载数据，以加快数据加载速度。 在使用 DataLoader 时，需要指定 <code>batch_size</code>、<code>shuffle</code> 等参数。<code>batch_size</code> 指定每个 batch 中的样本数量，<code>shuffle</code> 指定是否随机打乱数据。可以使用 DataLoader 加载自定义的 Dataset，也可以使用 torchvision. datasets 中提供的常见数据集，如 MNIST、CIFAR 等。 通常情况下，我们使用 DataLoader 来将数据分成若干个 batch，然后将每个 batch 的数据输入模型中进行训练，以提高训练效率。</p></blockquote><p><code>dataset</code> 是数据集 <code>dataloader</code> 是数据加载</p><h1 id="前言">前言</h1><h2 id="batch_size">batch_size</h2><p>下面例子直观感受 batch_size 的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]     # 所有数据，<span class="type">dataset</span>  </span><br><span class="line">  </span><br><span class="line"><span class="variable">batch_size</span> <span class="operator">=</span> <span class="number">2</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">0</span>,len(list)</span>,batch_size):      # 数据加载过程，<span class="type">dataloader</span>  </span><br><span class="line">    <span class="variable">batch_data</span> <span class="operator">=</span> list[i:i+batch_size]  </span><br><span class="line">    print(batch_data)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />[1, 2]<br />[3, 4]<br />[5, 6]<br />[7]</p></blockquote><h2 id="epochshuffle">epoch、shuffle</h2><p>epoch 表示轮次，shuffle 表示是否打乱数据，下面给出例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">random</span>  </span><br><span class="line">  </span><br><span class="line"><span class="variable">list</span> <span class="operator">=</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]     #所有数据，<span class="type">dataset</span>  </span><br><span class="line">  </span><br><span class="line"><span class="variable">batch_size</span> <span class="operator">=</span> <span class="number">2</span>  </span><br><span class="line">epoch = <span class="number">3</span>     # 轮次  </span><br><span class="line">shuffle = True    # 是否打乱  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> e in <span class="title function_">range</span><span class="params">(epoch)</span>:  </span><br><span class="line">    <span class="keyword">if</span> shuffle:  </span><br><span class="line">        random.shuffle(list)  </span><br><span class="line">    print(list)  </span><br><span class="line">    <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(<span class="number">0</span>,len(list)</span>,batch_size):      #数据加载过程，<span class="type">dataloader</span>  </span><br><span class="line">        <span class="variable">batch_data</span> <span class="operator">=</span> list[i:i+batch_size]  </span><br><span class="line">        print(batch_data)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />[5, 7, 6, 4, 3, 1, 2]<br />[5, 7]<br />[6, 4]<br />[3, 1]<br />[2]<br />[7, 6, 3, 4, 5, 2, 1]<br />[7, 6]<br />[3, 4]<br />[5, 2]<br />[1]<br />[1, 7, 4, 6, 3, 5, 2]<br />[1, 7]<br />[4, 6]<br />[3, 5]<br />[2]</p></blockquote><h1 id="复现">复现</h1><h2 id="dataset">DataSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataset</span>:  </span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,all_data,batch_size,shuffle=True)</span>:  </span><br><span class="line">        self.all_data = all_data  </span><br><span class="line">        self.batch_size = batch_size  </span><br><span class="line">        self.shuffle = shuffle  </span><br><span class="line">  </span><br><span class="line">        self.cursor = <span class="number">0</span>      # 左边界  </span><br><span class="line">  </span><br><span class="line">    # 魔术方法（特定条件下自动触发的函数）  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__iter__</span><span class="params">(self)</span>:   # 只有第一次会触发，所以需要返回一个具有__next__的对象  </span><br><span class="line">        print(<span class="string">&quot;======hello _iter_======&quot;</span>)  </span><br><span class="line">        <span class="keyword">if</span> self.shuffle:  </span><br><span class="line">            random.shuffle(self.all_data)  </span><br><span class="line">        self.cursor = <span class="number">0</span>    # 游标重置  </span><br><span class="line">        <span class="keyword">return</span> self  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__next__</span><span class="params">(self)</span>:  </span><br><span class="line">        <span class="keyword">if</span> self.cursor &gt;= len(self.all_data):  </span><br><span class="line">            raise <span class="type">StopIteration</span>  </span><br><span class="line">        <span class="variable">batch_data</span> <span class="operator">=</span> self.all_data[self.cursor : self.cursor+self.batch_size]  </span><br><span class="line">        self.cursor += self.batch_size  </span><br><span class="line">        <span class="keyword">return</span> batch_data  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    all_data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line">    batch_size = <span class="number">2</span>  </span><br><span class="line">    epoch = <span class="number">3</span>  </span><br><span class="line">    shuffle = <span class="type">True</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">dataset</span> <span class="operator">=</span> MyDataset(all_data,batch_size,shuffle)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e in <span class="title function_">range</span><span class="params">(epoch)</span>:  </span><br><span class="line">    # 把一个对象放在<span class="keyword">for</span>上时，会自动调用这个对象的__iter__,但只会在第一个循环触发  </span><br><span class="line">        <span class="keyword">for</span> batch_data in dataset:  </span><br><span class="line">            print(batch_data)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />======hello _iter_======<br />[5, 1]<br />[6, 3]<br />[2, 7]<br />[4]<br />======hello _iter_======<br />[6, 3]<br />[5, 4]<br />[7, 2]<br />[1]<br />======hello _iter_======<br />[1, 2]<br />[6, 5]<br />[3, 7]<br />[4]</p></blockquote><h2 id="dataloader">DataLoader</h2><p>dataloader 主要用于加载数据，所以上面写的 dataset 的__next__的功能实际上时 dataloader 做的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataSet</span>:  </span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self, all_data, batch_size, shuffle=True)</span>:  </span><br><span class="line">        self.all_data = all_data  </span><br><span class="line">        self.batch_size = batch_size  </span><br><span class="line">        self.shuffle = shuffle  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__iter__</span><span class="params">(self)</span>:  # 只有第一次会触发  </span><br><span class="line">        print(<span class="string">&quot;======hello _iter_======&quot;</span>)  </span><br><span class="line">        <span class="keyword">if</span> self.shuffle:  </span><br><span class="line">            random.shuffle(self.all_data)  # random在数据量很多时复杂度很高  </span><br><span class="line">        <span class="keyword">return</span> DataLoader(self)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataLoader</span>:  </span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self, dataset)</span>:  </span><br><span class="line">        self.dataset = dataset  </span><br><span class="line">        self.cursor = <span class="number">0</span>  # 左边界  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__next__</span><span class="params">(self)</span>:  </span><br><span class="line">        <span class="keyword">if</span> self.cursor &gt;= len(self.dataset.all_data):  </span><br><span class="line">            raise <span class="type">StopIteration</span>  </span><br><span class="line">        <span class="variable">batch_data</span> <span class="operator">=</span> self.dataset.all_data[self.cursor: self.cursor + self.dataset.batch_size]  </span><br><span class="line">        self.cursor += self.dataset.batch_size  </span><br><span class="line">        <span class="keyword">return</span> batch_data  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    all_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]  </span><br><span class="line">    batch_size = <span class="number">2</span>  </span><br><span class="line">    epoch = <span class="number">3</span>  </span><br><span class="line">    shuffle = <span class="type">True</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">dataset</span> <span class="operator">=</span> MyDataSet(all_data, batch_size, shuffle)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e in <span class="title function_">range</span><span class="params">(epoch)</span>:  </span><br><span class="line">        <span class="keyword">for</span> batch_data in dataset:  </span><br><span class="line">            print(batch_data)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />======hello _iter_======<br />[6, 4]<br />[3, 5]<br />[2, 7]<br />[1]<br />======hello _iter_======<br />[7, 1]<br />[5, 2]<br />[6, 3]<br />[4]<br />======hello _iter_======<br />[5, 6]<br />[4, 2]<br />[1, 7]<br />[3]</p></blockquote><p>这里 shuffle 打乱数据是利用 random 进行的，在数据较少时可以，但是面对深度学习的超大数据时有着很高的复杂度。解决的思路是：<strong>不打乱数据，打乱索引。</strong></p><h2 id="优化">优化</h2><p>shuffle 利用打乱索引实现：在 22 行中先构建了一个索引 list，再利用 np. random. shuffle 对这个 list 进行打乱，循环时只需要每次再这个索引 list 中选取 batch_size 个数据，再在原来的 all_data 中找到对应数据即可。</p><p><code>batch_data = self. dataset. all_data[ind]</code> 可以看出，在 python 中，下标可以是一个 list，返回的结果也是一个 list。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyDataSet</span>:  </span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,all_data,batch_size,shuffle=True)</span>:  </span><br><span class="line">        self.all_data = all_data  </span><br><span class="line">        self.batch_size = batch_size  </span><br><span class="line">        self.shuffle = shuffle  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__iter__</span><span class="params">(self)</span>:   # 只有第一次会触发 </span><br><span class="line">        print(<span class="string">&quot;======hello _iter_======&quot;</span>)  </span><br><span class="line">        <span class="keyword">return</span> DataLoader(self)  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__len__</span><span class="params">(self)</span>:  </span><br><span class="line">        <span class="keyword">return</span> len(self.all_data)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataLoader</span>:  </span><br><span class="line">    def <span class="title function_">__init__</span><span class="params">(self,dataset)</span>:  </span><br><span class="line">        self.dataset = dataset  </span><br><span class="line">        self.cursor = <span class="number">0</span>     # 左边界  </span><br><span class="line">        </span><br><span class="line">        self.index = [i <span class="keyword">for</span> i in <span class="title function_">range</span><span class="params">(len(self.dataset)</span>)]  </span><br><span class="line">        <span class="keyword">if</span> self.dataset.shuffle == True:  </span><br><span class="line">            np.random.shuffle(self.index)  </span><br><span class="line">  </span><br><span class="line">    def <span class="title function_">__next__</span><span class="params">(self)</span>:  </span><br><span class="line">        <span class="keyword">if</span> self.cursor &gt;= len(self.dataset.all_data):  </span><br><span class="line">            raise <span class="type">StopIteration</span>  </span><br><span class="line">        <span class="variable">ind</span> <span class="operator">=</span> self.index[self.cursor : self.cursor+self.dataset.batch_size]      # ind是个列表  </span><br><span class="line">        batch_data = self.dataset.all_data[ind]      # batch_data也是list </span><br><span class="line">        self.cursor += self.dataset.batch_size  </span><br><span class="line">        <span class="keyword">return</span> batch_data  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    all_data = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>])  </span><br><span class="line">    batch_size = <span class="number">2</span>  </span><br><span class="line">    epoch = <span class="number">3</span>  </span><br><span class="line">    shuffle = <span class="type">True</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="variable">dataset</span> <span class="operator">=</span> MyDataSet(all_data,batch_size,shuffle)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> e in <span class="title function_">range</span><span class="params">(epoch)</span>:  </span><br><span class="line">        <span class="keyword">for</span> batch_data in dataset:  </span><br><span class="line">            print(batch_data)</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br />======hello _iter_======<br />[3 1]<br />[5 7]<br />[4 2]<br />[6]<br />======hello _iter_======<br />[1 3]<br />[7 5]<br />[2 6]<br />[4]<br />======hello _iter_======<br />[2 4]<br />[1 6]<br />[7 5]<br />[3]</p></blockquote><h1 id="相关链接">相关链接</h1><p><a href="https://www.bilibili.com/video/BV1j3411t7VM?p=2&amp;vd_source=ec8fb32942c22665057156952ef080c7">bilibili</a><br /><a href="https://github.com/shouxieai/A-series-of-NLP/tree/main/NLP_%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B/1_dataset_dataloader">GitHub</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swagger3.0配置</title>
      <link href="/2023/02/17/springboot2-7-swagger3-0/"/>
      <url>/2023/02/17/springboot2-7-swagger3-0/</url>
      
        <content type="html"><![CDATA[<h1 id="引入依赖">引入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--ui插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="添加配置">添加配置</h1><p>在项目下建立 config/<code>Swaggerconfig</code> 文件</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302172216467.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.neo4j_test.config;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;  </span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.ApiInfoBuilder;  </span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.PathSelectors;  </span><br><span class="line"><span class="keyword">import</span> springfox.documentation.builders.RequestHandlerSelectors;  </span><br><span class="line"><span class="keyword">import</span> springfox.documentation.service.ApiInfo;  </span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spi.DocumentationType;  </span><br><span class="line"><span class="keyword">import</span> springfox.documentation.spring.web.plugins.Docket;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">docket</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">ApiInfoBuilder</span> <span class="variable">apiInfoBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>();  </span><br><span class="line">        apiInfoBuilder  </span><br><span class="line">                .title(<span class="string">&quot;neo4j接口测试&quot;</span>)  </span><br><span class="line">                .description(<span class="string">&quot;swagger测试接口&quot;</span>)  </span><br><span class="line">                .version(<span class="string">&quot;v1.0.0&quot;</span>);  </span><br><span class="line">        <span class="type">ApiInfo</span> <span class="variable">apiInfo</span> <span class="operator">=</span> apiInfoBuilder.build();  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.OAS_30)  </span><br><span class="line">                .apiInfo(apiInfo)  </span><br><span class="line">                .select()  </span><br><span class="line">                .apis(RequestHandlerSelectors.any())  </span><br><span class="line">                .paths(PathSelectors.any())  </span><br><span class="line">                .build();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="配置-application.-properties">配置 application. properties</h1><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.mvc.pathmatch.matching-strategy</span>=<span class="string">ant_path_matcher</span></span><br></pre></td></tr></table></figure><h1 id="运行-springboot-项目">运行 springboot 项目</h1><p>点击进入： http://localhost:8080/doc.html</p><h1 id="api-ui-优化">api ui 优化</h1><p>swagger 提供了⼀套注解，可以对每个接⼝进⾏详细说明</p><p><code>@Api</code> 类注解，在控制器类添加此注解，可以对控制器类进⾏功能说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api(value=&quot;提供知识图谱中用户的基本操作&quot;,tags = &quot;用户管理&quot;)</span></span><br></pre></td></tr></table></figure><blockquote><p>参考文档： <a href="https://www.cnblogs.com/Subaru/p/16478402.html">Springboot2.7整合Swagger3 - 菜月昴 - 博客园</a> <a href="https://blog.csdn.net/hundan_520520/article/details/103905103">swagger-bootstrap-ui 介绍和使用_hundan_520520的博客-CSDN博客</a> <a href="https://doc.xiaominfo.com/docs/quick-start">快速开始 | Knife4j</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Bing申请方法</title>
      <link href="/2023/02/17/%E7%94%B3%E8%AF%B7%E6%96%B9%E6%B3%95/"/>
      <url>/2023/02/17/%E7%94%B3%E8%AF%B7%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>NewBing 是基于 ChatGPT4.0 构建的强大的搜索引擎，这里给出申请的网页链接：<a href="https://www.bing.com/new">搜索</a></p></blockquote><p>点击进入 <strong>加入候补名单</strong></p><p>如果直接跳转到 bing 搜索页面则表示对当前用户进行屏蔽，需要进行以下操作。</p><h1 id="配置介绍">配置介绍</h1><p>进入扩展页面</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170940862.png" /></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170940315.png" /></p><p>下载第二个 <code>Header Editor</code>。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170941105.png" /></p><p>点击进行配置（管理）</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170942917.png" /></p><p>点击"+"创建</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170942007.png" /></p><p>编辑参数并保存</p><blockquote><p>匹配规则：<code>^http(s?)://(.*).bing\.com/(.*)</code> 头名称：<code>x-forwarded-for</code> 头内容：<code>8.8.8.8</code></p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170943323.png" /></p><p>再次点击刚刚的链接，重新点击<strong>加入候补名单</strong></p><p>进行申请候补，一段时间后通过候补就可以使用了~</p><h1 id="tips">tips</h1><p>如果上面操作之后点击<strong>加入候补名单</strong>还是直接跳转到搜索页面，需要清除 cookie，下面介绍清除 cookie 的方法：</p><p>在刚刚下载扩展的地方下载 <code>cookie editor</code></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170949098.png" /></p><p>点击删除 cookie 即可成功</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302170949070.png" /></p><h1 id="申请成功">申请成功</h1><p>一周之后，收到成功邮件~</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241350535.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 骚操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 骚操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bert本地下载</title>
      <link href="/2023/02/14/Bert%E6%9C%AC%E5%9C%B0%E4%B8%8B%E8%BD%BD/"/>
      <url>/2023/02/14/Bert%E6%9C%AC%E5%9C%B0%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="下载方法-1">下载方法 1</h1><blockquote><p>下载链接：<a href="https://huggingface.co/models">Models - Hugging Face</a></p></blockquote><p>输入想要下载的 bert 模型名称（比如我这里输入 <code>bert-base-uncased</code>）</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302141456055.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>如果使用 pytorch 版本的 BERT，下载这三个即可。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302141507097.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>放在一个文件夹下即可</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302141510619.png" /></p><h1 id="下载方法-2">下载方法 2</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PRETRAINED_MODEL_ARCHIVE_MAP = &#123;  </span><br><span class="line"><span class="string">&#x27;[bert-base-uncased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased.tar.gz&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-large-uncased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased.tar.gz&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-cased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased.tar.gz&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-multilingual&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual.tar.gz&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-chinese&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese.tar.gz&quot;</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PRETRAINED_VOCAB_ARCHIVE_MAP = &#123;  </span><br><span class="line"><span class="string">&#x27;bert-base-uncased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-vocab.txt&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-large-uncased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-uncased-vocab.txt&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-cased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-cased-vocab.txt&quot;</span>,  </span><br><span class="line"> <span class="string">&#x27;bert-large-cased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-large-cased-vocab.txt&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-multilingual-uncased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-uncased-vocab.txt&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-multilingual-cased&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-multilingual-cased-vocab.txt&quot;</span>,  </span><br><span class="line"><span class="string">&#x27;bert-base-chinese&#x27;</span>: <span class="string">&quot;https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-chinese-vocab.txt&quot;</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这里我需要下载 <code>bert-base-uncased</code>，直接输入<a href="https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased.tar.gz">下载链接</a> 和 <a href="https://s3.amazonaws.com/models.huggingface.co/bert/bert-base-uncased-vocab.txt">vocab.txt下载链接</a> （vocab 可能需要方法 1 才能下载）即可。</p><p>第一个链接解压后：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302141516809.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP——BERT</title>
      <link href="/2023/02/14/BERT/"/>
      <url>/2023/02/14/BERT/</url>
      
        <content type="html"><![CDATA[<blockquote><p>BERT 是用来预训练 Transformer 模型的</p></blockquote><ol type="1"><li>随机遮挡一个或多个单词，让 Encoder 预测被遮挡的单词</li><li>把两句话放在一起，让 Encoder 判断是不是在原文中相邻的两句话</li></ol><h1 id="task1预测被遮挡的单词">Task1、预测被遮挡的单词</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131709882.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="task2预测下一个句子">Task2、预测下一个句子</h1><p>训练数据格式：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131717819.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>设置训练数据 Target 标签</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131719833.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131718596.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>全过程</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131732838.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>实例（三个任务）</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131733876.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131736569.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP——RNN系列</title>
      <link href="/2023/02/14/RNN%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/02/14/RNN%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1dq4y1f7ep/?spm_id_from=333.788&amp;vd_source=ec8fb32942c22665057156952ef080c7">RNN模型与NLP应用(3/9)：Simple RNN模型_哔哩哔哩_bilibili</a></p><h1 id="普通-rnn-模型">普通 RNN 模型</h1><p>many to one 或者 many to many，适合输入和输出常读不固定，所以很适合文本、语音的处理。</p><p>RNN 和人的阅读思维和相似，不断积累信息。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652261.png" alt="Pasted image 20230201160756" /><figcaption aria-hidden="true">Pasted image 20230201160756</figcaption></figure><p>用状态向量 h 记录阅读过的信息，上图的 h2 已经包含 the cat sat。整个 RNN 只有一个 A，最后训练的就是这个 A。</p><p>如果设置了 return_sequences=False，那么表示只保留最后一个 ht，前面的向量都删除；如果设置为 true，则保留所有的 h，再手动在其后增加一个 Flatten() 层</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652262.png" alt="Pasted image 20230201161002" /><figcaption aria-hidden="true">Pasted image 20230201161002</figcaption></figure><blockquote><p>如果发现 val_acc 变差（不是 acc），在变差之前就要通过减少 epochs 停止训练（Early stopping）。</p></blockquote><h2 id="缺陷">缺陷</h2><p>SimpleRNN 记忆力很短。它适合 short-term dependence，因为它擅长从周围的上下文预测下文，比如给一句话的一部分，预测下一个词。但是它不擅长 long_term dependence，文本太长会导致忘记前文，使得信息丢失。</p><h1 id="lstm">LSTM</h1><p>LSTM 也是循环神经网络，它比 SimpleRNN 记忆力长很多，但是仍然会有遗忘的情况。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652263.png" alt="Pasted image 20230201163451" /><figcaption aria-hidden="true">Pasted image 20230201163451</figcaption></figure><blockquote><p>sigmod 函数将向量的每个元素压到 [0,1] 之间 <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652264.png" alt="Pasted image 20230201164017" /></p></blockquote><p>一共有四个参数矩阵，下面列出：</p><h3 id="遗忘门-ft">遗忘门 ft</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652265.png" alt="Pasted image 20230201164220" /><figcaption aria-hidden="true">Pasted image 20230201164220</figcaption></figure><h3 id="输入门-it">输入门 it</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652266.png" alt="Pasted image 20230201164334" /><figcaption aria-hidden="true">Pasted image 20230201164334</figcaption></figure><h3 id="new-value">New Value</h3><p>注意激活函数不是 sigmod，而是 tanh (双曲正切函数) <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652267.png" alt="Pasted image 20230201164434" /></p><h3 id="输出门-ot">输出门 ot</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652268.png" alt="Pasted image 20230201164738" /><figcaption aria-hidden="true">Pasted image 20230201164738</figcaption></figure><p>更新状态 <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652269.png" alt="Pasted image 20230201164839" /></p><h2 id="实现">实现</h2><p>只保留最后一个 ht（特征向量） <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652270.png" alt="Pasted image 20230201165143" /></p><h1 id="多层-rnn">多层 RNN</h1><p>前两层的 LSTM 的所有输出的 h 都需要保留，只有最后一层的 LSTM 的输出只需要最后的 ht。最后增加全连接层即可。 <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652271.png" alt="Pasted image 20230202174210" /></p><h1 id="双向-rnn">双向 RNN</h1><p>两条相反方向的独立 RNN。 <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041652272.png" alt="Pasted image 20230202175122" /></p><h1 id="预训练-rnn">预训练 RNN</h1><p>对 Embedding 层作预训练，从而减少 Embedding 的输出过于冗余的缺点。</p><h1 id="小结">小结</h1><p>simpleRNN 效果不好，能用 simpleRNN 尽量用 LSTM。推荐双向 LSTM、多层 RNN、预训练 RNN。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NLP——Attention系列</title>
      <link href="/2023/02/14/Attention%E7%B3%BB%E5%88%97/"/>
      <url>/2023/02/14/Attention%E7%B3%BB%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1YA411G7Ep/?spm_id_from=333.788&amp;vd_source=ec8fb32942c22665057156952ef080c7">RNN模型与NLP应用(8/9)：Attention (注意力机制)</a></p><p>基于 LSTM 的模型有一个缺陷，它没有办法记录很长的句子，因为只保留最后一个输出 <span class="math inline">\(h_m\)</span>，所以如果句子很长，前面的信息就会被遗忘。而 Attemtion 模型就弥补了这个缺陷。</p><h1 id="attention注意力机制">Attention（注意力机制）</h1><blockquote><p>准确的代价是巨大的计算量！</p></blockquote><p>decoder 每次更新状态时都会回头再看一遍 encoder 所有状态。此外，Attention 还会告诉 decoder 应该关注 encoder 哪个状态。</p><p>缺点：计算量非常大。</p><p>在 encoder 结束工作时，Attention 和 decoder 同时工作。decoder 初始工作状态 <span class="math inline">\(s_0\)</span> 时 encoder 的最后状态 <span class="math inline">\(h_m\)</span>，Attention 判断 <span class="math inline">\(s_0\)</span> 和 <span class="math inline">\(h_i\)</span> 的相关性。</p><blockquote><p><span class="math inline">\(c_0=a_1h_1+...+a_mh_m\)</span></p></blockquote><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131506641.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><blockquote><p>对于每一个 <span class="math inline">\(s_i\)</span>，都有自己的 <span class="math inline">\(c_i\)</span>，对于每一个 <span class="math inline">\(c_i\)</span>，构成它的 <span class="math inline">\(a_1、a_2...\)</span> 都和其他的 <span class="math inline">\(c_i\)</span> 的不一样。<span class="math inline">\(a_i\)</span> 是由 <span class="math inline">\(s_i\)</span> 与每个 <span class="math inline">\(h_i\)</span> 做对比，计算出的权重。</p></blockquote><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131511486.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><blockquote><p>做完所有的工作，一共要计算 t 次权重，每次要计算 m 个权重，复杂度是 mt，非常高。</p></blockquote><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131517108.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="例子">例子</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131522186.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="self-attention自注意力机制">Self-Attention（自注意力机制）</h1><p>普通的 Attemtion 是基于一个 encoder 网络和一个 decoder 网络结构，Self-Attention 是运用在一个网路结构上。</p><blockquote><p>初始时 <span class="math inline">\(h_0\)</span> 和 <span class="math inline">\(c_0\)</span> 都是全零向量。</p></blockquote><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131529509.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><blockquote><p>计算 <span class="math inline">\(c_i\)</span> 是已有状态 h 的加权平均，权重 <span class="math inline">\(a_i\)</span> 是相关性</p></blockquote><p><span class="math inline">\(h_3\)</span> 是由 <span class="math inline">\(x_3\)</span> 和 <span class="math inline">\(c_2\)</span> 计算得到</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131535546.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>计算权重 <img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131534958.png" alt="image.png" /></p><p>计算相关性</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302131534180.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱常见疾病构建</title>
      <link href="/2023/02/14/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%B8%B8%E8%A7%81%E7%96%BE%E7%97%85%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/02/14/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%B8%B8%E8%A7%81%E7%96%BE%E7%97%85%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>数据链接：<a href="http://openkg.cn/dataset/disease-information">DiseaseKG:基于cnSchma常见疾病信息知识图谱 - 图谱 - 开放知识图谱</a> 数据下载：<a href="https://github.com/nuolade/disease-kb">GitHub - nuolade/disease-kb: 常见疾病相关信息构建knowledge graph</a></p><p><a href="https://blog.csdn.net/m0_60976461/article/details/119729628">知识图谱学习笔记 4_落霞孤雾的博客-CSDN博客_medical.json</a></p><h1 id="数据分析">数据分析</h1><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">diseaseKB</span><br><span class="line">├── data</span><br><span class="line">│   └── medical.json 结构化疾病医疗知识</span><br><span class="line">├── prepare_data</span><br><span class="line">│   ├── build_data.py 数据处理到数据库</span><br><span class="line">│   ├── data_spider.py 爬取数据</span><br><span class="line">│   └── max_cut.py 根据给定的词典对文本进行前向、后向和双向最大匹配</span><br><span class="line">├── dict 各种类别的词典</span><br><span class="line">├── build_medicalgraph.py 利用结构化的数据建立Neo4j知识图谱 </span><br><span class="line">├── build_medicalgraph_from_json.py 利用实体和关系json文件据建立知识图谱 </span><br><span class="line">└── build_json.py 利用爬取的数据生成提炼的实体和关系json文件</span><br></pre></td></tr></table></figure><p>/data/下存放所有数据的数据</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101511803.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>在 dict 中存放处理好的对应数据</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101512241.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="数据载入">数据载入</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302122135202.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302122135118.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="代码分析">代码分析</h1><blockquote><p>基于原理和提供的代码，我增加了注释和修改了顺序，有些语法也重新写了。</p></blockquote><h2 id="导包">导包</h2><p>首先是导入需要的包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py2neo  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> json  </span><br><span class="line"><span class="keyword">import</span> logging    <span class="comment"># 可以不用</span></span><br></pre></td></tr></table></figure><p>如果使用 logging 进行信息输出，需要在这之后加上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.getLogger().setLevel(logging.INFO)   <span class="comment"># 使得在pycharm中显示logging.info</span></span><br></pre></td></tr></table></figure><h2 id="定义-main">定义 main</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    handler = MedicalGraph()  </span><br><span class="line">    handler.clean()        <span class="comment"># 清楚所有节点和关系</span></span><br><span class="line">    handler.create_graph_nodes()     <span class="comment"># 建立节点</span></span><br><span class="line">    handler.create_graph_relationship()     <span class="comment"># 建立关系</span></span><br></pre></td></tr></table></figure><h2 id="定义-medicalgraph-类">定义 MedicalGraph 类</h2><h3 id="定义__init__函数">定义__init__()函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line"><span class="comment"># os.path.abspath(__file__)返回当前脚本的绝对路径,windows使用\\分割  </span></span><br><span class="line">    cur_dir = <span class="string">&#x27;\\&#x27;</span>.join(os.path.abspath(__file__).split(<span class="string">&#x27;\\&#x27;</span>)[:-<span class="number">1</span>])    </span><br><span class="line">    self.data_path = os.path.join(cur_dir,<span class="string">&#x27;data\\medical.json&#x27;</span>)  </span><br><span class="line">    self.clinet = py2neo.Graph(<span class="string">&quot;http://127.0.0.1:7474&quot;</span>, user=<span class="string">&#x27;neo4j&#x27;</span>, password=<span class="string">&#x27;12345678&#x27;</span>, name=<span class="string">&#x27;neo4j&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="定义-clean-函数">定义 clean() 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>(<span class="params">self</span>):  </span><br><span class="line">    logging.info(<span class="string">&quot;================正在删除所有节点和关系================&quot;</span>)  </span><br><span class="line">    self.clinet.run(<span class="string">&quot;match (n) detach delete (n)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="定义读取-json-文件函数">定义读取 json 文件函数</h3><p>同时构建节点和节点间的关系，后面不论是构建节点还是定义关系都会重新使用 read_json () 这个独立函数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_json</span>(<span class="params">self</span>):  </span><br><span class="line">    <span class="comment"># 1 建立实体节点list，共8类节点  </span></span><br><span class="line">    drugs = []  <span class="comment"># 药品  </span></span><br><span class="line">    foods = []  <span class="comment"># 食物  </span></span><br><span class="line">    checks = []  <span class="comment"># 检查  </span></span><br><span class="line">    departments = []  <span class="comment"># 科室名称  </span></span><br><span class="line">    producers = []  <span class="comment"># 药品大类  </span></span><br><span class="line">    diseases = []  <span class="comment"># 疾病名称  </span></span><br><span class="line">    symptoms = []  <span class="comment"># 症状  </span></span><br><span class="line">    cures = []  <span class="comment"># 治疗方法  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 2 建立实体节点之间关系list  </span></span><br><span class="line">    rels_department = []  <span class="comment"># 科室－科室关系（前小后大）  </span></span><br><span class="line">    rels_noteat = []  <span class="comment"># 疾病－忌吃食物关系  </span></span><br><span class="line">    rels_doeat = []  <span class="comment"># 疾病－宜吃食物关系  </span></span><br><span class="line">    rels_recommandeat = []  <span class="comment"># 疾病－推荐吃食物关系  </span></span><br><span class="line">    rels_commonddrug = []  <span class="comment"># 疾病－通用药品关系  </span></span><br><span class="line">    rels_recommanddrug = []  <span class="comment"># 疾病－热门药品关系  </span></span><br><span class="line">    rels_check = []  <span class="comment"># 疾病－检查关系  </span></span><br><span class="line">    rels_drug_producer = []  <span class="comment"># 厂商－药物关系  </span></span><br><span class="line">    rels_cureway = []  <span class="comment"># 疾病-治疗方式关系  </span></span><br><span class="line">    rels_symptom = []  <span class="comment"># 疾病-症状关系  </span></span><br><span class="line">    rels_acompany = []  <span class="comment"># 疾病并发关系  </span></span><br><span class="line">    rels_category = []  <span class="comment"># 疾病-科室之间的关系  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 3 建立疾病存储字典  </span></span><br><span class="line">    disease_infos = []  <span class="comment"># 疾病信息  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 4 读取文件  </span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> <span class="built_in">open</span>(self.data_path,<span class="string">&#x27;rb&#x27;</span>):  </span><br><span class="line">        data_json = json.loads(data)      <span class="comment"># json.loads(data)可用于解析有效的JSON字符串并将其转换为Python字典  </span></span><br><span class="line">  </span><br><span class="line">        diseases.append(data_json[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># 加入疾病名称list中  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 构建一个病毒字典，存储当前病毒的所有信息  </span></span><br><span class="line">        disease_dict = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">        disease_name = data_json[<span class="string">&#x27;name&#x27;</span>]    <span class="comment"># 因为后面反复使用,所有设置变量访问更快  </span></span><br><span class="line">        disease_dict[<span class="string">&#x27;name&#x27;</span>] = disease_name  </span><br><span class="line">        disease_dict[<span class="string">&#x27;desc&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;prevent&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;cause&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;easy_get&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;cure_department&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;cure_way&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;cure_lasttime&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;symptom&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">        disease_dict[<span class="string">&#x27;cured_prob&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 4.1 必须有的字段  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;desc&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            disease_dict[<span class="string">&#x27;desc&#x27;</span>] = data_json[<span class="string">&#x27;desc&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;prevent&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            disease_dict[<span class="string">&#x27;prevent&#x27;</span>] = data_json[<span class="string">&#x27;prevent&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;cause&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            disease_dict[<span class="string">&#x27;cause&#x27;</span>] = data_json[<span class="string">&#x27;cause&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;easy_get&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            disease_dict[<span class="string">&#x27;easy_get&#x27;</span>] = data_json[<span class="string">&#x27;easy_get&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;cure_department&#x27;</span> <span class="keyword">in</span> data_json:     <span class="comment"># 所属科室  </span></span><br><span class="line">            cure_department = data_json[<span class="string">&#x27;cure_department&#x27;</span>]  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cure_department)==<span class="number">1</span>:     <span class="comment"># 疾病-科室之间的关系  </span></span><br><span class="line">                rels_category.append([disease_name,cure_department[<span class="number">0</span>]])  </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cure_department)==<span class="number">2</span>:     <span class="comment"># 科室－科室关系（前小后大） 疾病-科室之间的关系  </span></span><br><span class="line">                big = cure_department[<span class="number">0</span>]  </span><br><span class="line">                small = cure_department[<span class="number">1</span>]  </span><br><span class="line">                rels_department.append([small,big])  </span><br><span class="line">                rels_category.append([disease_name,cure_department[<span class="number">0</span>]])  </span><br><span class="line">            departments += cure_department    <span class="comment"># list的添加可以用append,也可以用+  </span></span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;cure_way&#x27;</span> <span class="keyword">in</span> data_json:    <span class="comment"># 疾病治疗方法  </span></span><br><span class="line">            cure_way = data_json[<span class="string">&#x27;cure_way&#x27;</span>]  </span><br><span class="line">            <span class="keyword">for</span> cure <span class="keyword">in</span> cure_way:  </span><br><span class="line">                rels_cureway.append([disease_name,cure])  </span><br><span class="line">            cures += cure_way  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;cure_lasttime&#x27;</span> <span class="keyword">in</span> data_json:    <span class="comment"># 治疗周期  </span></span><br><span class="line">            disease_dict[<span class="string">&#x27;cure_lasttime&#x27;</span>] = data_json[<span class="string">&#x27;cure_lasttime&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;symptom&#x27;</span> <span class="keyword">in</span> data_json:      <span class="comment"># 疾病症状  </span></span><br><span class="line">            <span class="keyword">for</span> symptom <span class="keyword">in</span> data_json[<span class="string">&#x27;symptom&#x27;</span>]:  </span><br><span class="line">                rels_symptom.append([disease_name, symptom])  </span><br><span class="line">            symptoms += data_json[<span class="string">&#x27;symptom&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;cured_prob&#x27;</span> <span class="keyword">in</span> data_json:     <span class="comment"># 治愈概率  </span></span><br><span class="line">            disease_dict[<span class="string">&#x27;cured_prob&#x27;</span>] = data_json[<span class="string">&#x27;cured_prob&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 4.2 还有其他可能有的字段  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;get_prob&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            disease_dict[<span class="string">&#x27;get_prob&#x27;</span>] = data_json[<span class="string">&#x27;get_prob&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;easy_get&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            disease_dict[<span class="string">&#x27;easy_get&#x27;</span>] = data_json[<span class="string">&#x27;easy_get&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 4.3 建立关系  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;acompany&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            <span class="keyword">for</span> acompany <span class="keyword">in</span> data_json[<span class="string">&#x27;acompany&#x27;</span>]:  </span><br><span class="line">                rels_acompany.append([disease_name, acompany])  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;common_drug&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            common_drug = data_json[<span class="string">&#x27;common_drug&#x27;</span>]  </span><br><span class="line">            <span class="keyword">for</span> drug <span class="keyword">in</span> common_drug:  </span><br><span class="line">                rels_commonddrug.append([disease_name, drug])  </span><br><span class="line">            drugs += common_drug  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;recommand_drug&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            recommand_drug = data_json[<span class="string">&#x27;recommand_drug&#x27;</span>]  </span><br><span class="line">            drugs += recommand_drug      <span class="comment"># 药品名称增加  </span></span><br><span class="line">            <span class="keyword">for</span> drug <span class="keyword">in</span> recommand_drug:  </span><br><span class="line">                rels_recommanddrug.append([disease_name, drug])  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;not_eat&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            not_eat = data_json[<span class="string">&#x27;not_eat&#x27;</span>]  </span><br><span class="line">            <span class="keyword">for</span> _<span class="keyword">not</span> <span class="keyword">in</span> not_eat:  </span><br><span class="line">                rels_noteat.append([disease_name,_<span class="keyword">not</span>])  </span><br><span class="line">            foods += not_eat  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;do_eat&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            do_eat = data_json[<span class="string">&#x27;do_eat&#x27;</span>]  </span><br><span class="line">            <span class="keyword">for</span> _do <span class="keyword">in</span> do_eat:  </span><br><span class="line">                rels_doeat.append([disease_name,_do])  </span><br><span class="line">            foods += do_eat  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;recommand_eat&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">            recommand_eat = data_json[<span class="string">&#x27;recommand_eat&#x27;</span>]  </span><br><span class="line">            <span class="keyword">for</span> _recommand <span class="keyword">in</span> recommand_eat:  </span><br><span class="line">                rels_recommandeat.append([disease_name, _recommand])  </span><br><span class="line">            foods += recommand_eat  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;check&#x27;</span> <span class="keyword">in</span> data_json:     <span class="comment"># 检查项目  </span></span><br><span class="line">            check = data_json[<span class="string">&#x27;check&#x27;</span>]  </span><br><span class="line">            <span class="keyword">for</span> _check <span class="keyword">in</span> check:  </span><br><span class="line">                rels_check.append([disease_name, _check])  </span><br><span class="line">            checks += check  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;drug_detail&#x27;</span> <span class="keyword">in</span> data_json:    <span class="comment"># 药品详情  </span></span><br><span class="line">            drug_detail = data_json[<span class="string">&#x27;drug_detail&#x27;</span>]  </span><br><span class="line">            producer = [i.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> drug_detail]     <span class="comment"># 得到药品的名称,i.split(&#x27;(&#x27;)表示根据(将其分开,[0]表示取(之前的内容  </span></span><br><span class="line">            <span class="comment"># print(producer)  </span></span><br><span class="line">            rels_drug_producer += [[i.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">0</span>], i.split(<span class="string">&#x27;(&#x27;</span>)[-<span class="number">1</span>].replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> drug_detail]   <span class="comment"># 对每个药物,构建其名称和所属类型的对应关系  </span></span><br><span class="line">            producers += producer  </span><br><span class="line">        <span class="comment"># print(rels_drug_producer)  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 4.4 存入将当前疾病及其信息存入disease_infos字典中  </span></span><br><span class="line">        disease_infos.append(disease_dict)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 5 返回数据  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">set</span>(drugs), <span class="built_in">set</span>(foods), <span class="built_in">set</span>(checks), <span class="built_in">set</span>(departments), <span class="built_in">set</span>(producers), <span class="built_in">set</span>(symptoms), <span class="built_in">set</span>(diseases), <span class="built_in">set</span>(  </span><br><span class="line">        cures), disease_infos,rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug, \  </span><br><span class="line">           rels_symptom, rels_acompany, rels_category, rels_cureway     <span class="comment"># 返回节点和关系(节点使用set会自动删除重复元素,关系是二元组不能直接用set去重)</span></span><br></pre></td></tr></table></figure><blockquote><p>回到 main 函数，可以看到我们需要定义 <code>create_graph_nodes()</code> 函数和 <code>create_graph_relationship()</code> 函数</p></blockquote><h3 id="定义创建节点函数">定义创建节点函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建实体节点  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_graph_nodes</span>(<span class="params">self</span>):  </span><br><span class="line">    <span class="comment"># 1 获取需要读取的文件信息  </span></span><br><span class="line">    Drugs, Foods, Checks, Departments, Producers, Symptoms, Diseases, Cures, disease_infos, rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug, rels_symptom, rels_acompany, rels_category, rels_cureway = self.read_json()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 2 创建疾病节点  </span></span><br><span class="line">    self.create_diseases_nodes(disease_infos)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 3 创建其他类型节点,只有name属性  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Drug&#x27;</span>, Drugs)    <span class="comment"># 药品  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Food&#x27;</span>, Foods)    <span class="comment"># 食物  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Check&#x27;</span>, Checks)   <span class="comment"># 检查项目  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Department&#x27;</span>, Departments)    <span class="comment"># 科目  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Producer&#x27;</span>, Producers)     <span class="comment"># 在售药品  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Symptom&#x27;</span>, Symptoms)     <span class="comment"># 疾病症状  </span></span><br><span class="line">    self.create_simple_nodes(<span class="string">&#x27;Cure&#x27;</span>, Cures)      <span class="comment"># 治疗方法</span></span><br></pre></td></tr></table></figure><p>这里定义疾病节点和其他节点不同，疾病节点由多个属性组成，而普通节点只有 name 属性。</p><h4 id="定义创建疾病节点函数">定义创建疾病节点函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_diseases_nodes</span>(<span class="params">self,disease_infos</span>):  </span><br><span class="line">    logging.info(<span class="string">&quot;================正在创建疾病实体节点================&quot;</span>)  </span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">len</span>(disease_infos)  </span><br><span class="line">    count = <span class="number">0</span>  </span><br><span class="line">    <span class="keyword">for</span> disease_dict <span class="keyword">in</span> disease_infos:  </span><br><span class="line">        node = py2neo.Node(<span class="string">&quot;Disease&quot;</span>,name=disease_dict[<span class="string">&#x27;name&#x27;</span>], desc=disease_dict[<span class="string">&#x27;desc&#x27;</span>],  </span><br><span class="line">                    prevent=disease_dict[<span class="string">&#x27;prevent&#x27;</span>] ,cause=disease_dict[<span class="string">&#x27;cause&#x27;</span>],  </span><br><span class="line">                    easy_get=disease_dict[<span class="string">&#x27;easy_get&#x27;</span>],cure_lasttime=disease_dict[<span class="string">&#x27;cure_lasttime&#x27;</span>],  </span><br><span class="line">                    cured_prob=disease_dict[<span class="string">&#x27;cured_prob&#x27;</span>])  </span><br><span class="line">        self.clinet.create(node)  </span><br><span class="line">        count += <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">if</span> count % <span class="number">2000</span>==<span class="number">0</span>:  </span><br><span class="line">            logging.info(<span class="string">&quot;已经创建%d个节点,总共%d个节点&quot;</span>,count,<span class="built_in">sum</span>)  </span><br><span class="line">    logging.info(<span class="string">&quot;已创建完成,共创建%d个节点&quot;</span>, count)  </span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="定义创建普通节点函数">定义创建普通节点函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_simple_nodes</span>(<span class="params">self,label,nodes</span>):  </span><br><span class="line">    logging.info(<span class="string">&quot;================正在创建%s实体节点================&quot;</span>,label)  </span><br><span class="line">    count = <span class="number">0</span>  </span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">len</span>(nodes)  </span><br><span class="line">    <span class="keyword">for</span> node_name <span class="keyword">in</span> nodes:  </span><br><span class="line">        node = py2neo.Node(label,name=node_name)  </span><br><span class="line">        self.clinet.create(node)  </span><br><span class="line">        count += <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">if</span> count%<span class="number">2000</span>==<span class="number">0</span>:  </span><br><span class="line">            logging.info(<span class="string">&quot;已经创建%d个节点,总共%d个节点&quot;</span>, count, <span class="built_in">sum</span>)  </span><br><span class="line">    logging.info(<span class="string">&quot;已创建完成,共创建%d个节点&quot;</span>, count)</span><br></pre></td></tr></table></figure><h3 id="定义创建关系函数">定义创建关系函数</h3><p>对每个关系分别调用关系创建函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建实体关系  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_graph_relationship</span>(<span class="params">self</span>):  </span><br><span class="line">    <span class="comment"># 1 获取需要读取的文件信息  </span></span><br><span class="line">    Drugs, Foods, Checks, Departments, Producers, Symptoms, Diseases, Cures, disease_infos, rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug, rels_symptom, rels_acompany, rels_category, rels_cureway = self.read_json()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 2 依次建立关系  </span></span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>, rels_recommandeat, <span class="string">&#x27;recommand_eat&#x27;</span>, <span class="string">&#x27;推荐食谱&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>, rels_noteat, <span class="string">&#x27;no_eat&#x27;</span>, <span class="string">&#x27;忌吃&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>, rels_doeat, <span class="string">&#x27;do_eat&#x27;</span>, <span class="string">&#x27;宜吃&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Department&#x27;</span>, <span class="string">&#x27;Department&#x27;</span>, rels_department, <span class="string">&#x27;belongs_to&#x27;</span>, <span class="string">&#x27;属于&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Drug&#x27;</span>, rels_commonddrug, <span class="string">&#x27;common_drug&#x27;</span>, <span class="string">&#x27;常用药品&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Producer&#x27;</span>, <span class="string">&#x27;Drug&#x27;</span>, rels_drug_producer, <span class="string">&#x27;drugs_of&#x27;</span>, <span class="string">&#x27;生产药品&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Drug&#x27;</span>, rels_recommanddrug, <span class="string">&#x27;recommand_drug&#x27;</span>, <span class="string">&#x27;好评药品&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Check&#x27;</span>, rels_check, <span class="string">&#x27;need_check&#x27;</span>, <span class="string">&#x27;诊断检查&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Symptom&#x27;</span>, rels_symptom, <span class="string">&#x27;has_symptom&#x27;</span>, <span class="string">&#x27;症状&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Disease&#x27;</span>, rels_acompany, <span class="string">&#x27;acompany_with&#x27;</span>, <span class="string">&#x27;并发症&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Department&#x27;</span>, rels_category, <span class="string">&#x27;belongs_to&#x27;</span>, <span class="string">&#x27;所属科室&#x27;</span>)  </span><br><span class="line">    self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Cure&#x27;</span>, rels_cureway, <span class="string">&#x27;cure_way&#x27;</span>,<span class="string">&#x27;治疗方法&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="定义关系创建函数">定义关系创建函数</h4><blockquote><p>这里需要注意：在 json 中存在 <code>'</code>（单引号），所以如果在命令语句中的 <code>%s</code> 左右被 <code>''</code> 包裹，可能会出现错误情况，所以需要用 <code>""</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_relationship</span>(<span class="params">self,start_node,end_node,edges_list,rel_type,rel_name</span>):    <span class="comment"># 此处关联是用rel_type，但是会给它一个中文名称rel_name  </span></span><br><span class="line">    logging.info(<span class="string">&quot;================正在构建%s关系================&quot;</span>, rel_name)  </span><br><span class="line">    <span class="comment"># 1 去重操作  </span></span><br><span class="line">    set_edges = []  </span><br><span class="line">    <span class="comment"># 1.1 先将二元组拼接为一个字符串  </span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> edges_list:    <span class="comment"># 对于每一对二元组  </span></span><br><span class="line">        set_edges.append(<span class="string">&#x27;###&#x27;</span>.join(edge))     <span class="comment">#每一对二元组都转为一个字符串再存入set_edges列表中  </span></span><br><span class="line">    <span class="comment"># 1.2 set去重  </span></span><br><span class="line">    set_edges = <span class="built_in">set</span>(set_edges)  </span><br><span class="line">    <span class="comment"># 1.3 将每个字符串还原成二元组  </span></span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> set_edges:  </span><br><span class="line">        edge = edge.split(<span class="string">&#x27;###&#x27;</span>)  </span><br><span class="line">        p_name = edge[<span class="number">0</span>]  </span><br><span class="line">        q_name = edge[<span class="number">1</span>]  </span><br><span class="line">        cmd = <span class="string">&quot;&quot;&quot;match (p:%s &#123;name:&quot;%s&quot;&#125;),(q:%s &#123;name:&quot;%s&quot;&#125;) create (p)-[rel:%s &#123;name:&quot;%s&quot;&#125;]-&gt;(q)&quot;&quot;&quot;</span> % (start_node,p_name,end_node,q_name,rel_type,rel_name)  </span><br><span class="line">        self.clinet.run(cmd)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="完整代码">完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py2neo  </span><br><span class="line"><span class="keyword">import</span> os  </span><br><span class="line"><span class="keyword">import</span> json  </span><br><span class="line"><span class="keyword">import</span> logging  </span><br><span class="line">  </span><br><span class="line">logging.getLogger().setLevel(logging.INFO)   <span class="comment"># 使得在pycharm中显示logging.info  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedicalGraph</span>:  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):  </span><br><span class="line">        cur_dir = <span class="string">&#x27;\\&#x27;</span>.join(os.path.abspath(__file__).split(<span class="string">&#x27;\\&#x27;</span>)[:-<span class="number">1</span>])    <span class="comment"># os.path.abspath(__file__)返回当前脚本的绝对路径,windows使用\\分割  </span></span><br><span class="line">        self.data_path = os.path.join(cur_dir,<span class="string">&#x27;data\\medical.json&#x27;</span>)  </span><br><span class="line">        self.clinet = py2neo.Graph(<span class="string">&quot;http://127.0.0.1:7474&quot;</span>, user=<span class="string">&#x27;neo4j&#x27;</span>, password=<span class="string">&#x27;12345678&#x27;</span>, name=<span class="string">&#x27;neo4j&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clean</span>(<span class="params">self</span>):  </span><br><span class="line">        logging.info(<span class="string">&quot;================正在删除所有节点和关系================&quot;</span>)  </span><br><span class="line">        self.clinet.run(<span class="string">&quot;match (n) detach delete (n)&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read_json</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="comment"># 1 建立实体节点list，共8类节点  </span></span><br><span class="line">        drugs = []  <span class="comment"># 药品  </span></span><br><span class="line">        foods = []  <span class="comment"># 食物  </span></span><br><span class="line">        checks = []  <span class="comment"># 检查  </span></span><br><span class="line">        departments = []  <span class="comment"># 科室名称  </span></span><br><span class="line">        producers = []  <span class="comment"># 药品大类  </span></span><br><span class="line">        diseases = []  <span class="comment"># 疾病名称  </span></span><br><span class="line">        symptoms = []  <span class="comment"># 症状  </span></span><br><span class="line">        cures = []  <span class="comment"># 治疗方法  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 2 建立实体节点之间关系list  </span></span><br><span class="line">        rels_department = []  <span class="comment"># 科室－科室关系（前小后大）  </span></span><br><span class="line">        rels_noteat = []  <span class="comment"># 疾病－忌吃食物关系  </span></span><br><span class="line">        rels_doeat = []  <span class="comment"># 疾病－宜吃食物关系  </span></span><br><span class="line">        rels_recommandeat = []  <span class="comment"># 疾病－推荐吃食物关系  </span></span><br><span class="line">        rels_commonddrug = []  <span class="comment"># 疾病－通用药品关系  </span></span><br><span class="line">        rels_recommanddrug = []  <span class="comment"># 疾病－热门药品关系  </span></span><br><span class="line">        rels_check = []  <span class="comment"># 疾病－检查关系  </span></span><br><span class="line">        rels_drug_producer = []  <span class="comment"># 厂商－药物关系  </span></span><br><span class="line">        rels_cureway = []  <span class="comment"># 疾病-治疗方式关系  </span></span><br><span class="line">        rels_symptom = []  <span class="comment"># 疾病-症状关系  </span></span><br><span class="line">        rels_acompany = []  <span class="comment"># 疾病并发关系  </span></span><br><span class="line">        rels_category = []  <span class="comment"># 疾病-科室之间的关系  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 3 建立疾病存储字典  </span></span><br><span class="line">        disease_infos = []  <span class="comment"># 疾病信息  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 4 读取文件  </span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> <span class="built_in">open</span>(self.data_path,<span class="string">&#x27;rb&#x27;</span>):  </span><br><span class="line">            data_json = json.loads(data)      <span class="comment"># json.loads(data)可用于解析有效的JSON字符串并将其转换为Python字典  </span></span><br><span class="line">  </span><br><span class="line">            diseases.append(data_json[<span class="string">&#x27;name&#x27;</span>])  <span class="comment"># 加入疾病名称list中  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 构建一个病毒字典，存储当前病毒的所有信息  </span></span><br><span class="line">            disease_dict = &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">            disease_name = data_json[<span class="string">&#x27;name&#x27;</span>]    <span class="comment"># 因为后面反复使用,所有设置变量访问更快  </span></span><br><span class="line">            disease_dict[<span class="string">&#x27;name&#x27;</span>] = disease_name  </span><br><span class="line">            disease_dict[<span class="string">&#x27;desc&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;prevent&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;cause&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;easy_get&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;cure_department&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;cure_way&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;cure_lasttime&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;symptom&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">            disease_dict[<span class="string">&#x27;cured_prob&#x27;</span>] = <span class="string">&#x27;&#x27;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 4.1 必须有的字段  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;desc&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                disease_dict[<span class="string">&#x27;desc&#x27;</span>] = data_json[<span class="string">&#x27;desc&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;prevent&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                disease_dict[<span class="string">&#x27;prevent&#x27;</span>] = data_json[<span class="string">&#x27;prevent&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;cause&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                disease_dict[<span class="string">&#x27;cause&#x27;</span>] = data_json[<span class="string">&#x27;cause&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;easy_get&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                disease_dict[<span class="string">&#x27;easy_get&#x27;</span>] = data_json[<span class="string">&#x27;easy_get&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;cure_department&#x27;</span> <span class="keyword">in</span> data_json:     <span class="comment"># 所属科室  </span></span><br><span class="line">                cure_department = data_json[<span class="string">&#x27;cure_department&#x27;</span>]  </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cure_department)==<span class="number">1</span>:     <span class="comment"># 疾病-科室之间的关系  </span></span><br><span class="line">                    rels_category.append([disease_name,cure_department[<span class="number">0</span>]])  </span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(cure_department)==<span class="number">2</span>:     <span class="comment"># 科室－科室关系（前小后大） 疾病-科室之间的关系  </span></span><br><span class="line">                    big = cure_department[<span class="number">0</span>]  </span><br><span class="line">                    small = cure_department[<span class="number">1</span>]  </span><br><span class="line">                    rels_department.append([small,big])  </span><br><span class="line">                    rels_category.append([disease_name,cure_department[<span class="number">0</span>]])  </span><br><span class="line">                departments += cure_department    <span class="comment"># list的添加可以用append,也可以用+  </span></span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;cure_way&#x27;</span> <span class="keyword">in</span> data_json:    <span class="comment"># 疾病治疗方法  </span></span><br><span class="line">                cure_way = data_json[<span class="string">&#x27;cure_way&#x27;</span>]  </span><br><span class="line">                <span class="keyword">for</span> cure <span class="keyword">in</span> cure_way:  </span><br><span class="line">                    rels_cureway.append([disease_name,cure])  </span><br><span class="line">                cures += cure_way  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;cure_lasttime&#x27;</span> <span class="keyword">in</span> data_json:    <span class="comment"># 治疗周期  </span></span><br><span class="line">                disease_dict[<span class="string">&#x27;cure_lasttime&#x27;</span>] = data_json[<span class="string">&#x27;cure_lasttime&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;symptom&#x27;</span> <span class="keyword">in</span> data_json:      <span class="comment"># 疾病症状  </span></span><br><span class="line">                <span class="keyword">for</span> symptom <span class="keyword">in</span> data_json[<span class="string">&#x27;symptom&#x27;</span>]:  </span><br><span class="line">                    rels_symptom.append([disease_name, symptom])  </span><br><span class="line">                symptoms += data_json[<span class="string">&#x27;symptom&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;cured_prob&#x27;</span> <span class="keyword">in</span> data_json:     <span class="comment"># 治愈概率  </span></span><br><span class="line">                disease_dict[<span class="string">&#x27;cured_prob&#x27;</span>] = data_json[<span class="string">&#x27;cured_prob&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 4.2 还有其他可能有的字段  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;get_prob&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                disease_dict[<span class="string">&#x27;get_prob&#x27;</span>] = data_json[<span class="string">&#x27;get_prob&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;easy_get&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                disease_dict[<span class="string">&#x27;easy_get&#x27;</span>] = data_json[<span class="string">&#x27;easy_get&#x27;</span>]  </span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 4.3 建立关系  </span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;acompany&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                <span class="keyword">for</span> acompany <span class="keyword">in</span> data_json[<span class="string">&#x27;acompany&#x27;</span>]:  </span><br><span class="line">                    rels_acompany.append([disease_name, acompany])  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;common_drug&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                common_drug = data_json[<span class="string">&#x27;common_drug&#x27;</span>]  </span><br><span class="line">                <span class="keyword">for</span> drug <span class="keyword">in</span> common_drug:  </span><br><span class="line">                    rels_commonddrug.append([disease_name, drug])  </span><br><span class="line">                drugs += common_drug  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;recommand_drug&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                recommand_drug = data_json[<span class="string">&#x27;recommand_drug&#x27;</span>]  </span><br><span class="line">                drugs += recommand_drug      <span class="comment"># 药品名称增加  </span></span><br><span class="line">                <span class="keyword">for</span> drug <span class="keyword">in</span> recommand_drug:  </span><br><span class="line">                    rels_recommanddrug.append([disease_name, drug])  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;not_eat&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                not_eat = data_json[<span class="string">&#x27;not_eat&#x27;</span>]  </span><br><span class="line">                <span class="keyword">for</span> _<span class="keyword">not</span> <span class="keyword">in</span> not_eat:  </span><br><span class="line">                    rels_noteat.append([disease_name,_<span class="keyword">not</span>])  </span><br><span class="line">                foods += not_eat  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;do_eat&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                do_eat = data_json[<span class="string">&#x27;do_eat&#x27;</span>]  </span><br><span class="line">                <span class="keyword">for</span> _do <span class="keyword">in</span> do_eat:  </span><br><span class="line">                    rels_doeat.append([disease_name,_do])  </span><br><span class="line">                foods += do_eat  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;recommand_eat&#x27;</span> <span class="keyword">in</span> data_json:  </span><br><span class="line">                recommand_eat = data_json[<span class="string">&#x27;recommand_eat&#x27;</span>]  </span><br><span class="line">                <span class="keyword">for</span> _recommand <span class="keyword">in</span> recommand_eat:  </span><br><span class="line">                    rels_recommandeat.append([disease_name, _recommand])  </span><br><span class="line">                foods += recommand_eat  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;check&#x27;</span> <span class="keyword">in</span> data_json:     <span class="comment"># 检查项目  </span></span><br><span class="line">                check = data_json[<span class="string">&#x27;check&#x27;</span>]  </span><br><span class="line">                <span class="keyword">for</span> _check <span class="keyword">in</span> check:  </span><br><span class="line">                    rels_check.append([disease_name, _check])  </span><br><span class="line">                checks += check  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;drug_detail&#x27;</span> <span class="keyword">in</span> data_json:    <span class="comment"># 药品详情  </span></span><br><span class="line">                drug_detail = data_json[<span class="string">&#x27;drug_detail&#x27;</span>]  </span><br><span class="line">                producer = [i.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> drug_detail]     <span class="comment"># 得到药品的名称,i.split(&#x27;(&#x27;)表示根据(将其分开,[0]表示取(之前的内容  </span></span><br><span class="line">                <span class="comment"># print(producer)  </span></span><br><span class="line">                rels_drug_producer += [[i.split(<span class="string">&#x27;(&#x27;</span>)[<span class="number">0</span>], i.split(<span class="string">&#x27;(&#x27;</span>)[-<span class="number">1</span>].replace(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;&#x27;</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> drug_detail]   <span class="comment"># 对每个药物,构建其名称和所属类型的对应关系  </span></span><br><span class="line">                producers += producer  </span><br><span class="line">            <span class="comment"># print(rels_drug_producer)  </span></span><br><span class="line">  </span><br><span class="line">            <span class="comment"># 4.4 存入将当前疾病及其信息存入disease_infos字典中  </span></span><br><span class="line">            disease_infos.append(disease_dict)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 5 返回数据  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">set</span>(drugs), <span class="built_in">set</span>(foods), <span class="built_in">set</span>(checks), <span class="built_in">set</span>(departments), <span class="built_in">set</span>(producers), <span class="built_in">set</span>(symptoms), <span class="built_in">set</span>(diseases), <span class="built_in">set</span>(  </span><br><span class="line">            cures), disease_infos,rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug, \  </span><br><span class="line">               rels_symptom, rels_acompany, rels_category, rels_cureway     <span class="comment"># 返回节点和关系(节点使用set会自动删除重复元素,关系是二元组不能直接用set去重)  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_diseases_nodes</span>(<span class="params">self,disease_infos</span>):  </span><br><span class="line">        logging.info(<span class="string">&quot;================正在创建疾病实体节点================&quot;</span>)  </span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">len</span>(disease_infos)  </span><br><span class="line">        count = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">for</span> disease_dict <span class="keyword">in</span> disease_infos:  </span><br><span class="line">            node = py2neo.Node(<span class="string">&quot;Disease&quot;</span>,name=disease_dict[<span class="string">&#x27;name&#x27;</span>], desc=disease_dict[<span class="string">&#x27;desc&#x27;</span>],  </span><br><span class="line">                        prevent=disease_dict[<span class="string">&#x27;prevent&#x27;</span>] ,cause=disease_dict[<span class="string">&#x27;cause&#x27;</span>],  </span><br><span class="line">                        easy_get=disease_dict[<span class="string">&#x27;easy_get&#x27;</span>],cure_lasttime=disease_dict[<span class="string">&#x27;cure_lasttime&#x27;</span>],  </span><br><span class="line">                        cured_prob=disease_dict[<span class="string">&#x27;cured_prob&#x27;</span>])  </span><br><span class="line">            self.clinet.create(node)  </span><br><span class="line">            count += <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">if</span> count % <span class="number">2000</span>==<span class="number">0</span>:  </span><br><span class="line">                logging.info(<span class="string">&quot;已经创建%d个节点,总共%d个节点&quot;</span>,count,<span class="built_in">sum</span>)  </span><br><span class="line">        logging.info(<span class="string">&quot;已创建完成,共创建%d个节点&quot;</span>, count)  </span><br><span class="line">        <span class="keyword">return</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_simple_nodes</span>(<span class="params">self,label,nodes</span>):  </span><br><span class="line">        logging.info(<span class="string">&quot;================正在创建%s实体节点================&quot;</span>,label)  </span><br><span class="line">        count = <span class="number">0</span>  </span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">len</span>(nodes)  </span><br><span class="line">        <span class="keyword">for</span> node_name <span class="keyword">in</span> nodes:  </span><br><span class="line">            node = py2neo.Node(label,name=node_name)  </span><br><span class="line">            self.clinet.create(node)  </span><br><span class="line">            count += <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">if</span> count%<span class="number">2000</span>==<span class="number">0</span>:  </span><br><span class="line">                logging.info(<span class="string">&quot;已经创建%d个节点,总共%d个节点&quot;</span>, count, <span class="built_in">sum</span>)  </span><br><span class="line">        logging.info(<span class="string">&quot;已创建完成,共创建%d个节点&quot;</span>, count)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_relationship</span>(<span class="params">self,start_node,end_node,edges_list,rel_type,rel_name</span>):    <span class="comment"># 此处关联是用rel_type，但是会给它一个中文名称rel_name  </span></span><br><span class="line">        logging.info(<span class="string">&quot;================正在构建%s关系================&quot;</span>, rel_name)  </span><br><span class="line">        <span class="comment"># 1 去重操作  </span></span><br><span class="line">        set_edges = []  </span><br><span class="line">        <span class="comment"># 1.1 先将二元组拼接为一个字符串  </span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges_list:    <span class="comment"># 对于每一对二元组  </span></span><br><span class="line">            set_edges.append(<span class="string">&#x27;###&#x27;</span>.join(edge))     <span class="comment">#每一对二元组都转为一个字符串再存入set_edges列表中  </span></span><br><span class="line">        <span class="comment"># 1.2 set去重  </span></span><br><span class="line">        set_edges = <span class="built_in">set</span>(set_edges)  </span><br><span class="line">        <span class="comment"># 1.3 将每个字符串还原成二元组  </span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> set_edges:  </span><br><span class="line">            edge = edge.split(<span class="string">&#x27;###&#x27;</span>)  </span><br><span class="line">            p_name = edge[<span class="number">0</span>]  </span><br><span class="line">            q_name = edge[<span class="number">1</span>]  </span><br><span class="line">            cmd = <span class="string">&quot;&quot;&quot;match (p:%s &#123;name:&quot;%s&quot;&#125;),(q:%s &#123;name:&quot;%s&quot;&#125;) create (p)-[rel:%s &#123;name:&quot;%s&quot;&#125;]-&gt;(q)&quot;&quot;&quot;</span> % (start_node,p_name,end_node,q_name,rel_type,rel_name)  </span><br><span class="line">            self.clinet.run(cmd)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 创建实体节点  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_graph_nodes</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="comment"># 1 获取需要读取的文件信息  </span></span><br><span class="line">        Drugs, Foods, Checks, Departments, Producers, Symptoms, Diseases, Cures, disease_infos, rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug, rels_symptom, rels_acompany, rels_category, rels_cureway = self.read_json()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 2 创建疾病节点  </span></span><br><span class="line">        self.create_diseases_nodes(disease_infos)  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 3 创建其他类型节点,只有name属性  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Drug&#x27;</span>, Drugs)    <span class="comment"># 药品  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Food&#x27;</span>, Foods)    <span class="comment"># 食物  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Check&#x27;</span>, Checks)   <span class="comment"># 检查项目  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Department&#x27;</span>, Departments)    <span class="comment"># 科目  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Producer&#x27;</span>, Producers)     <span class="comment"># 在售药品  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Symptom&#x27;</span>, Symptoms)     <span class="comment"># 疾病症状  </span></span><br><span class="line">        self.create_simple_nodes(<span class="string">&#x27;Cure&#x27;</span>, Cures)      <span class="comment"># 治疗方法  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 创建实体关系  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_graph_relationship</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="comment"># 1 获取需要读取的文件信息  </span></span><br><span class="line">        Drugs, Foods, Checks, Departments, Producers, Symptoms, Diseases, Cures, disease_infos, rels_check, rels_recommandeat, rels_noteat, rels_doeat, rels_department, rels_commonddrug, rels_drug_producer, rels_recommanddrug, rels_symptom, rels_acompany, rels_category, rels_cureway = self.read_json()  </span><br><span class="line">  </span><br><span class="line">        <span class="comment"># 2 依次建立关系  </span></span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>, rels_recommandeat, <span class="string">&#x27;recommand_eat&#x27;</span>, <span class="string">&#x27;推荐食谱&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>, rels_noteat, <span class="string">&#x27;no_eat&#x27;</span>, <span class="string">&#x27;忌吃&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Food&#x27;</span>, rels_doeat, <span class="string">&#x27;do_eat&#x27;</span>, <span class="string">&#x27;宜吃&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Department&#x27;</span>, <span class="string">&#x27;Department&#x27;</span>, rels_department, <span class="string">&#x27;belongs_to&#x27;</span>, <span class="string">&#x27;属于&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Drug&#x27;</span>, rels_commonddrug, <span class="string">&#x27;common_drug&#x27;</span>, <span class="string">&#x27;常用药品&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Producer&#x27;</span>, <span class="string">&#x27;Drug&#x27;</span>, rels_drug_producer, <span class="string">&#x27;drugs_of&#x27;</span>, <span class="string">&#x27;生产药品&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Drug&#x27;</span>, rels_recommanddrug, <span class="string">&#x27;recommand_drug&#x27;</span>, <span class="string">&#x27;好评药品&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Check&#x27;</span>, rels_check, <span class="string">&#x27;need_check&#x27;</span>, <span class="string">&#x27;诊断检查&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Symptom&#x27;</span>, rels_symptom, <span class="string">&#x27;has_symptom&#x27;</span>, <span class="string">&#x27;症状&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Disease&#x27;</span>, rels_acompany, <span class="string">&#x27;acompany_with&#x27;</span>, <span class="string">&#x27;并发症&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Department&#x27;</span>, rels_category, <span class="string">&#x27;belongs_to&#x27;</span>, <span class="string">&#x27;所属科室&#x27;</span>)  </span><br><span class="line">        self.create_relationship(<span class="string">&#x27;Disease&#x27;</span>, <span class="string">&#x27;Cure&#x27;</span>, rels_cureway, <span class="string">&#x27;cure_way&#x27;</span>,<span class="string">&#x27;治疗方法&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    handler = MedicalGraph()  </span><br><span class="line">    handler.clean()  </span><br><span class="line">    handler.create_graph_nodes()  </span><br><span class="line">    handler.create_graph_relationship()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j使用语法+py2neo</title>
      <link href="/2023/02/11/Neo4j%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95-py2neo/"/>
      <url>/2023/02/11/Neo4j%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95-py2neo/</url>
      
        <content type="html"><![CDATA[<p>视频链接：<a href="https://www.bilibili.com/video/BV1EY411B7GY?vd_source=ee0c3d58f791481ea0f93acb1c8a35ab">哔哩哔哩</a></p><blockquote><p>如果需要删除所有节点，输入： <code>match (n) detach delete (n)</code></p></blockquote><h1 id="准备学习">准备学习</h1><h2 id="建立对象">建立对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create (n:`学生`&#123;姓名:&quot;张三&quot;,性别:&quot;男&quot;,年龄:20&#125;)</span><br><span class="line">```                                                            </span><br><span class="line"></span><br><span class="line">![image.png](https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101524954.png)</span><br><span class="line"></span><br><span class="line">![image.png](https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101529349.png)</span><br><span class="line"></span><br><span class="line">## 建立关系</span><br><span class="line"></span><br><span class="line">neo4j 创建的关系一定是单向的，A 指向 B 的这个有向关系的名称为 C，表示：**A 的 C 是 B**</span><br><span class="line"></span><br><span class="line">### 创建方法 1</span><br><span class="line"></span><br><span class="line">```neo4j</span><br><span class="line">match (a:`老师`),(b:`学生`) where a.姓名=&quot;陶老师&quot; and b.姓名=&quot;汪睿阳&quot; create (a)-[rel:学生]-&gt;(b)</span><br></pre></td></tr></table></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101543066.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="创建方法-2">创建方法 2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match (a:`学生` &#123;姓名:&quot;汪睿阳&quot;&#125;),(b:`学生` &#123;姓名:&quot;彤彤&quot;&#125;) create (a)-[rel:对象]-&gt;(b)</span><br></pre></td></tr></table></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101602353.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="查询">查询</h2><p>会一起返回节点之间的关系（同样可以用 <code>where</code> 写）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match (a:`老师` &#123;姓名:&quot;陶老师&quot;&#125;)-[r:`学生`]-&gt;(b:`学生`) return b</span><br></pre></td></tr></table></figure><p>只会返回节点的<strong>姓名</strong>属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match (a:`老师` &#123;姓名:&quot;陶老师&quot;&#125;)-[r:`学生`]-&gt;(b:`学生`) return b.姓名</span><br></pre></td></tr></table></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101611859.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="删除关系">删除关系</h2><h3 id="删除某一类关系">删除某一类关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match (a:`老师`)-[r:`学生弟`]-&gt;(b:`学生`) delete r</span><br></pre></td></tr></table></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101636358.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="删除某个指定关系">删除某个指定关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">match (a:`老师` &#123;姓名:&quot;赵老师&quot;&#125;)-[r:`学生`]-&gt;(b:`学生` &#123;姓名:&quot;彤彤&quot;&#125;) delete r</span><br></pre></td></tr></table></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101638695.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="python-连接-neo4j">python 连接 neo4j</h1><p>cmd 中安装 py2neo 包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install py2neo</span><br></pre></td></tr></table></figure><h2 id="连接指令">连接指令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py2neo  </span><br><span class="line"></span><br><span class="line">clinet = py2neo.Graph(<span class="string">&quot;http://127.0.0.1:7474&quot;</span>, user=<span class="string">&#x27;neo4j&#x27;</span>, password=<span class="string">&#x27;LLAP1107&#x27;</span>, name=<span class="string">&#x27;neo4j&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意加上 name 字段</p></blockquote><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302101702225.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="创建节点">创建节点</h2><h3 id="方法一">方法一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = py2neo.Node(<span class="string">&quot;老师&quot;</span>, 姓名=<span class="string">&quot;陶老师&quot;</span>, 性别=<span class="string">&quot;男&quot;</span>, 年龄=<span class="number">35</span>)  </span><br><span class="line">clinet.create(node)</span><br></pre></td></tr></table></figure><h3 id="方法二">方法二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clinet.run(<span class="string">&quot;create (n:学生 &#123;姓名:&#x27;小明&#x27;,性别:&#x27;男&#x27;,年龄:22&#125;)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="方法三定义函数">方法三、定义函数⭐</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_node</span>(<span class="params">clinet,<span class="built_in">type</span>,name,sex,age</span>):  </span><br><span class="line">    cmd = <span class="string">&quot;&quot;&quot;create (a:%s &#123;姓名:&quot;%s&quot;,性别:&quot;%s&quot;,年龄:%d&#125;)&quot;&quot;&quot;</span> % (<span class="built_in">type</span>,name,sex,age)  </span><br><span class="line">    clinet.run(cmd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="comment"># 打开数据库  </span></span><br><span class="line">clinet = py2neo.Graph(<span class="string">&quot;http://127.0.0.1:7474&quot;</span>, user=<span class="string">&#x27;neo4j&#x27;</span>, password=<span class="string">&#x27;LLAP1107&#x27;</span>, name=<span class="string">&#x27;neo4j&#x27;</span>)  </span><br><span class="line"><span class="comment"># 清空数据库  </span></span><br><span class="line">clinet.run(<span class="string">&quot;match (n) detach delete (n)&quot;</span>)</span><br><span class="line"></span><br><span class="line">create_node(clinet, <span class="string">&quot;老师&quot;</span>, <span class="string">&quot;陶老师&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">33</span>)  </span><br><span class="line">create_node(clinet, <span class="string">&quot;学生&quot;</span>, <span class="string">&quot;汪小阳&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">23</span>)</span><br></pre></td></tr></table></figure><h3 id="方法四定义通用函数同格式">方法四、定义通用函数（同格式）⭐</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> py2neo  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_node</span>(<span class="params">clinet,<span class="built_in">type</span></span>):  </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">type</span>&#125;</span>信息.txt&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:  </span><br><span class="line">        infos = f.read().split(<span class="string">&quot;\n&quot;</span>)  </span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> infos:  </span><br><span class="line">        info = info.strip().split(<span class="string">&quot; &quot;</span>)    <span class="comment">#先删除左右多余的空格，再根据&quot; &quot;将其转化为一个list  </span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(info) != <span class="number">3</span>:  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">        name,sex,age = info  </span><br><span class="line">        cmd = <span class="string">&quot;&quot;&quot;create (a:%s &#123;姓名:&quot;%s&quot;,性别:&quot;%s&quot;,年龄: %d&#125;)&quot;&quot;&quot;</span> % (<span class="built_in">type</span>, name, sex, <span class="built_in">int</span>(age))  </span><br><span class="line">        clinet.run(cmd)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    clinet = py2neo.Graph(<span class="string">&quot;http://127.0.0.1:7474&quot;</span>, user=<span class="string">&quot;neo4j&quot;</span>, password=<span class="string">&quot;LLAP1107&quot;</span>, name=<span class="string">&quot;neo4j&quot;</span>)  </span><br><span class="line">    clinet.run(<span class="string">&quot;match (n) detach delete (n)&quot;</span>)  </span><br><span class="line">    create_node(clinet, <span class="string">&quot;学生&quot;</span>)  </span><br><span class="line">    create_node(clinet, <span class="string">&quot;教师&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="创建关联">创建关联</h2><h3 id="方法一-1">方法一</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clinet.run(<span class="string">&quot;match (a:老师 &#123;姓名:&#x27;陶老师&#x27;&#125;), (b:学生 &#123;姓名:&#x27;汪小阳&#x27;&#125;) create (a)-[rel:学生]-&gt;(b)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="方法二-1">方法二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clinet.run(<span class="string">&quot;match (a:老师), (b:学生) where a.姓名=&#x27;陶老师&#x27; and b.姓名=&#x27;汪小阳&#x27; create (a)-[rel:学生]-&gt;(b)&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="方法三定义函数-1">方法三、定义函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">create_relationship</span>(<span class="params">clinet,type1,type2,name1,name2,relation</span>):  </span><br><span class="line">    cmd = <span class="string">&quot;&quot;&quot;match (a:%s),(b:%s) where a.姓名=&quot;%s&quot; and b.姓名=&quot;%s&quot; create (a)-[rel:%s]-&gt;(b)&quot;&quot;&quot;</span> % (type1,type2,name1,name2,relation)  </span><br><span class="line">    clinet.run(cmd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"><span class="comment"># 打开数据库  </span></span><br><span class="line">clinet = py2neo.Graph(<span class="string">&quot;http://127.0.0.1:7474&quot;</span>, user=<span class="string">&#x27;neo4j&#x27;</span>, password=<span class="string">&#x27;LLAP1107&#x27;</span>, name=<span class="string">&#x27;neo4j&#x27;</span>)  </span><br><span class="line"><span class="comment"># 清空数据库  </span></span><br><span class="line">clinet.run(<span class="string">&quot;match (n) detach delete (n)&quot;</span>)</span><br><span class="line"></span><br><span class="line">create_relationship(clinet, <span class="string">&quot;老师&quot;</span>, <span class="string">&quot;学生&quot;</span>, <span class="string">&quot;陶老师&quot;</span>, <span class="string">&quot;汪小阳&quot;</span>, <span class="string">&quot;学生&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j安装和使用</title>
      <link href="/2023/02/06/Neo4j%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/06/Neo4j%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装-jdk">安装 jdk</h1><p>不多说，很简单~</p><h1 id="安装-neo4j">安装 neo4j</h1><p>下载桌面版安装包：<a href="https://neo4j.com/download/">neo4j</a>，按照下面步骤进行安装：</p><p>下载时会出现 token，记下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6IndyeTA4MThAMTI2LmNvbSIsIm1peHBhbmVsSWQiOiJnb29nbGUtb2F1dGgyfDEwMDEzNzMwOTMzMjQzMTg2MjU0MSIsIm1peHBhbmVsUHJvamVjdElkIjoiNGJmYjI0MTRhYjk3M2M3NDFiNmYwNjdiZjA2ZDU1NzUiLCJvcmciOiJsbnR1IiwicHViIjoibmVvNGouY29tIiwicmVnIjoi552_6ZizIOaxqiIsInN1YiI6Im5lbzRqLWRlc2t0b3AiLCJleHAiOjE3MDcyMzI0MDMsInZlciI6IioiLCJpc3MiOiJuZW80ai5jb20iLCJuYmYiOjE2NzU2OTY0MDMsImlhdCI6MTY3NTY5NjQwMywianRpIjoib0ozOGlSSU5rIn0.utNpl3CTvrOPFz0eGLtzbIbhP2ZJcVJWKbT5LeRcPpWb3bbUK5AkACqBEtGc_DdPNXKXw2Dg4pXOfdsODSzXBWHtnzdkhQFXnFmA5DDTPnIJTqauP-xty6LDdjueggNOkuekoEg-BxWSu7Y3pZIDMVxPxk6ZmmnuiC4iSIJRUACxhXn5skYJPgcOKyTFDzFXvNjBMxuhOAfTwG4KNJyyI6SHNUguVNyJrrguDC90gmRAF7gj5NF86GwK3thVrPpsiBUt0iXsRG1ioeR9ZJELlkvJx_gZ910amBFKlYAOJNtrE3_elu0j0ZaBURFkBoe1qnsbqfMbEBOjeDq-McMOLg</span><br></pre></td></tr></table></figure><p>点击进行安装：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062343317.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>修改安装位置为 D 盘：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062343990.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>启动软件并修改缓存位置：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062351227.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>输入保存的 token：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062352675.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>等待配置：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062353156.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>进入软件：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062355479.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="使用方法">使用方法</h1><h2 id="演示文件">演示文件</h2><p>进入演示文件：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062355054.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>按照下面的要求点击配置：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062358183.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="自定义项目">自定义项目</h2><p>新建项目：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070002747.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>修改名称并添加 DBMS：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070004595.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>配置 DBMS：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070008203.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>启动数据库：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070009709.png" alt="image.png" /> 打开项目：</p><p>注意这里可以有多种方式，我将演示 Browser。</p><blockquote><p><strong>Browser：</strong> 用于图数据可视化，同时可以输入 Cypher 语言进行图数据库相关的操作。优点是非常灵活，可以输入各种指令。缺点是可视化程度不是很高。注意，可以在内置 browser 打开，也可以在启动实例之后，打开浏览器输入地址 localhost：7474 打开 Browser 端。</p><p><strong>Bloom：</strong> 官方专门的可视化工具，功能强大，非技术人员也可以轻松使用，导入数据之后进行操作基本不用指令，点击/拖拽/选择就可以了。优点是数据可视化方面做的很好，缺点是，不够灵活（网友这样说）。</p></blockquote><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070010284.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>进入 Neo4j Browser 页面：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070011481.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>创建大学：<code>create(:大学&#123;name:"华中科技大学"&#125;)</code> 创建院系：<code>create(:院系&#123;name:"计算机科学与技术学院"&#125;)</code> 建立关系：<code>MATCH(p1:</code>大学<code>),(p2:</code>院系<code>) Create(p1)-[r:院系]-&gt;(p2)</code></p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070018229.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>点击左边关系 <code>院系</code>，右边自动生成可视化。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302070031821.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>如果需要删除节点，需要将其关系也一并删除：<code>MATCH (n:大学&#123;name:"华中科技大学"&#125;) DETACH DELETE(n)</code></p><h1 id="其他">其他</h1><h2 id="卸载注意事项">卸载注意事项</h2><p>除了刚刚安装的 neo4j 和 neo4j_data，还要删除 C:\Users\xxxxxx\. Neo4jDesktop文件。<a href="https://blog.csdn.net/qq_34045989/article/details/115458261">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱相关概念</title>
      <link href="/2023/02/06/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
      <url>/2023/02/06/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章来源： <a href="https://zhuanlan.zhihu.com/p/114470141">知识图谱嵌入(KGE)主流模型简介 - 知乎</a> <a href="https://zhuanlan.zhihu.com/p/77497246">电影知识图谱问答（三）|Apache Jena知识存储及SPARQL知识检索 - 知乎</a> <a href="https://zhuanlan.zhihu.com/p/77594347">电影知识图谱问答（四）| 问句理解及答案推理 - 知乎</a></p></blockquote><h1 id="知识图谱介绍">知识图谱介绍</h1><p>知识图谱是由大量的事实三元组组成，如（英国, 首都, 伦敦）便是真实世界中的知识，可用 <span class="math inline">\((h, r, t )\)</span> 进行表示，其中 <span class="math inline">\(h, t\)</span> 表示头尾实体，<span class="math inline">\(r\)</span> 表示关系。但我们知道，真实世界中知识是无限增长的，而知识图谱却不能包含真实世界中的所有知识，因此需在知识库中进行知识补全，或者称为<strong>链接预测</strong>。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062012617.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><strong>链接预测</strong>一个可行的方法便是将实体和关系进行 Embedding 表示，类似于 Word2Vec，将字或词表示成 Embedding 信息。然后<strong>根据实体和关系的 Embedding 信息进行预测</strong>，比如<strong>利用头实体和关系去预测尾实体</strong>，或者<strong>利用尾实体和关系去预测头实体</strong>。当然，Embedding 信息也可应用到其他领域，比如知识问答、文本信息增强、语义检索等。</p><p><strong>知识图谱嵌入 (Knowledge Graph Embedding, KGE)</strong> 学习知识库中的实体和关系的 Embedding 表示，是语义检索、知识问答、推荐等众多应⽤的基础研究。</p><h1 id="知识图谱嵌入kge">知识图谱嵌入（KGE）</h1><p>KGE 是将知识库中的实体和关系进行 Embedding 表示，模型规划为： - 翻译 (TransE, TransH, TransR, etc) - 双线性 (RESCAL, DisMult, ComplEx, etc) - 双曲几何 (Poincare, MuRE, etc) - 神经网络 (ConvE, CapsE, etc) - 旋转 (RotatE, QuatE, DihEdral, etc)</p><p>KGE 主要关注方面： - <strong>关系的多样性</strong>，如 1-1, 1-N, N-1, N-N 关系，对称/反对称、翻转、组合等信息。如翻译、旋转模型。 - <strong>实体的层次性</strong>，实体之间的上下位关系。如双曲空间模型。 - <strong>实体和关系的深层次交互信息</strong>。如双线性和神经网络模型。</p><h2 id="翻译模型">翻译模型</h2><blockquote><p>翻译模型是<strong>把关系当作头实体和尾实体之间的翻译</strong>，包括TransE, TransH, TransD等模型。</p></blockquote><h3 id="transe">TransE</h3><p><strong>TransE</strong> 认为 <span class="math inline">\(h+r≈t\)</span> ，即 r 是头尾实体之间的翻译关系，优化目标是最小化评分函数。TransE 能够解决 <strong>1-1 类别</strong>的关系，但不能够很好的解决 1-N, N-1, N-N 关系。比如（流浪地球，演员，吴京）、（流浪地球，演员，吴孟达）两个三元组，当头实体 <span class="math inline">\(h\)</span> 和关系 <span class="math inline">\(r\)</span> 相同时，TransE 认为所有尾实体 <span class="math inline">\(t\)</span> 具有相同的 Embedding 信息，但实际情况并非如此。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062019837.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="transh">TransH</h3><p>针对 TransE 存在的问题，<strong>TransH</strong> 把头实体 h 和尾实体 t 投影到关系所在的超平面中。经过投影后，尽管头实体 h 和关系 r 相同，尾实体 t 的 Embedding 信息也会不同，TransH 能够一定程度上解决多对多的关系。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062020361.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="transr">TransR</h3><p><strong>TransR</strong> 认为 TransE 和 TransH 均是把实体和关系放在同一空间中进行考虑，但实体可能具有多个不同方面的属性，不同的关系也关注着实体的不同属性，因此把实体和关系放在同一空间中考虑是不准确的。因此，TransR 构建实体空间和关系空间。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062024969.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="其他">其他</h3><p>除了TransE, TransH, TransR以外，还有其他Trans模型，考虑实体和关系的概率性、稀疏性等问题，此处不再赘述。但总体上，Trans模型均是把关系当作头尾实体之间的翻译，解决知识库中所存在的多对多问题。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062024241.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="双线性模型">双线性模型</h2><blockquote><p>双线性模型<strong>计算实体和关系在向量空间中潜在语义的可信度</strong>，包括RESCAL、DisMult、ComplEx等模型。</p></blockquote><h3 id="rescal">RESCAL</h3><p>RESCAL 把关系利用满秩矩阵表示，其实体和关系之间全是矩阵运算，因此实体和关系的信息可以进行深层次交互，非常具有表现力。但同时，<strong>RESCAL 容易过拟合</strong>，并且随着关系矩阵维度的增加，复杂度会很高，<strong>很难应用到大规模知识图谱。</strong></p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062031504.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="dismult">DisMult</h3><p>针对 RESCAL 存在的问题，DisMult 放松对关系矩阵的约束，把关系矩阵 M_r 利用对角矩阵表示。但 DisMult 过分简化了 RESCAL 模型，导致<strong>只能够解决知识库中存在的对称关系，不能够解决知识图谱中其他类型的关系。</strong></p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062034521.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="complex">ComplEx</h3><p>针对 DisMult 存在的问题，ComplEx 把 DisMult 扩展到复数空间表示。ComplEx 对 DisMult 扩展后，能够同时解决对称和非对称关系。ComplEx 首次在 KGE 中引入复数方法，还有其他模型利用复数空间解决问题，并且可解决除对称、非对称外更复杂的对称类型。</p><h3 id="其他-1">其他</h3><p>除 RESCAL, DisMult, ComplEx 外，还有其他双线性模型，考虑实体和关系的潜在语义信息，获取实体和关系的深层次交互信息。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062053189.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="神经网络模型">神经网络模型</h2><blockquote><p>多数翻译模型和双线性模型是16年之前模型，最近几年随着神经网络的兴起，也有利用神经网络解决KGE问题的模型，包括ConvE、CapsE等。</p></blockquote><h3 id="conve">ConvE</h3><p>ConvE 首先把头实体和关系转换为二维向量，接下来利用卷积层和全连接层获取交互信息，然后与矩阵 W 和尾实体进行计算，判断当前三元组的可信度。ConvE 模型上没什么新颖之处，只不过是比较早的利用卷积神经网络来对 KGE 进行建模。</p><h3 id="capse">CapsE</h3><p>CapsE 采用胶囊神经网络模型，首先把头实体、关系、尾实体表示成 <span class="math inline">\(k×3\)</span> 的矩阵，接下来通过卷积层获取其特征信息，然后对特征信息进行压缩，并进行动态路由，最后计算三元组的可信度。CapsE 只是胶囊网络在 KGE 问题上的简单应用，也没有特别新颖之处。</p><h3 id="kg-bert">KG-BERT</h3><p>KG-BERT 模型利用 BERT 进行 fine-tuning，获取头实体、关系、尾实体信息，然后取 CLS 信息进行二分类，判断当前三元组可信度。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062155966.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><strong>KGE 除了利用卷积神经网络、胶囊网络、BERT 模型外，也有模型利用深度神经网络、图注意力网络等方法。</strong></p><p>普通的神经网络模型不是特别适合解决KGE问题，不能够对知识图谱中实体的层次性、关系的多样性问题建模，仅仅只是获取实体和关系的深层次交互信息，没有可解释性。但可以多尝试图神经网络在KGE上的应用，比较符合图谱结构。</p><h2 id="双曲几何模型">双曲几何模型</h2><blockquote><p>上面多次提到实体间具有层次性，比如爷爷--父亲--儿子关系，类似于<strong>树状结构</strong>。此时，可以利用双曲空间性质，在双曲空间中对实体的层次性建模，包括Poincare, MuRP等模型。</p></blockquote><h3 id="poincare">Poincare</h3><p>Poincare采用双曲几何中的庞加莱圆盘进行建模，其空间曲率为负。因为庞加莱圆盘性质，能够对实体间的层次性建模，学习图谱间的层次性信息。但Poincare模型没有考虑到关系性质，而且不能够在庞加莱圆盘中进行复杂操作。另外，双曲空间需要黎曼优化方法，建议自行去了解相关数学知识，包括黎曼曲率张量、黎曼流形、黎曼优化等概念。</p><h3 id="murp">MuRP</h3><p>MuRP 相对于 Poincare 而言更加完善，MuRP 同时在双曲空间和欧式空间中建模，结合关系向量，能够处理图谱中所存在的多类型关系。MuRP 首先将实体向量定义在庞加莱圆盘中，接下来将实体映射到欧式空间，并和关系进行操作，然后再将实体映射回庞加莱圆盘中进行距离计算，并用黎曼方法优化。</p><h2 id="旋转模型">旋转模型</h2><blockquote><p>旋转模型<strong>把关系当作头实体和尾实体之间的旋转</strong>，包括RotatE、QuatE、DihEdral等模型。</p></blockquote><h3 id="rotate">RotatE</h3><p>RotatE认为知识库中存在多种类型的关系，如symmetry(e.g., marriage), antisymmetry(e.g., filiation), inversion(e.g., hypernym and hyponym), composition(e.g., my mother's husband is my father)关系，但以往的TransE, RESCAL, ConvE等模型均不能够解决上述关系。因此RotatE提出在复数空间中建模，把关系当作头尾实体之间的旋转，RotatE从理论上证明能够解决对称/反对称、翻转、组合关系。另外，RotatE认为在训练过程中，很多三元组明显是错误的，因此RotatE提出自对抗的负采样方法，让错误样本更加明显，负采样和损失函数公式如下所示。</p><h3 id="quate">QuatE</h3><p>RotatE 是在二维复平面空间中进行操作，那么很自然的可以推广到三维复平面空间中。三维情况下旋转可以利用欧拉角和四元数等方法，但欧拉角存在死锁问题，因此 QuatE 采用四元数进行旋转，四元数可表示为 <span class="math inline">\(Q=a+bi+cj+dk\)</span>。继续推广，可以利用 8 元数进行旋转，但此时复杂度升高，结果并没有提升太多。再往上推广，有 16 元数，但 16 元数的乘法不满足交换律和结合律，因此不再考虑。</p><h3 id="dihedral">DihEdral</h3><p>除了 RotatE 和 QuatE 利用复数空间解决对称/反对称、翻转、组合关系，DihEdral 利用群论知识来解决上述关系。DihEdral 采用二面体群进行旋转，二面体群具有两种性质，即旋转和对称操作。DihEdral 将多个二面体群组成对角矩阵，能够从理论上解决对称/反对称、翻转、组合（Abelian, Non-Abelian）关系。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062210283.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h1 id="知识图谱数据库">知识图谱数据库</h1><p>传统关系数据库（如 MySQL、MongoDB 等）不能体现知识间的层次关系，更不能进行知识推理和知识检索。</p><p><strong>常用的图数据库：Neo4j 和 Apache Jena。</strong></p><h2 id="neo4j">Neo4j</h2><p>Neo4j 是高性能、NoSQL 类型的图数据库，存储过程中将数据表示为节点，数据之间的关系表示为边，节点和边的类型可以是字符串、数字等。Neo4j 能够存储百亿节点，形成巨大的图网络结构，即大规模知识图谱。<strong>Neo4j 能够非常方便的将数据可视化</strong>，看出数据之间的关联关系。</p><h2 id="apache-jena">Apache Jena</h2><p>Apache Jena 是开源的 Java 语义网框架，用于链接数据和构建语义网，可存储 RDF、RDFS 类型数据。</p><p>Apache Jena 提供 TDB、Rule Reasoner、Fuseki 组件，其中 TDB 是 Jena 用于存储 RDF 类型数据的组件，属于存储层面的技术；Rule Reasoner 可进行简单规则推理，支持用户进行自定义推理规则；Fuseki 是 Jena 提供的 SPARQL 服务器，支持 SPARQL 语言进行检索，可在单机和服务器端高效运行。</p><p>因为知识图谱问答需定义很多推理规则，对可视化没有太多要求，所以我们选择 Apache Jena 来存储 RDF 数据。</p><p>接下来是基于 Jena 的实战。需要了解如何进行知识存储和知识检索，具体流程包括：将 RDF 类型数据转换成 TDB 类型数据、配置及启动 Apache Fuseki、利用 SPARQL 从 Apache Jena 中进行知识检索。</p><h3 id="rdf2tdb">RDF2TDB</h3><p>Apache Jena 需要 tdb 类型的数据，所以需要将已得到的 RDF 类型数据转换成 tdb 类型数据，转换方法可通过 Apache Jena 提供的工具进行实现。</p><h3 id="fuseki-配置">Fuseki 配置</h3><p>转换成 TDB 类型数据完成之后，如果想要在网页端进行查看和检索，还需要配置 Apache Fuseki。</p><h3 id="sparql-知识检索">SPARQL 知识检索</h3><p>数据存储成功之后，便能够通过 SPARQL 检索语言从 Apache Jena 数据库之中进行检索答案。比如问句 <strong>“流浪地球的主演有哪些？”</strong> ，转换成如下 SPARQL 查询语句需要经过以下步骤。</p><h4 id="问句理解">问句理解</h4><p>针对用户提问的自然语言问句，首先需要理解其中的深层次语义信息，即获取问句实体和目标属性信息。</p><p>以问句 <strong>“流浪地球的导演是谁？”</strong> 为例： - 实体：流浪地球 - 目标属性：导演 所采用的方法分别是<strong>实体识别</strong>和<strong>属性链接</strong>。</p><h5 id="实体识别">实体识别</h5><p>从问句中提取出实体可以采用以下两种方法： - 构建诸如 <strong>BiLSTM-CRF</strong> 等深度学习模型，然后利用训练好的深度学习模型预测出问句实体。<strong>这种方法能够预测得到训练数据中未出现过的电影名称</strong>，预测准确率保持在 90%以上。缺点是需要构建训练数据，从头开始训练深度学习模型，耗费时间长； - 构建<strong>实体词表</strong>，从问句中提取词表中所包含的实体。词表方法构建快捷方便，缺点是<strong>只能够发现词表中包含的电影实体名称</strong>，无法发现新的电影实体。</p><p>比较推荐的方法是<strong>词表+BiLSTM-CRF</strong> 深度学习模型，但此处为了构建方便，只采用词表方法。词表构建方法是从爬取的数据之中，选出其中的<strong>电影和书籍名称</strong>、<strong>人物名称</strong>加入到词表之中。另外可加上深度学习预测模型提高效果。</p><h5 id="属性链接">属性链接</h5><p>属性链接可以采用以下两种方法： - 构建诸如 CNN 等多分类深度学习模型，然后利用训练好的深度学习模型预测问句的目标属性。 - 构建关键词集合，把问句中所包含的关键词当作问句的目标属性。</p><p>同样，此处问了方便，直接采用关键词方法。可自主加上CNN等多分类预测模型。</p><p>需要注意的是，同一目标属性可以表达成多种含义。比如流浪地球的<strong>评分</strong>是多少？、也可以表达成流浪地球在豆瓣有多少<strong>分数</strong>？，那么此时我们就需要同时考虑<strong>评分</strong>和<strong>分数</strong>关键词。即：<code>rating = (W ('评分') | W ('分数'))</code></p><h4 id="答案推理">答案推理</h4><h5 id="基于规则的答案推理">基于规则的答案推理</h5><p>获取问句的实体和目标属性之后，便可根据规则模版将传统<strong>自然语言问句</strong>转换得到<strong>SPARQL</strong>查询语句，进而从 Apache Jena 数据库之中推理得到问题答案。构建规则模型可利用 Python Refo 库进行构建。</p><p>将问句转换成 SPARQL 查询语句之后，便可从 Apache Jena 之中检索得到问句答案，为提高推理的准确率，还可以使用自定义推理规则进行补充。</p><h5 id="基于表示学习的答案推理">基于表示学习的答案推理</h5><p>通过问句理解模块，能够得到问句的实体和目标属性信息。然后结合基于模版的答案推理方法，能够将问句转换成 SPARQL 查询语句，进而在 Apache Jena 数据库之中推理得到问题答案。<strong>但基于规则的答案推理仅能够处理已定义的规则，不能覆盖问句的所有情况。</strong></p><p>因为不能定义所有规则，所以我们可以采用基于表示学习的答案推理方法，比如知识图谱嵌入中经典的 <strong>Trans 系列方法</strong>。</p><p>这里以 <strong>TransE</strong> 为例进行解释，知识图谱中三元组向量化后可以表示为 <strong>&lt;h, r, t&gt;</strong>，其中头实体为 h、关系为 r、尾实体为 t。TransE 假设实体和关系之间存在，即头实体 h 加上关系 r 的向量信息近似等于尾实体，那么我们便能够通过头实体和关系预测得到尾实体。也就是说，能够通过问句中实体和目标属性信息，预测得到问句答案。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302062006992.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h2 id="gstore">gStore</h2><p>gStore 是北大团队经过十余年时间研发的原生 RDF 图数据库系统，图数据库当前主流有 RDF 和属性图两种数据模型，具体哪种没有高低之分。但是无论 RDF 还是 RDF 图数据库的查询语言 SPARQL 都是 W3C 定义的事实标准，在进行使用时有规可循。</p><p>gStore所有底层代码都是北大团队自主编写的，当前一共有十几万行代码，这样在自主可控方面是非常有保障的。而且对于鲲鹏/飞腾/海光/兆芯等国产CPU和统信UOS/麒麟国产操作系统都进行适配。本人实际使用时其查询性能相比于国际主流的图数据库也是有明显的性能优势的，这也是来源于学术界的一个优势所在，gStore单机版存储容量为50亿三元组，同时支持分布式部署来解决单机性能瓶颈，但是分布式版本不开源。而且已经在很多行业也进行了落地（可见官网案例）。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode总结笔记</title>
      <link href="/2022/11/15/LeetCode%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/15/LeetCode%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="初始化">初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];    <span class="comment">//初始化为null</span></span><br><span class="line"><span class="type">int</span>[] i = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];          <span class="comment">//初始化为0</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>];    <span class="comment">//初始化为false</span></span><br></pre></td></tr></table></figure><h1 id="字符">字符</h1><h2 id="char">char</h2><h4 id="相等操作">相等操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 == c2;</span><br></pre></td></tr></table></figure><h4 id="运算">运算</h4><p>字符支持加减运算，但是不可以用 <code>c = (char)('a' + (c - 'A'));</code>，因为 Java 中字符（串）一旦声明就不能改变，这和 C/C++不一样。但是可以用新的变量保存字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_c = (<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span> + (old_c - <span class="string">&#x27;A&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="string">string</h2><h3 id="常用函数">常用函数</h3><h4 id="判断字符是否包含在字符串中">判断字符是否包含在字符串中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.indexOf(c) != -<span class="number">1</span>     <span class="comment">//表示包含</span></span><br></pre></td></tr></table></figure><h4 id="判断字符串是否包含在字符串中">判断字符串是否包含在字符串中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.contains(s2)      <span class="comment">//如果s2包含在s1中，则返回true</span></span><br></pre></td></tr></table></figure><h4 id="compareto比较">compareTo()比较</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.compareTo(s2);    <span class="comment">//如果s1&gt;s2，返回1；如果s1&lt;s2，返回-1；如果相等，返回0</span></span><br></pre></td></tr></table></figure><h4 id="substring截断">substring()截断：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = s.substring(<span class="number">1</span>,<span class="number">5</span>);    <span class="comment">//截取下标1~4</span></span><br><span class="line"></span><br><span class="line">s = s.substring(<span class="number">5</span>);   <span class="comment">//截取下标为5~end</span></span><br></pre></td></tr></table></figure><h4 id="replace替换">replace()替换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);    <span class="comment">//将全文的-变成无</span></span><br></pre></td></tr></table></figure><h4 id="equals相等">equals()相等</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2);</span><br></pre></td></tr></table></figure><h4 id="split分割">split()分割</h4><blockquote><p>对于<code>String s = "a  b     c  d e f      g"</code></p></blockquote><h5 id="分割单个空格">分割单个空格</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = s.split(<span class="string">&quot; &quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>//a // //b // // // // //c // //d //e //f // // // // // //g //</p></blockquote><h5 id="分割多个连续空格">分割多个连续空格</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = s.split(<span class="string">&quot;\\s+&quot;</span>);    <span class="comment">//正则</span></span><br></pre></td></tr></table></figure><blockquote><p>//a //b //c //d //e //f //g</p></blockquote><h4 id="字典序排序">字典序排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">Arrays.sort(sc);</span><br><span class="line">s = <span class="keyword">new</span> <span class="title class_">String</span>(sc);</span><br></pre></td></tr></table></figure><h2 id="常用转换">常用转换</h2><h3 id="字符字符串">字符➡️字符串</h3><h4 id="将单个字符转为字符串">将单个字符转为字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> String.valueOf(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="将字符数组转为字符串">将字符数组转为字符串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(sa1);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sa1);</span><br></pre></td></tr></table></figure><h3 id="字符串字符">字符串➡️字符</h3><h4 id="提取完整数组">提取完整数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br></pre></td></tr></table></figure><h4 id="提取字符串中某一下标的字符">提取字符串中某一下标的字符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">st</span> <span class="operator">=</span> s.charAt(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="字符整数">字符➡️整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="整数字符串">整数➡️字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h3 id="整数字符">整数➡️字符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="字符串整数">字符串➡️整数</h3><p>使用<code>Integer.parseInt(s)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(s);</span><br></pre></td></tr></table></figure><h2 id="stringbuilder">StringBuilder</h2><blockquote><p>String内容是不可变的，StringBuilder内容是可变的</p><p>StringBuilder处理字符串性能比String好</p></blockquote><h3 id="创建">创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><h3 id="插入">插入</h3><h4 id="尾部插入">尾部插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.append(<span class="string">&quot;wry&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="中间插入">中间插入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.insert(<span class="number">0</span>,<span class="string">&#x27;w&#x27;</span>);    <span class="comment">//在下标为0之前插入字符w</span></span><br></pre></td></tr></table></figure><h3 id="长度">长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br></pre></td></tr></table></figure><h3 id="删除">删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.delete(<span class="number">6</span>, <span class="number">14</span>);    <span class="comment">//删除下标为[6,14)</span></span><br></pre></td></tr></table></figure><h3 id="转换">转换</h3><h4 id="stringbuilder转为string">StringBuilder转为String</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h4 id="string转为stringbuilder">String转为StringBuilder</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br></pre></td></tr></table></figure><h1 id="数组">数组</h1><h2 id="赋值">赋值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(nums, Integer.MAX_VALUE);    <span class="comment">//对数组进行一次性赋值</span></span><br></pre></td></tr></table></figure><h2 id="自定义排序">自定义排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(logs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] l1, <span class="type">int</span>[] l2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l1[<span class="number">0</span>]-l2[<span class="number">0</span>];    <span class="comment">//结果为1表示l1和l2调换</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="排序去重">排序+去重</h2><blockquote><p>使用Stram 流</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = Arrays.stream(arr).sorted().distinct().toArray();</span><br></pre></td></tr></table></figure><h2 id="判断相等">判断相等</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两个数组是否一样</span></span><br><span class="line">Arrays.equals(arr1, arr2);</span><br></pre></td></tr></table></figure><h2 id="拷贝">拷贝</h2><h3 id="深拷贝">深拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(原数组, 原数组起点, 新数组, 新数组起点, 长度);</span><br></pre></td></tr></table></figure><h1 id="list">list</h1><blockquote><p>List本质上就是动态数组</p></blockquote><h2 id="构建">构建</h2><h3 id="对于单个list">对于单个List</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><blockquote><p>不推荐 <code>ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();</code></p></blockquote><h3 id="对于嵌套list">对于嵌套List⭐</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; ll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="初始化-1">初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将nums转为list</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将旧list的内容赋给新list（深拷贝）</span></span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1);</span><br></pre></td></tr></table></figure><h2 id="添加">添加</h2><h4 id="对于单个list-1">对于单个List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.add(r);    <span class="comment">//r必须是list的&lt;&gt;内的类型，在尾部插入</span></span><br></pre></td></tr></table></figure><h4 id="对于嵌套list-1">对于嵌套List</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br></pre></td></tr></table></figure><h2 id="搜索">搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.get(index);    <span class="comment">//获取list下标为index的数值</span></span><br></pre></td></tr></table></figure><h2 id="查找某个元素是否在其中">查找某个元素是否在其中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(s);    <span class="comment">//查找s这个元素是否在list中</span></span><br></pre></td></tr></table></figure><h2 id="数组list">数组➡️List</h2><p><code>Arrays. asList</code> 将数组转化成 List 集合，但是得到的 List 的长度是不可改变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.add(Arrays.asList(x,y));        <span class="comment">//在嵌套list（res）中加入一个由x、y两个元素构成的list</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：<br />（1）该方法适用于对象型数据的数组（String、Integer...）<br />（2）该方法不建议使用于基本数据类型的数组（byte, short, int, long, float, double, boolean）<br />（3）该方法将数组与 List 列表链接起来：当更新其一个时，另一个自动更新<br />（4）不支持 add ()、remove ()、clear () 等方法</p></blockquote><h1 id="动态数组-arraylist">动态数组 ArrayList</h1><h2 id="构建-1">构建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><h2 id="添加-1">添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al.add(<span class="number">2</span>);    <span class="comment">//将整数2加入动态数组</span></span><br></pre></td></tr></table></figure><h2 id="定点添加">定点添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al.add(<span class="number">2</span>,<span class="number">1</span>);  <span class="comment">//将整数1加入动态数组的2的位置（作为第三个元素）（第一个是index，第二个是元素值）</span></span><br></pre></td></tr></table></figure><h2 id="替换">替换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al.set(<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">// 将下标为2的元素替换为数字3</span></span><br></pre></td></tr></table></figure><h2 id="删除-1">删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al.remove(<span class="number">1</span>);     <span class="comment">//删掉第二个元素</span></span><br></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = al.get(<span class="number">1</span>);   <span class="comment">//获取下标为1的元素的值</span></span><br></pre></td></tr></table></figure><h2 id="长度-1">长度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> al.size();</span><br></pre></td></tr></table></figure><h2 id="排序">排序</h2><h3 id="升序排序从小到大">升序排序（从小到大）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list);</span><br></pre></td></tr></table></figure><h3 id="降序排序从大到小">降序排序（从大到小）🌟</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer n1, Integer n2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n2-n1;     <span class="comment">//如果return&gt;0则对调</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="deque双端队列">Deque双端队列</h1><p>两端都可以进出，FIFO（先进先出）</p><h2 id="构造">构造</h2><p>注意：ArrayDeque&lt;&gt;比 LinkedList 更快<a href="https://leetcode.cn/circle/article/bXc4tx/">力扣</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="操作">操作</h2><p>端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p><table><thead><tr class="header"><th></th><th>第一个元素 (头部)</th><th></th><th>最后一个元素 (尾部)</th><th></th></tr></thead><tbody><tr class="odd"><td></td><td>抛出异常</td><td>特殊值</td><td>抛出异常</td><td>特殊值</td></tr><tr class="even"><td>插入</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr class="odd"><td>删除</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr class="even"><td>检查</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><h2 id="deque与queue的对照">Deque与Queue的对照</h2><table><thead><tr class="header"><th>Queue方法</th><th>等效Deque方法</th></tr></thead><tbody><tr class="odd"><td>add(e)</td><td>addLast(e)</td></tr><tr class="even"><td>offer(e)</td><td>offerLast(e)</td></tr><tr class="odd"><td>remove()</td><td>removeFirst()</td></tr><tr class="even"><td>poll()</td><td>pollFirst()</td></tr><tr class="odd"><td>element()</td><td>getFirst()</td></tr><tr class="even"><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p><table><thead><tr class="header"><th><strong>堆栈方法</strong></th><th><strong>等效Deque方法</strong></th></tr></thead><tbody><tr class="odd"><td>push(e)</td><td>addFirst(e)</td></tr><tr class="even"><td>pop()</td><td>removeFirst()</td></tr><tr class="odd"><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p><strong>但是Java没有栈，只能用Deque双端队列代替。</strong></p><p>需要多次使用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line">Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">dq.addLast(st);</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出并返回</span></span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> dq.pollLast();</span><br></pre></td></tr></table></figure><h1 id="stream流">Stream流</h1><p>Stream流是Java8开始有的一个很装逼的功能，可以对流直接进行操作。</p><p><a href="LeetCode逐题笔记.md#46、全排列">46</a>使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br></pre></td></tr></table></figure><p>请注意，这里的res存的时Integer的集合(列表)，但是num时int类型的，曾经说到过int转为Integer可以用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(a);</span><br></pre></td></tr></table></figure><p>但是这个方法很不好，而Java8的流操作可以处理：</p><ol type="1"><li><code>Arrays.stream(nums)</code>表示将数组nums转为流</li><li><code>.boxed()</code>表示将流的类型提升，比如int变成Integer等等</li><li><code>.collect(Collectors.toList())</code>基本是流操作必备的结尾，表示将流转为List集合类型</li></ol><p>此外，流操作还有很多其他的用法：</p><p><a href="https://baijiahao.baidu.com/s?id=1738098020923007265&amp;wfr=spider&amp;for=pc">全面吃透JAVA Stream流操作，让代码更加的优雅 (baidu.com)</a></p><ul><li><p><strong>开始管道</strong></p><p>主要负责新建一个Stream流，或者基于现有的数组、List、Set、Map等集合类型对象创建出新的Stream流。</p></li></ul><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041633685.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><p><strong>中间管道</strong>⭐</p><p>负责对Stream进行处理操作，并返回一个新的Stream对象，中间管道操作可以进行<strong>叠加</strong>。</p></li></ul><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041633686.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><ul><li><p><strong>终止管道</strong></p><p>顾名思义，通过终止管道操作之后，Stream流将<strong>会结束</strong>，最后可能会执行某些逻辑处理，或者是按照要求返回某些执行后的结果数据。</p></li></ul><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041633687.jpeg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h2 id="数组转为-list">数组转为 list</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h1 id="链表">链表</h1><p>Java语言使用链表格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = head;</span><br><span class="line">        head.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">MyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">linkedList.get(<span class="number">1</span>);    </span><br></pre></td></tr></table></figure><h1 id="hashmap散列表">HashMap（散列表）</h1><h2 id="创建-1">创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br></pre></td></tr></table></figure><h2 id="添加键值对">添加键值对</h2><p>key 如果已经存在，则 value 会直接覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.put(<span class="string">&quot;abc&quot;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="删除键值对">删除键值对</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.remove(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="查找值">查找值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.get(<span class="string">&quot;abc&quot;</span>);    <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure><h2 id="更新值">更新值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.replace(<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>);    <span class="comment">//以后hash里面&quot;abc&quot;对应的value就是3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.replace(<span class="string">&quot;abc&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">//只对hash键值对为&quot;abc&quot;-2的修改value为3，如果键值对不符合则返回false</span></span><br></pre></td></tr></table></figure><h2 id="查找键值对数量">查找键值对数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.size()</span><br></pre></td></tr></table></figure><h2 id="判断是否为空">判断是否为空</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.isEmpty()    <span class="comment">//如果为空返回true</span></span><br></pre></td></tr></table></figure><h2 id="判断是否有某个key">判断是否有某个key</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.containsKey(<span class="string">&quot;abc&quot;</span>)    <span class="comment">//如果有则返回true</span></span><br></pre></td></tr></table></figure><h2 id="判断是否有某个value">判断是否有某个value</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.containsValue(<span class="number">3</span>)    <span class="comment">//如果有则返回true</span></span><br></pre></td></tr></table></figure><h2 id="遍历">遍历⭐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一、forEach</span></span><br><span class="line">hash.forEach((key,value)-&gt; &#123;</span><br><span class="line">    <span class="comment">//对于每一组key和value的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> value.toString() + key;</span><br><span class="line">    res.add(s);</span><br><span class="line">&#125;);    <span class="comment">//不要忘记分号</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二、最推荐，遍历entey获取key和value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; entry : hash.entrySet()) &#123;  <span class="comment">//entrySet()返回hashMap中所有映射项的集合集合视图。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三、单独取出key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : hash.KeySet()) &#123;    <span class="comment">//keySet()返回hashMap中所有key组成的集合视图。</span></span><br><span class="line">    <span class="comment">//对key操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String value : hash.values()) &#123;    <span class="comment">//values()返回hashMap中所有value组成的集合视图。</span></span><br><span class="line">    <span class="comment">//对key操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除所有键值对">删除所有键值对</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.clear();</span><br></pre></td></tr></table></figure><h2 id="获取指定-key-对应对-value如果找不到-key-则返回设置的默认值">获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = hash.getOrDefault(key,defaultvalue);     <span class="comment">//如果key存在，则相当于get()；如果key不存在，则返回的是defaultvalue</span></span><br></pre></td></tr></table></figure><h2 id="如果-key-存在则将原始值1如果-key-不存在则加入value-设置为-1">🌟如果 key 存在，则将原始值+1；如果 key 不存在，则加入（value 设置为 1）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.put(key, hash.getOrDefault(key,<span class="number">0</span>)+<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="set-集合">Set 集合</h1><blockquote><p>时间复杂度 <span class="math inline">\(n\)</span></p></blockquote><p>Set 表示唯一对象的集合。集合中元素的排序是不相关的。</p><h4 id="hashset">HashSet</h4><p>HashSet 基于 HashMap 来实现的，是一个<strong>不允许有重复元素的集合</strong>。</p><p>HashSet 允许有 null 值。</p><p>HashSet <strong>是无序的，即不会记录插入的顺序</strong>。</p><p>HashSet 实现了 Set 接口。（这就是为什么这个解法可以使用 <code>Set&lt;Long&gt; set = new HashSet&lt;&gt;();</code>）</p><p>Set 对象的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Long&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Set 对象的添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.add(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>Set 对象的判断是否存在操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.contains(k)     <span class="comment">//判断k这个值在set中是否存在，存在则返回true</span></span><br></pre></td></tr></table></figure><p>Set 判断一个 set 集合是否包含在另一个集合中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.containsAll(set2)     <span class="comment">//set2是否是set1的子集</span></span><br></pre></td></tr></table></figure><p>合并 set</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1.addAll(set2);     <span class="comment">// 将set2中的所有元素加入set1中</span></span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.remove(<span class="number">6</span>);    <span class="comment">// 删除6这个元素</span></span><br></pre></td></tr></table></figure><p>Set 清空功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.clear();</span><br></pre></td></tr></table></figure><h1 id="小根堆">小根堆</h1><blockquote><p>时间复杂度：<span class="math inline">\(O(log(n))\)</span></p></blockquote><h2 id="创建-2">创建：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Long&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="添加操作">添加操作：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.add(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="判断是否为空-1">判断是否为空：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.isEmpty()    <span class="comment">//如果是空则返回true</span></span><br></pre></td></tr></table></figure><h2 id="弹出操作弹出最小的数并返回此数">弹出操作（弹出最小的数，并返回此数）：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br></pre></td></tr></table></figure><h1 id="大根堆">大根堆</h1><h2 id="创建-3">创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果b&gt;a，则返回正值，表示顺序要替换</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a,b)-&gt;b-a);    </span><br></pre></td></tr></table></figure><h2 id="复杂构建">复杂构建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果a[1]-a[0]大的放在根节点</span></span><br><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">int</span>[]&gt;((a,b)-&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a[<span class="number">1</span>]-a[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> b[<span class="number">1</span>]-b[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> y-x;   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="添加-2">添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">q.offer(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="弹出">弹出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.poll();    <span class="comment">//弹出最大（最小）的元素</span></span><br></pre></td></tr></table></figure><h1 id="长度函数">长度函数</h1><ol type="1"><li><p><code>length</code>：<strong>数组</strong>长度</p></li><li><p><code>length()</code>：<strong>字符串</strong>长度</p></li><li><p><code>size()</code>：<strong>列表</strong>长度</p></li><li><p>int转为Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(a);</span><br></pre></td></tr></table></figure></li><li><p>数组的排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);     <span class="comment">//原地修改nums数组</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="位运算">位运算</h1><table><thead><tr class="header"><th>操作符</th><th>描述</th><th>例子</th></tr></thead><tbody><tr class="odd"><td>＆</td><td>如果相对应位都是 1，则结果为 1，否则为 0</td><td>（A＆B），得到 12，即 00001100</td></tr><tr class="even"><td>|</td><td>如果相对应位都是 0，则结果为 0，否则为 1</td><td>（A|B）得到 61，即 00111101</td></tr><tr class="odd"><td>^</td><td>如果相对应位值相同，则结果为 0，否则为 1</td><td>（A^B）得到 49，即 00110001</td></tr><tr class="even"><td>〜</td><td>按位取反运算符翻转操作数的每一位，即 0 变成 1，1 变成 0。</td><td>（〜A）得到-61，即 11000011</td></tr><tr class="odd"><td>&lt;&lt;</td><td>按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td>A&lt;&lt;2 得到 240，即 11110000</td></tr><tr class="even"><td>&gt;&gt;</td><td>按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td>A&gt;&gt;2 得到 15 即 1111</td></tr><tr class="odd"><td>&gt;&gt;&gt;</td><td>按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td>A&gt;&gt;&gt;2 得到 15 即 00001111</td></tr></tbody></table><h1 id="并查集">并查集</h1><p>模板题： <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/description/">#1971</a></p><p><strong>模板代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] bc, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bc[x]!=x) &#123;   </span><br><span class="line">            bc[x] = find(bc,bc[x]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bc[x];    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] bc, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootx</span> <span class="operator">=</span> find(bc,x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rooty</span> <span class="operator">=</span> find(bc,y);</span><br><span class="line">        <span class="keyword">if</span> (rootx==rooty) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bc[rootx] = rooty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] bc = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            bc[i] = i;        <span class="comment">// 初始每个节点的根就是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序集合-treeset">有序集合 TreeSet⭐</h1><blockquote><p>时间复杂度 <span class="math inline">\(log(n)\)</span></p></blockquote><p>TreeSet 是一个有序集合，它扩展了 AbstractSet 类并实现了 NavigableSet 接口。</p><ul><li>它存储唯一的元素</li><li>它不保留元素的插入顺序</li><li>它按升序对元素进行排序</li><li>它不是线程安全的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">title: 排序原理</span><br><span class="line">TreeSet 存储对象的时候，可以排序，但是需要指定排序的算法  </span><br><span class="line">- Integer 能排序 (有默认顺序)，String 能排序 (有默认顺序)，自定义的类存储的时候出现异常 (没有顺序)  </span><br><span class="line">- 对于数字直接是按从小到大顺序排序</span><br><span class="line">- 对于字符串需要使用iterator()进行排序</span><br><span class="line">```java</span><br><span class="line">public class TreeSetTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set ts = new TreeSet();</span><br><span class="line">        ts.add(&quot;abc&quot;);</span><br><span class="line">        ts.add(&quot;xyz&quot;);</span><br><span class="line">        ts.add(&quot;rst&quot;);</span><br><span class="line">        Iterator it = ts.iterator();    //重点</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            System.out.print(it.next());</span><br><span class="line">            System.out.print(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//abc rst xyz</span><br></pre></td></tr></table></figure><ul><li>如果想把自定义类的对象存入 TreeSet 进行排序，那么必须实现 Comparable 接口<br /></li><li>在类上 implement Comparable<br /></li><li>重写 <code>compareTo()</code> 方法<br /></li><li>在方法内定义比较算法, 根据大小关系，返回正数负数或零<br /></li><li>在使用TreeSet存储对象的时候，<code>add()</code>方法内部就会自动调用<code>compareTo()</code>方法进行比较，根据比较结果使用二叉树形式进行存储 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 创建</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ul><h2 id="添加-3">添加</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.add(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><h2 id="删除-2">删除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.remove(<span class="number">3</span>);   <span class="comment">//将元素3删除</span></span><br></pre></td></tr></table></figure><h2 id="清空">清空</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.clear();</span><br></pre></td></tr></table></figure><h2 id="查询元素数量">查询元素数量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.size();</span><br></pre></td></tr></table></figure><h2 id="判空">判空</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.isEmpty();</span><br></pre></td></tr></table></figure><h2 id="判断存在">判断存在</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.contains(<span class="number">3</span>);    <span class="comment">//判断3元素是否存在</span></span><br></pre></td></tr></table></figure><h2 id="返回首个元素">返回首个元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.first();</span><br></pre></td></tr></table></figure><h2 id="返回最后元素">返回最后元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.last()</span><br></pre></td></tr></table></figure><h2 id="返回小于指定值的-treeset-的元素">返回小于指定值的 TreeSet 的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.headSet(<span class="number">2</span>);      <span class="comment">//返回小于2的</span></span><br></pre></td></tr></table></figure><h2 id="返回大于指定值的-treeset-的元素">返回大于指定值的 TreeSet 的元素</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.tailSet(<span class="number">2</span>);      <span class="comment">//返回大于2的</span></span><br></pre></td></tr></table></figure><h2 id="迭代器-iterator-遍历">迭代器 iterator () 遍历🌟</h2><p>返回类型为 Iterator ，它以升序返回 TreeSet 元素。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorOfTreeSet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeSet &lt;String&gt; tree_set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br><span class="line">        tree_set.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">        tree_set.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line">        tree_set.add(<span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line">        tree_set.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line">        tree_set.add(<span class="string">&quot;SFDC&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;TreeSet: &quot;</span> + tree_set);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;tree_set.iterator(): &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Iterator</span> <span class="variable">itr</span> <span class="operator">=</span> tree_set.iterator(); itr.hasNext();)</span><br><span class="line">            System.out.println(itr.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeSet: [C, C++, JAVA, PHP, SFDC]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//tree_set.iterator():</span></span><br><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="comment">//PHP</span></span><br><span class="line"><span class="comment">//SFDC</span></span><br></pre></td></tr></table></figure><h1 id="二分查找">二分查找</h1><blockquote><p>模拟 C++的 <code>lower_bound()</code> 和 `upper_bound()</p></blockquote><h2 id="大于等于target">大于等于target</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 能找到 k 最好，找不到就找稍微大一点的  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findBigger</span> <span class="params">(<span class="type">int</span> k)</span> &#123;  </span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=nums.length-<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">while</span> (l&lt;r) &#123;  </span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;  </span><br><span class="line"><span class="keyword">if</span> (nums[m]&lt;k) &#123;  </span><br><span class="line">l = m+<span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">r = m;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> l;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小于等于target">小于等于target</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 能找到k最好，找不到就找稍微小一点的  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findSmaller</span><span class="params">(<span class="type">int</span> k)</span> &#123;  </span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>, r=nums.length-<span class="number">1</span>;  </span><br><span class="line"><span class="keyword">while</span> (l&lt;r) &#123;  </span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 向上取整  </span></span><br><span class="line"><span class="keyword">if</span> (nums[m]&lt;=k) &#123;  </span><br><span class="line">l = m;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> &#123;  </span><br><span class="line">r = m - <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> l;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode逐题笔记</title>
      <link href="/2022/11/15/LeetCode%E9%80%90%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/15/LeetCode%E9%80%90%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和">1、两数之和</h1><h3 id="length的使用">length的使用</h3><ol type="1"><li><p><code>length</code></p><p>length是属性，是<strong>数组</strong>的长度，使用时的形式是：数组<code>.length</code>不加括号</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] cp;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cpdomains.length;</span><br></pre></td></tr></table></figure></li><li><p><code>length()</code></p><p>length()是<strong>字符串</strong>自带的方法，是求字符串长度的，使用形式是：<code>str.length()</code></p></li><li><p><code>size()</code></p><p>size()是<strong>列表</strong>的自带方法，求的是列表的长度，使用形式是：<code>list.size()</code></p></li></ol><h1 id="两数相加">2. 两数相加</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303170957822.png" /></p><p>中等题，考察链表的操作和构造。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="literal">null</span> || l2!=<span class="literal">null</span> || add!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> add;</span><br><span class="line">            <span class="keyword">if</span> (l1!=<span class="literal">null</span>) &#123;</span><br><span class="line">                k += l1.val;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2!=<span class="literal">null</span>) &#123;</span><br><span class="line">                k += l2.val;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                k -= <span class="number">10</span>;</span><br><span class="line">                add = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                add = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(k);</span><br><span class="line">            p.next = temp;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无重复字符的最长子串">3. 无重复字符的最长子串</h1><blockquote><p>考察： #滑动窗口 #双指针 #Set</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221737239.png" /></p><p>中等题。注意审题，因为 <code>s</code> 由英文字母、数字、符号和空格组成，所以不能使用位运算。这里使用 hashset。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (i&lt;n &amp;&amp; j&lt;n) &#123;    <span class="comment">// j表示待判断的，i表示起点</span></span><br><span class="line">            <span class="keyword">if</span> (i == j &amp;&amp; i &lt; n-<span class="number">1</span>) &#123;</span><br><span class="line">                set.add(sc[i]);</span><br><span class="line">                j = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(sc[j])) &#123;    <span class="comment">// 表示过去没有</span></span><br><span class="line">                set.add(sc[j]);     <span class="comment">// 当前j可以加入</span></span><br><span class="line">                res = Math.max(res, j-i+<span class="number">1</span>);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;     <span class="comment">// j下标的元素已经有了，不能继续处理了，需要删i</span></span><br><span class="line">                set.remove(sc[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="寻找两个正序数组的中位数">4、寻找两个正序数组的中位数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626674.png" alt="image-20220922220554936" /><figcaption aria-hidden="true">image-20220922220554936</figcaption></figure><h1 id="最长回文子串">5、最长回文子串</h1><h2 id="方法一中心扩张法">方法一、中心扩张法</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626675.png" alt="image-20220920211209159" /><figcaption aria-hidden="true">image-20220920211209159</figcaption></figure><h3 id="注意">注意</h3><ol type="1"><li><p>注意出现“aaaa”、“aaa”这样相同字符的回文子串，因此需要在第一个while循环中判断从当前i开始左右是否相同。</p></li><li><p>在完成相同字符的判断后，进行left-1和right+1同时判断，查找回文数。</p></li><li><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(1)</p><p>时间换空间</p></li></ol><h3 id="替换">替换</h3><ol type="1"><li><p>将字符串转为数组的方式有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] str = s.toCharArray();</span><br></pre></td></tr></table></figure></li><li><p>提取字符串中某一下标的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">st</span> <span class="operator">=</span> s.charAt(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法二动态规划">方法二、动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626676.png" alt="image-20220920211102615" /><figcaption aria-hidden="true">image-20220920211102615</figcaption></figure><p>二维数组是动态规划最常用的方法</p><h3 id="注意-1">注意</h3><ol type="1"><li><p>此方法核心在于按照子串长度进行遍历，判断l长度的子串是否为回文子串，即判断除去两个端点的子串是否为回文子串</p></li><li><p>1中至少要有三个元素。在只有1个元素时，回文子串就是它自己；有两个元素时，如果两个元素相等则为回文子串。</p></li><li><p>时间复杂度：O(n^2)</p><p>空间复杂度：O(n^2)</p></li></ol><h1 id="盛最多水的容器">11、盛最多水的容器</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626677.png" alt="image-20220924130921512" /><figcaption aria-hidden="true">image-20220924130921512</figcaption></figure><p>逻辑性很强的题目！！</p><p>双指针，一个指向最左边，一个指向最右边，这两个指针所指的相对长的板后面称为长板，相对短的板称为短板。</p><p>对于左右指针逼近，容器的底边长度一定是在减小。</p><p>容器的盛水量取决于底边长度和<strong>短板</strong>。</p><p>所以！如果移动短板，可能会遇到更短或者相等的板，那是不幸，容量变小；如果遇到长一些的板子，容量可能变小也可能不变也可能变大。</p><p>如果移动长板，底边长度一定减小，如果遇到的是长板，因为容器的高取决于短板，且底边变短，所以容量一定减小；如果遇到比自己短，比短板长的板子，和刚刚一样的道理，也是容量变小；如果遇到比短板还短的板子，那更不用说了，短边变成它自己了，容量一定减小。</p><p>因此！富贵险中求！如果移动长板，那容量是一定减少的！如果移动短板，有几率容量变大！</p><p>所以设置一个max值，每次移动都记录一下容量，当i与j相遇就说明遍历结束，最后返回max即可。</p><h1 id="三数之和">15、三数之和</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626678.png" alt="image-20220924125048130" /><figcaption aria-hidden="true">image-20220924125048130</figcaption></figure><ol type="1"><li><p><code>Listconst&lt;List&lt;Integer&gt;&gt;</code> 的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br></pre></td></tr></table></figure></li><li><p><code>List&lt;Integer&gt;</code>的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; r = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure></li><li><p>List的添加操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.add(r);    <span class="comment">//r必须是list的&lt;&gt;内的类型，在尾部插入</span></span><br></pre></td></tr></table></figure></li><li><p>List的搜索操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list1.get(index);    <span class="comment">//获取list下标为index的数值</span></span><br></pre></td></tr></table></figure></li><li><p>List查找某个元素是否在其中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(s);    <span class="comment">//查找s这个元素是否在list中</span></span><br></pre></td></tr></table></figure></li><li><p>int转为Integer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(a);</span><br></pre></td></tr></table></figure></li><li><p>数组的排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);     <span class="comment">//原地修改nums数组</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="有效的括号">20. 有效的括号</h1><blockquote><p>考察： #栈</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304210915708.png" /></p><p>简单题，利用栈即可。</p><h1 id="删除有序数组中的重复项">26、删除有序数组中的重复项</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626679.png" alt="image-20220924130553781" /><figcaption aria-hidden="true">image-20220924130553781</figcaption></figure><p>双指针思路</p><h1 id="下一个排列">31、下一个排列</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626680.png" alt="image-20220929222726483" /><figcaption aria-hidden="true">image-20220929222726483</figcaption></figure><p>思路很强，考验找规律的能力。</p><p>例：</p><p><strong>对于 123465：</strong></p><p>第一步，从后往前找到第一对升序的两个数，也就是46</p><p>第二步，从结尾开始到6，<strong>找到第一个大于4的数</strong>，也就是5</p><p>第三步，将4和5对换位置，变成123564</p><p>第四步，将6开始到结尾变成升序，变成123546</p><p><strong>简化：</strong></p><p>第一步，从后往前找到第一对升序的两个数，也就是46</p><p>第二步，从6开始到结尾，升序排列，变成123456</p><p>第三步，<strong>在刚刚升序的部分找到第一个大于4的数，即5</strong>，将4和5对换位置，变成123546</p><p><strong>其他：</strong></p><p>对于已经是最大的数，即从头到尾是越来越小的，它的下一个数是最小的，也就是从头到尾是越来越大的，因此只要对数组进行排序即可。</p><h1 id="搜索旋转排序数组">33、搜索旋转排序数组</h1><p>遇到时间复杂度<code>O(log n)</code>，二话不说，直接<strong>二分查找</strong>！</p><h2 id="方法一暴力不满足logn">方法一、暴力（不满足log(n)）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626681.png" alt="image-20221002171738960" /><figcaption aria-hidden="true">image-20221002171738960</figcaption></figure><h2 id="方法二二分法不完全满足logn">方法二、二分法（不完全满足log(n)）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626682.png" alt="image-20221002172037673" /><figcaption aria-hidden="true">image-20221002172037673</figcaption></figure><p>先求出向左移动的次数k，然后再用二分法判定，每次结果也便宜k。</p><h2 id="方法三二分法优化满足logn">方法三、二分法优化（满足log(n)）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626683.png" alt="image-20221002175004110" /><figcaption aria-hidden="true">image-20221002175004110</figcaption></figure><p>这个方法简单又巧妙。</p><p>正常二分后，先判断mid的值是不是target，再看左边和右边哪个是顺序的。</p><p>如果<code>nums[left] &lt;= nums[mid]</code>，说明左边是顺序的。再看target是不是再左边区间里，如果是则<code>right = mid-1</code>；<strong>否则，</strong><code>left = mid+1</code>，继续在右边找。</p><p>如果<code>nums[left] &gt; nums[mid]</code>，说明左边是不规则的，那么右边一定是顺序的。再看target是不是再右边区间里，如果是则<code>left = mid+1</code>；<strong>否则，</strong><code>right = mid-1</code>，继续在左边找。</p><h1 id="在排序数组中查找元素的第一个和最后一个位置">34、在排序数组中查找元素的第一个和最后一个位置</h1><p>遇到时间复杂度<code>O(log n)</code>，二话不说，直接<strong>二分查找</strong>！</p><h2 id="方法一二分扩张">方法一、二分+扩张</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626684.png" alt="image-20221002123506969" /><figcaption aria-hidden="true">image-20221002123506969</figcaption></figure><p>先找到值为target的数组的元素的位置，再向两边扩张，找到左右边界。</p><h2 id="方法二二分查找性质">方法二、二分查找性质</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626685.png" alt="image-20221002123926754" /><figcaption aria-hidden="true">image-20221002123926754</figcaption></figure><p>这种方法的思路很妙，要想找到数组中值为target的范围，只要找到数组中&gt;=target和target+1的第一个值的下标。</p><blockquote><p>例：</p><p>nums = [5,7,7,8,8,10], target = 8</p></blockquote><p>先找target=8的第一个位置：</p><ol type="1"><li>left = 0，right = 6，mid = 3，找到了一个，往左边找</li><li>left = 0，right = 3，mid = 1，小了</li><li>left = 2，right = 3，mid = 2，小了</li><li>left = 3，right = 3，mid = 3，当left==right，结束，此时left就是第一个</li></ol><p>再找target=9的第一个位置：</p><ol type="1"><li>left = 0，right = 6，mid = 3，小了</li><li>left = 4，right = 6，mid = 5，大了</li><li>left = 4，right = 5，mid = 4，小了</li><li>left = 5，right = 5，mid = 5，当left==right，结束，此时left就是第一个的位置</li></ol><p>除此之外，我们还需要判断target=8的时候到底有没有这个值哦~</p><p>注意：</p><p>本题的right初始值为n，后来right更新为mid，和我们过去使用的二分法略有不同，因为如果mid就是我需要的那个值，且它就是第一个出现的，按照过去的算法，right=mid-1，最后可能会丢失了这个mid。但是新的算法一直用right保存mid，<strong>只要一直在找左区间，就需要将我们的目标范围不停往左边移动</strong>，就应该用right保存mid，最后一定会出现left、right、mid相等的情况，也就是左区间。</p><h1 id="搜索插入位置">35. 搜索插入位置</h1><blockquote><p>考察： #二分查找</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201611658.png" /></p><p>简单题，相当于找&gt;=target 的第一个元素的下标。</p><h1 id="组合总和">39、组合总和⭐</h1><h2 id="方法一双端队列dfs">方法一、双端队列+DFS</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626686.png" alt="image-20221004214508995" /><figcaption aria-hidden="true">image-20221004214508995</figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626687.png" alt="image-20221004211227805" /><figcaption aria-hidden="true">image-20221004211227805</figcaption></figure><p>候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合。同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。</p><h3 id="相关知识">相关知识</h3><h4 id="listlist">List&lt;List&gt;</h4><p>构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br></pre></td></tr></table></figure><h4 id="deque双端队列">Deque双端队列</h4><p>两端都可以进出，FIFO（先进先出）</p><p>构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>操作</p><p>端队列的开头移除元素。从 Queue 接口继承的方法完全等效于 Deque 方法，如下表所示：</p><table><thead><tr class="header"><th></th><th>第一个元素 (头部)</th><th></th><th>最后一个元素 (尾部)</th><th></th></tr></thead><tbody><tr class="odd"><td></td><td>抛出异常</td><td>特殊值</td><td>抛出异常</td><td>特殊值</td></tr><tr class="even"><td>插入</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr class="odd"><td>删除</td><td>removeFirst()</td><td>pollFirst()</td><td>removeLast()</td><td>pollLast()</td></tr><tr class="even"><td>检查</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>Deque与Queue的对照</p><table><thead><tr class="header"><th>Queue方法</th><th>等效Deque方法</th></tr></thead><tbody><tr class="odd"><td>add(e)</td><td>addLast(e)</td></tr><tr class="even"><td>offer(e)</td><td>offerLast(e)</td></tr><tr class="odd"><td>remove()</td><td>removeFirst()</td></tr><tr class="even"><td>poll()</td><td>pollFirst()</td></tr><tr class="odd"><td>element()</td><td>getFirst()</td></tr><tr class="even"><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。堆栈方法完全等效于 Deque 方法，如下表所示：</p><table><thead><tr class="header"><th><strong>堆栈方法</strong></th><th><strong>等效Deque方法</strong></th></tr></thead><tbody><tr class="odd"><td>push(e)</td><td>addFirst(e)</td></tr><tr class="even"><td>pop()</td><td>removeFirst()</td></tr><tr class="odd"><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=begin;i&lt;len;i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);     <span class="comment">//双端队列在结尾增加</span></span><br><span class="line">            DFS(candidates,i,len,target-candidates[i],path,res);</span><br><span class="line">            path.removeLast();    <span class="comment">//双端队列删去刚刚在上一个DFS中加入的值，继续进入循环，判断下一个分支</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   <span class="comment">//构造一个双端队列</span></span><br><span class="line"></span><br><span class="line">        DFS(candidates,<span class="number">0</span>,len,target,path,res);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二剪枝叶">方法二、剪枝叶</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626688.png" alt="image-20221004211040594" /><figcaption aria-hidden="true">image-20221004211040594</figcaption></figure><p>在一开始就对数组进行排序，因为在分支中，如果<code>target-candidates[i] &lt; 0</code>，那么这个分支之后的更大的i就更不可能了。直接break即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=begin;i&lt;len;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (target-candidates[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.addLast(candidates[i]);     <span class="comment">//双端队列在结尾增加</span></span><br><span class="line">    DFS(candidates,i,len,target-candidates[i],path,res);</span><br><span class="line">    path.removeLast();    <span class="comment">//双端队列删去刚刚在上一个DFS中加入的值，继续进入循环，判断下一个分支</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合总和ii">40、组合总和II</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626689.png" alt="image-20221004222241402" /><figcaption aria-hidden="true">image-20221004222241402</figcaption></figure><p>和39题是同样的思路</p><p>唯一的不同是每次begin是从下一个更大的数开始。</p><p><strong>注意：</strong></p><p>在剪枝中，注意要两次剪枝。</p><p>第一次剪枝和39题一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一次剪枝</span></span><br><span class="line"><span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次剪枝是为了消除一样的结果，注意在<code>i&gt;begin</code>时，<code>candidates[i]==candidates[i-1]</code>表示是在同一级有相同元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二次剪枝</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;begin &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳跃游戏ii">45、跳跃游戏II⭐</h1><h2 id="方法一动态规划数组">方法一、动态规划+数组</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626690.png" alt="image-20221018221627713" /><figcaption aria-hidden="true">image-20221018221627713</figcaption></figure><p>原理和 <code>55、跳跃游戏</code> 一致，但是是利用 dp 数组记录到达下标为 i 的节点的最短步数。</p><p>遍历数组，在遍历中，对下标为<code>i+nums[i]</code>进行判断，步数为<code>dp[i]+1</code>，取最小的dp存入。最后输出<code>dp[n-1]</code></p><h2 id="方法二优化">方法二、优化</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626691.png" alt="image-20221018221108378" /><figcaption aria-hidden="true">image-20221018221108378</figcaption></figure><p>例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</p><p>从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。</p><p>思想是上面那样，但是操作起来需要一些技巧：</p><p>对于上面的第一个部分0~2，虽然我们可以通过max知道谁能跳多远，但是我们还是需要走到边界end，也就是下标为2的地方，在这里我们可以更新步数+1，同时将新的边界end更新为刚刚走完的那一段中能走的最远的max。再继续上面的步骤。</p><p><strong>代码真的很巧妙！！！</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;   </span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 上次跳跃可达范围右边界（下次的最右起跳点）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_border</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="comment">// 目前能跳到的最远位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            max_border = Math.max(max_border,i+nums[i]);</span><br><span class="line">            <span class="comment">// 到达上次跳跃能到达的右边界了</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                end = max_border;    <span class="comment">// 目前能跳到的最远位置变成了下次起跳位置的有边界</span></span><br><span class="line">                step++;    <span class="comment">// 进入下一次跳跃</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全排列">46、全排列</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626692.png" alt="image-20221008115241358" /><figcaption aria-hidden="true">image-20221008115241358</figcaption></figure><p>本题的思路来自<code>31、下一个排列</code>，找当前数组的下一个排列，<strong>对于 123465：</strong></p><ol type="1"><li>从后向前找到第一对升序的相邻的两个数，即<code>46</code>；</li><li>从6开始到结尾升序排列，变成<code>123456</code>；</li><li>在刚刚升序的子序列中，即<code>56</code>中，从左到右找到一个大于<code>4</code>的数，即<code>5</code>，与<code>4</code>交换，变成<code>123546</code>。</li></ol><p>因此，本题的思路很简单了：</p><ol type="1"><li>将数组升序排列</li><li>调用此方法</li><li>直到整个数组为逆序为止，也就是当i定位第一对升序组合的较小值时，已经定位到-1了，则退出。</li></ol><h2 id="拓展">拓展</h2><p><a href="LeetCode总结笔记.md#Stream流">Stream流</a></p><h1 id="字母异位词分组">49. 字母异位词分组</h1><blockquote><p>考察： #哈希</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304161118867.png" /></p><p>中等题，hash 存储即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;String&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,ArrayList&lt;String&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] sc = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(sc);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sc);</span><br><span class="line">            ArrayList&lt;String&gt; temp = hash.getOrDefault(key,<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            hash.put(key, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ArrayList&lt;String&gt; v : hash.values()) &#123;</span><br><span class="line">            res.add(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大子数组和">53、最大子数组和</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626693.png" alt="image-20221019195142360" /><figcaption aria-hidden="true">image-20221019195142360</figcaption></figure><p>简单动态规划~写过很多次啦！</p><h1 id="跳跃游戏">55、跳跃游戏</h1><h2 id="方法一动态规划dp数组">方法一、动态规划+dp数组</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626694.png" alt="image-20221018222804356" /><figcaption aria-hidden="true">image-20221018222804356</figcaption></figure><p>利用dp数组记录某个点是否能到达，能到达记为1，随时判断下标为n-1即可。</p><h2 id="方法二优化动态更新最大长度">方法二、优化——动态更新最大长度</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626695.png" alt="image-20221018222935560" /><figcaption aria-hidden="true">image-20221018222935560</figcaption></figure><p>在能跳跃的区域内遍历，不断更新能跳跃的最大长度，如果能覆盖下标为n-1则为true。</p><p>只用遍历一遍即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//不断更新能跳的最大长度，这样只要遍历一次就行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;max) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (max&gt;=n-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合并区间">56. 合并区间</h1><blockquote><p>考察： #数组 #数组排序</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304210936639.png" /></p><p>中等题，但是简单。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a1, <span class="type">int</span>[] a2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a1[<span class="number">0</span>]!=a2[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> a1[<span class="number">0</span>]-a2[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a1[<span class="number">1</span>]-a2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>], end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;intervals.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>]&lt;=end) &#123;</span><br><span class="line">                end = Math.max(end,intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                temp.add(start);</span><br><span class="line">                temp.add(end);</span><br><span class="line">                al.add(temp);</span><br><span class="line">                start = intervals[i][<span class="number">0</span>];</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        temp.add(start);</span><br><span class="line">        temp.add(end);</span><br><span class="line">        al.add(temp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[al.size()][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;al.size();i++) &#123;</span><br><span class="line">            res[i][<span class="number">0</span>] = al.get(i).get(<span class="number">0</span>);</span><br><span class="line">            res[i][<span class="number">1</span>] = al.get(i).get(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文本左右对齐">68、文本左右对齐</h1><h2 id="方法一枚举各种情况">方法一、枚举各种情况</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626696.png" alt="image-20220924200048680" /><figcaption aria-hidden="true">image-20220924200048680</figcaption></figure><p><code>_1.java</code>文件为精简版（将很多重复的代码放入函数）</p><p><code>_2.java</code>文件更容易理解</p><p><code>_3.java</code>文件思路一致，但是更加精简，且易懂⭐</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626697.png" alt="image-20220924202357372" /><figcaption aria-hidden="true">image-20220924202357372</figcaption></figure><h1 id="爬楼梯">70、爬楼梯</h1><h2 id="方法一动态规划">方法一、动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626698.png" alt="image-20221016215036802" /><figcaption aria-hidden="true">image-20221016215036802</figcaption></figure><p>如果使用递归——妥妥的时间超时！！！</p><p>所以只有正着推。可以得到规律：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br></pre></td></tr></table></figure><h3 id="简单优化">简单优化</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626699.png" alt="image-20221016220255962" /><figcaption aria-hidden="true">image-20221016220255962</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    temp = a + b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure><h1 id="搜索二维矩阵">74. 搜索二维矩阵</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211050065.png" /></p><p>中等题。两次二分查找，先查找行，再查找列。代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; matrix[<span class="number">0</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> findrow(matrix,target);</span><br><span class="line">        System.out.println(r);</span><br><span class="line">        <span class="keyword">return</span> find(matrix[r],target);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findrow</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;    <span class="comment">// 找第一个小于等于target的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[m][<span class="number">0</span>]&lt;=target) &#123;</span><br><span class="line">                l = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[m]==target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集">78. 子集⭐⭐</h1><blockquote><p>考察： #回溯</p></blockquote><p>题解：<a href="https://leetcode.cn/problems/subsets/solutions/2059409/hui-su-bu-hui-xie-tao-lu-zai-ci-pythonja-8tkl/?languageTags=java">题解</a></p><h2 id="方法一">方法一</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304222043816.png" /></p><p>中等题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i==nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选nums[i]，直接进入下一个</span></span><br><span class="line">        find(i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择nums[i]，添加进入ans，再进入下一个</span></span><br><span class="line">        ans.add(nums[i]);</span><br><span class="line">        find(i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 回退场景</span></span><br><span class="line">        ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二更通用的回溯框架">方法二、更通用的回溯⭐（框架）</h2><p>思路比较抽象，需要思考。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;nums.length;j++) &#123;</span><br><span class="line">            <span class="comment">// 第一种情况：nums[j]在</span></span><br><span class="line">            ans.add(nums[j]);</span><br><span class="line">            find(j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二种情况：nums[i]-nums[j]都不在</span></span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="格雷编码">89. 格雷编码 ⭐</h1><p><a href="https://leetcode.cn/problems/gray-code/solutions/1198173/dai-ma-jie-de-xiao-bai-javac-san-chong-f-iaxe/">题解</a></p><h2 id="方法一规律">方法一、规律</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230922343.png" /></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230849567.png" /></p><p>总结了如下规律：<br />1. 0 位格雷码有 1 个码字；1 位格雷码有 2 个码字 2. (n+1) 位格雷码中的<strong>前 2^n</strong> 个码字（前一半）等于 n 位格雷码的全部码字，按顺序书写，加前缀 0（意味着如果 n 位的所有码字已经加入 res，就不用操作了） 3. (n+1) 位格雷码中的<strong>后 2^n</strong> 个码字 (后一半）等于 n 位格雷码的全部码字按逆序书写，并加前缀 1（相当于把 n 位的所有码字逆序遍历，并加上一个头 1） 4. n+1 位格雷码的集合 = n 位格雷码集合 (顺序) 加前缀 0 + n 位格雷码集合 (逆序) 加前缀 1</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        res.add(<span class="number">0</span>);     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;      <span class="comment">//表示从1位到n位</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> res.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=l-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;      <span class="comment">//遍历在上一轮之后存的i-1位二进制码</span></span><br><span class="line">                res.add(res.get(j)+head);</span><br><span class="line">            &#125;</span><br><span class="line">            head = head &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二格雷编码">方法二、格雷编码</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230924855.png" /></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230913159.png" /></p><p>实现公式如下：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230913296.png" /></p><blockquote><p>举个🌰：n=4 时，当十进制为 7，现在最高位加个 0，所以其对应的二进制位 00111，可以通过上图的例子进行演算。<br />从右往左推算 00111 对应的格雷码的每一位：<br />1 ⊕ 1 = 0<br />1 ⊕ 1 = 0<br />0 ⊕ 1 = 1<br />0 ⊕ 0 = 0<br />所以其对应的格雷码为 0100</p></blockquote><blockquote><p>再举个🌰：n=4 时，当十进制为 12，现在最高位加个 0，所以其对应的二进制位 01100，可以通过上图的例子进行演算。<br />从右往左推算 01100 对应的格雷码的每一位：<br />0 ⊕ 0 = 0<br />1 ⊕ 0 = 1<br />1 ⊕ 1 = 0<br />0 ⊕ 1 = 1<br />所以其对应的格雷码为 1010</p></blockquote><p>不难发现，对于十进制为 i 的数，其格雷码就是 <strong>i ^ (i&gt;&gt;1)</strong>，根据这个思路很容易得到代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">grayCode</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;  </span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子集-ii">90. 子集 II⭐</h1><blockquote><p>考察： #回溯</p></blockquote><blockquote><p>基础题/框架题：<strong>78（子集）</strong></p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304222133401.png" /></p><p>中等题，在 78 题的基础上多了一步去重。需要先对 nums 进行排序，将相同的聚在一起。在 find 函数中，如果遇到连续的相同的数，只取其中的第一个。因为在同一个 find 下的 for 循环内是属于同一级别的，比如：<code>[1, 2, 2]</code> 分解为 <code>[1, 2]</code> 和 <code>[1, 2]</code> 是一样的，同级别的相同的去重即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        find(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;nums.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&gt;i &amp;&amp; nums[j]==nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(nums[j]);</span><br><span class="line">            find(j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            ans.remove(ans.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的中序遍历">94. 二叉树的中序遍历</h1><blockquote><p>考察： #树</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181704002.png" /></p><p>简单题，考察树的中序遍历，模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midfind</span><span class="params">(TreeNode r)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">midfind(r.left);</span><br><span class="line">res.add(r.val);</span><br><span class="line">midfind(r.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对称二叉树">101. 对称二叉树😭</h1><blockquote><p>考察： #树</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191457105.png" /></p><p>简单题，但是思路很妙。</p><p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。如果同时满足下面的条件，两个树互为镜像： - 它们的两个根结点具有相同的值 - 每个树的右子树都与另一个树的左子树镜像对称</p><p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> check(root,root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(TreeNode r1, TreeNode r2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> &amp;&amp; r2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r1 == <span class="literal">null</span> || r2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r1.val == r2.val &amp;&amp; check(r1.left, r2.right) &amp;&amp; check(r1.right, r2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层序遍历">102. 二叉树的层序遍历</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181725335.png" /></p><p>简单题。但是要注意 <code>List&lt;List&lt;Integer&gt;&gt;</code> 对象的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度">104. 二叉树的最大深度</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181713334.png" /></p><p>简单题，遍历即可，同步 level 层级。</p><h1 id="杨辉三角">118. 杨辉三角</h1><blockquote><p>考察： #动态数组</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181807228.png" /></p><p>简单题。但是需要注意，对于同一个 arraylist 对象，如果之前已经加入了嵌套的外层 list 中，之后再改变这个对象，嵌套在里面的也会改变，类似于一个指针。</p><h1 id="买卖股票的最佳时机">121、买卖股票的最佳时机</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626700.png" alt="image-20221021185552910" /><figcaption aria-hidden="true">image-20221021185552910</figcaption></figure><p>思路与<code>1014、最佳观光组合</code>相同。</p><h1 id="买卖股票的最佳时机-ii">122、买卖股票的最佳时机 II</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626701.png" alt="image-20221021194731667" /><figcaption aria-hidden="true">image-20221021194731667</figcaption></figure><p>这题很容易想复杂了，其实这题的目的就是为了始终不亏钱。所以只要是相邻两个升序的就买了就卖，一定能赚一笔！</p><h1 id="最长连续序列">128. 最长连续序列⭐</h1><blockquote><p>考察： #Set</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181636880.png" /></p><p>中等题。题目要求在 <span class="math inline">\(O(n)\)</span> 的时间内找到最长的连续序列，思路是找到每个连续序列的第一个数，然后再一直++，就能找到这个长度。那么问题是如何找到第一个数，或者说会不会出现中间的数重复判断。第一个数有一个特性是非第一个数没有的，就是 num-1 是不存在数组中。现在问题是如何快速判断一个数在不在数组中，这里选择使用 HashSet，它是 <span class="math inline">\(O(n)\)</span> 的时间复杂度。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> s : set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(s-<span class="number">1</span>)) &#123;    <span class="comment">// 我们要找的就是一个连续序列的开头数字，它的特征就是没有s-1这个值</span></span><br><span class="line">                <span class="comment">// s就是连续序列的开头数字</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (set.contains(s+<span class="number">1</span>)) &#123;    <span class="comment">// 判断下一个在不在set中</span></span><br><span class="line">                    k++;    <span class="comment">// 计数</span></span><br><span class="line">                    s++;    <span class="comment">// 判断下一个数，这里++的结果是存在与set的</span></span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res, k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分发糖果">135、分发糖果</h1><h2 id="方法一递归">方法一、递归</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626702.png" alt="image-20220924183620852" /><figcaption aria-hidden="true">image-20220924183620852</figcaption></figure><p>思想：相邻的两个值中，更大的糖果=更小的糖果+1，如果比左右都大则取其max。如果比左右都小，则糖果数为1。用数组记录数值，可以提高时间效率（如果不设置数组，则会超时）。</p><h2 id="方法二左右遍历">方法二、左右遍历</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626703.png" alt="image-20220924182743805" /><figcaption aria-hidden="true">image-20220924182743805</figcaption></figure><p>思想：从左向右遍历一遍，设置第一个值为1，如果当前值比上一个值大，则糖果数=上一个的糖果数+1，反之将其置为1。此时从左到右的糖果大小关系已经明确。再从右往左遍历一遍，此时只需要一个temp变量记录即可，设置第一个的temp为1，如果当前值比上一个值大，则糖果数=temp+1，对于每一个小朋友都会对他从左遍历和从右遍历取最大值，也就是他最后得到的糖果值。</p><blockquote><p>对于 <code>[1,2,87,87,87,2,1]</code></p><p>从左向右：1，2，3，1，1，1，1</p><p>从右向左：1，1，1，1，3，2，1</p><p>综合：1，2，3，1，3，2，1</p></blockquote><h1 id="只出现一次的数字">136. 只出现一次的数字</h1><h2 id="方法一hashset">方法一、HashSet</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211955850.png" /></p><p>简单题，利用 set 记录，最后遍历。注意 set 的删除为 <code>remove()</code>。</p><h2 id="方法二位运算">方法二、位运算👍</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211957312.png" /></p><p>思路：元素只出现两次，而相同元素异或为 0。0 和某个只出现一次的元素异或为这个元素。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            res = res ^ num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘积最大子数组">152、乘积最大子数组⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626704.png" alt="image-20221020111954135" /><figcaption aria-hidden="true">image-20221020111954135</figcaption></figure><p>动态规划经典题</p><p>本题和<code>53、最大子数组和</code>有异曲同工之处。但是值得注意的是乘法中，两个负数相乘就会得到正数。</p><p>所以我们不能只用一个last记录以当前元素结尾的最大值，我们需要用lastmax记录当前元素结尾的最大值、用lastmin记录当前元素结尾的最小值。</p><p>最大值和最小值实时动态更新。如果当前元素&lt;0，那么最大值就是上一个元素的最小值*nums[i]和它自身判断，最小值就是上一个元素的最大值*nums[i]和它自身判断。nums[i]&gt;0就很简单了。</p><p>为了更广泛操作（装逼），我们可以提前计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> lastmax*nums[i];</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> lastmin*nums[i];</span><br></pre></td></tr></table></figure><p>那么每次更新的时候只需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lastmax = Math.max(Math.max(a,b),nums[i]);</span><br><span class="line">lastmin = Math.min(Math.min(a,b),nums[i]);</span><br></pre></td></tr></table></figure><p>其实不难理解，如果nums[i]&lt;0，如果上一个值的max&gt;0、min&lt;0，那么取的是b；如果max&lt;0、min&lt;0，那么取的也还是b；如果max&gt;0、min&gt;0，那么取得还是b。但是如果nums[i]&gt;0，那么一切都恰恰相反，都取a。所以我们只需要用a、b得最大值和它自身比较就能得到新的lastmax。</p><p>lastmin同理。</p><p>每次循环都用变量min找到最大值。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastmax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastmin</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> lastmax*nums[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> lastmin*nums[i];</span><br><span class="line"></span><br><span class="line">            lastmax = Math.max(Math.max(a,b),nums[i]);</span><br><span class="line">            lastmin = Math.min(Math.min(a,b),nums[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// if (nums[i]&lt;0) &#123;</span></span><br><span class="line">            <span class="comment">//     lastmax = Math.max(b,nums[i]);</span></span><br><span class="line">            <span class="comment">//     lastmin = Math.min(a,nums[i]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">            <span class="comment">//     lastmax = Math.max(a,nums[i]);</span></span><br><span class="line">            <span class="comment">//     lastmin = Math.min(b,nums[i]);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">            max = Math.max(max,lastmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="寻找旋转排序数组中的最小值">153. 寻找旋转排序数组中的最小值</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301641982.png" /></p><p>中等题，但是很简单。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="轮转数组">189. 轮转数组</h1><h2 id="方法一开辟额外空间">方法一、开辟额外空间</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211003068.png" /></p><p>中等题。最后利用了<a href="LeetCode总结笔记.md#数组#拷贝#深拷贝">深拷贝</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        k = k % n;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=n-k;j&lt;n;j++,i++) &#123;</span><br><span class="line">            res[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n-k;j++,i++) &#123;</span><br><span class="line">            res[i] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(res[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        System.arraycopy(res, <span class="number">0</span>, nums, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二原地翻转">方法二、原地翻转👍</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211009794.png" /></p><p>思路：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304211010551.png" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k = k % n;</span><br><span class="line">        reverse(nums,<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,<span class="number">0</span>,k-<span class="number">1</span>);</span><br><span class="line">        reverse(nums,k,n-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;    <span class="comment">// 将nums数组的[start,end]原地逆置</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打家劫舍模板题">198、打家劫舍（模板题）⭐⭐</h1><p>典型的动态规划入门题</p><p>思路<a href="https://leetcode.cn/problems/house-robber/solutions/138131/dong-tai-gui-hua-jie-ti-si-bu-zou-xiang-jie-cjavap/">198. 打家劫舍 - 力扣（Leetcode）</a></p><h3 id="优化前">优化前</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626705.png" alt="image-20221013224043773" /><figcaption aria-hidden="true">image-20221013224043773</figcaption></figure><h4 id="注意-2">注意：</h4><p><code>dp[0]</code>表示没有房间，不对应<code>nums</code>中任何值</p><p><code>dp[i]</code>对应的应该是第<code>i-1</code>个屋子的最大收益。</p><h3 id="优化后理论上更优的">优化后（理论上更优的）</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626706.png" alt="image-20221013224912862" /><figcaption aria-hidden="true">image-20221013224912862</figcaption></figure><h1 id="实现-trie-前缀树">208. 实现 Trie (前缀树)⭐</h1><blockquote><p>考察： #前缀树</p><p>拓展：<a href="https://leetcode.cn/problems/stream-of-characters/description/">1032. 字符流</a></p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303240925830.png" /></p><p><strong>前缀和介绍思路：<a href="https://blog.csdn.net/m0_46202073/article/details/107253959">【图解算法】字典树</a></strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    TreeNode[] Children;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        Children = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    TreeNode root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] sc = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        r.isEnd = <span class="literal">true</span>;    <span class="comment">// 表示这是单词的结尾</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] sc = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;word.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r.isEnd;     <span class="comment">// 需要完整搜索，如果单词都有，需要判断最后一个是不是结尾</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">char</span>[] sc = prefix.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;prefix.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r = r.Children[sc[i]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="打家劫舍-ii">213、打家劫舍 II⭐</h1><h2 id="动态规划">动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626707.png" alt="image-20221017165225803" /><figcaption aria-hidden="true">image-20221017165225803</figcaption></figure><p>相比<code>198、打家劫舍</code>，我们可以将题目拆解为：</p><p><strong>n (0~n-1) 个屋子分别在 0~n-2 和 1~n-1 中取最大值，这样就能保证首位不会同时出现</strong></p><h1 id="翻转二叉树">226. 翻转二叉树</h1><blockquote><p>考察： #树</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191133002.png" /></p><p>简答题，只要类似后序遍历，每次返回更改过左右节点的根即可。</p><h1 id="移动零">283. 移动零</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181652975.png" /></p><p>简单题。使用双指针，i 指向第一个 0，j 指向 i+1 位置。之后遍历 j，每次如果 j 位置的元素不是 0，则将其赋值到 i 的位置，i 再++。最后将 i 及其之后的元素置为 0 即可。</p><h1 id="最长递增子序列">300. 最长递增子序列⭐</h1><blockquote><p>考察： #动态规划 #最长递增子序列</p><p>拓展：<a href="https://leetcode.cn/problems/best-team-with-no-conflicts/">1626. 无矛盾的最佳球队</a></p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303221016803.png" /></p><p>中等题。这是最长递增子序列的最基础的题目！dp 保存的是以当前数组结尾的最长的个数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt;= nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    m = Math.max(m,dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m;</span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找到字符串中所有字母异位词">438. 找到字符串中所有字母异位词</h1><blockquote><p>考察： #滑动窗口</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221815270.png" /></p><p>中等题。因为可能会出现重复单词，所以不能使用位运算。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] pc = p.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pn</span> <span class="operator">=</span> p.length();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span>[] test = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n&lt;pn) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : pc) &#123;</span><br><span class="line">            map[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;pn;i++) &#123;</span><br><span class="line">            test[sc[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(map,test)) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-pn;i++) &#123;</span><br><span class="line">            test[sc[i-<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            test[sc[i+pn-<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            <span class="keyword">if</span> (Arrays.equals(map,test)) &#123;</span><br><span class="line">                res.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小操作次数使数组元素相等">453. 最小操作次数使数组元素相等</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303101155994.png" /></p><p>思路：<strong>n-1 个小的加 1，相当于最大的减 1</strong>。详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mi</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            mi = Math.min(mi,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            res += (nums[i]-mi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小操作次数使数组元素相等-ii">462. 最小操作次数使数组元素相等 II</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303101453063.png" /></p><p>先对 nums 排序，只要选择的相等数 <code>x ∈ [nums[i], nums[j]]</code>，对于左右指针所指向的数，其操作数是固定的，即 <code>nums[j]</code> - <code>nums[i]</code>，指针所指向数的差值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMoves2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 最终大家汇集的点一定在这些数之间的</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j) &#123;</span><br><span class="line">            res += (nums[j]-nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目标和">494. 目标和⭐</h1><h2 id="方法一二维数组-纯暴力">方法一、二维数组 （纯暴力）</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303140943028.png" /></p><p>类似于树的递归调用，很愚蠢。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span>&lt;&lt;n];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;i);j++) &#123;</span><br><span class="line">                res[i][j*<span class="number">2</span>] = res[i-<span class="number">1</span>][j] - nums[i];</span><br><span class="line">                res[i][j*<span class="number">2</span>+<span class="number">1</span>] = res[i-<span class="number">1</span>][j] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res[n-<span class="number">1</span>][i]==target) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;(1&lt;&lt;n);j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(res[i][j]);</span></span><br><span class="line">        <span class="comment">//         System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二数学动态规划">方法二、数学+动态规划</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303141032788.png" /></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303141035069.png" /></p><p>题解：<a href="https://leetcode.cn/problems/target-sum/solutions/816361/mu-biao-he-by-leetcode-solution-o0cp/">题解</a></p><blockquote><p>注意：不能添加以下的代码段，可能有多个 0，+0 和-0 效果一样，所以不一定是 1。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sum == target) &#123;    </span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target || (sum-target)%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> (sum-target)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于nums的每一个数，我选或者不选，使得最后的结果为target的搭配数量</span></span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [n+<span class="number">1</span>][neg+<span class="number">1</span>];    <span class="comment">//我们要找到就是最终neg的数量，即dp[n][neg]的值</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;     <span class="comment">//表示初始状态没有任何元素选取，和为0，有1种方案。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;neg+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j&lt;num) &#123;       <span class="comment">// 如果加上num得到的结果j还比num小，这是不可能的，所以不能加</span></span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-num];     <span class="comment">// 结果应该是不加num的个数+加上num的个数之和</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][neg];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化用一维数组进行动态规划">优化、用一维数组进行动态规划</h3><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303141041573.png" /></p><blockquote><p>需要注意：如果正向操作可能在 <code>j&gt;=num</code> 时将原本的 <code>dp[j]</code>覆盖，在之后的调用原本的<code>dp[j]</code>时会出错，所以<strong>一维的动态规划需要从后向前逆序进行</strong>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target || (sum-target)%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">neg</span> <span class="operator">=</span> (sum-target)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于nums的每一个数，我选或者不选，使得最后的结果为target的搭配数量</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[neg+<span class="number">1</span>];   </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;     </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=neg;j&gt;=num;j--) &#123;</span><br><span class="line">                dp[j] += dp[j-num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[neg];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他">其他</h2><h3 id="栈">栈</h3><p><strong>超时</strong>，理论上不应该，已经进行了小优化了，但是还是会超时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dq.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">//轮数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> dq.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                dq.addLast(k-nums[i]);</span><br><span class="line">                dq.addLast(k+nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dq.pollFirst()==target) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斐波那契数">509、斐波那契数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626708.png" alt="image-20221015213246525" /><figcaption aria-hidden="true">image-20221015213246525</figcaption></figure><p>简单哦~</p><h1 id="通过删除字母匹配到字典里最长单词">524、通过删除字母匹配到字典里最长单词</h1><h2 id="方法一排序后操作">方法一：排序后操作</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626709.png" alt="image-20221009174042475" /><figcaption aria-hidden="true">image-20221009174042475</figcaption></figure><p>先对List进行排序，重写排序规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(dictionary,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1.length() == s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.compareTo(s2)&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.length()-s2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>先对字符串List进行排序操作，根据题目要求，需要找到最长的且字典序最小的结果，所以依次遍历每一个字符串，如果当前字符串成立，则与它相同长度的字符串无需验证。</p><h2 id="方法二不排序操作">方法二、不排序操作</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626710.png" alt="image-20221009174019047" /><figcaption aria-hidden="true">image-20221009174019047</figcaption></figure><p>这种思路无需先排序，只要记录已经匹配成功的字符串的长度，如果在接下来的字符串长度比它小，那就无需验证；如果长度更长，则进行验证，如果验证成功，更新匹配成功的字符串长度；如果字符串长度和记录的相同，将当前字符串和这个已经匹配成功的字符串比较，只有字典序更小才进行验证。</p><h3 id="注意-3">注意</h3><p>字符串的比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.compareTo(s2);    <span class="comment">//如果s1&gt;s2，返回1；如果s1&lt;s2，返回-1；如果相等，返回0</span></span><br></pre></td></tr></table></figure><h1 id="二叉树的直径">543. 二叉树的直径</h1><blockquote><p>考察： #树</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201607248.png" /></p><p>简单题，但是思路很重要。</p><ul><li><code>root</code> 的直径 = <code>root.left</code> 的高度 + <code>root.right</code> 的高度</li><li><code>root</code> 的高度 = <code>Math.max(root.left的高度, root.right的高度)</code> + 1</li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;   </span><br><span class="line">        findd(root);    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root为根的最大直径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findd</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, height(root.left)+height(root.right));</span><br><span class="line">        findd(root.left);</span><br><span class="line">        findd(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(root.left),height(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="和为-k-的子数组">560. 和为 K 的子数组</h1><blockquote><p>考察：前缀和</p></blockquote><h2 id="方法一前缀和">方法一、前缀和</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301746343.png" /></p><p>利用前缀和+两层 for 循环，比较简单易想。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">// map[i]表示nums[0~i-1]</span></span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            map[i] = map[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[i]-map[j]==k) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二前缀和hash-优化">方法二、前缀和+hash 优化⭐</h2><p><strong>思路：</strong> 同样先构造一个 map 数组记录前缀和，再构造一个 hash，在遍历 map 时，记录当前 map[i]-k 的值 d，也就是我们需要在 map[0, i) 找到下标为 j，满足 map[j]为 d，那么 map[i]-map[j]和就是 k。</p><p><strong>注意：</strong> 在下面代码实现中，一定要先更新 res，再更新 hash。举个例子：如果 k 是 0，那么 d 就是 map[i]，如果我先更新 hash，假设 key 为 d 的开始没有，那么就在 hash 中加入的 <code>&#123;d, 1&#125;</code>，再更新 res 即为 res+1。但是这样是对的吗？显然不对！我要找的 k 是 0，但是我再 i 之前的 map 没有任何值是和 map[i]相等，理论上以 map[i]结尾是构造不了符合条件的子串，但是这里却+1，这是不对的。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">// map[i]表示nums[0~i-1]</span></span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            map[i] = map[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();     </span><br><span class="line">        hash.put(<span class="number">0</span>, <span class="number">1</span>);    <span class="comment">// 表示和为k的本身就有1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> map[i]-k;    <span class="comment">// 当前值和k之间的差距，现在就看在[0,i]之间有没有和为d的，已经存进去的都是有端下标小于i的</span></span><br><span class="line">            res += hash.getOrDefault(d, <span class="number">0</span>);      <span class="comment">// hash中key为d的val：表示[0,i)中前缀和为d的数量。如果map[j]=d，那么意思是(j,i]的和为k</span></span><br><span class="line">            hash.put(map[i], hash.getOrDefault(map[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="任务调度器">621. 任务调度器⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303170922304.png" /></p><p>中等题，思路很妙！<strong>思路：</strong></p><ol type="1"><li>将任务按类型分组，正好 A-Z 用一个 int[26]保存任务类型个数</li><li>对数组进行排序（因为我们实际上对到底是 A5 个还是 B5 个不感兴趣，我们只需要有某个单词出现 5 次即可），优先排列个数（count）最大的任务，如题得到的时间至少为 res =（count-1）* (n+1) + 1 ==&gt; <code>A-&gt;X-&gt;X-&gt;A-&gt;X-&gt;X-&gt;A</code> (X 为其他任务或者待命)。</li><li>再排序下一个任务，如果下一个任务 B 个数和最大任务数一致，则 res++ ==&gt; <code>A-&gt;B-&gt;X-&gt;A-&gt;B-&gt;X-&gt;A-&gt;B</code></li><li>对于空位还满足的，直接插进去即可。（你可能会觉得，如果剩下的空位不能满足 n 的条件怎么办，就像在 n=2 的情况下，在 <code>ABCABCABCAxxA</code> 时候还有 2 个 D，但是剩下的空间不能满足，这时候只需要稍微调整已经排序的位置即可，也就是变成 <code>ABCBACBABxACx</code>，那么两个 D 就能顺利插进去）</li><li><strong>如果空位都插满之后还有任务，那就随便在这些间隔里面插入就可以，因为间隔长度肯定会大于 n，在这种情况下就是任务的总数是最小所需时间</strong></li><li>最后返回的实际上就是 res 和所有单词的个数的最大值，所有单词个数实际上就是 tasks 的长度。</li></ol><p><strong>代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leastInterval</span><span class="params">(<span class="type">char</span>[] tasks, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] words = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tasks) &#123;</span><br><span class="line">            words[c-<span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(words);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (words[<span class="number">25</span>] - <span class="number">1</span>) * (n+<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; words[j]==words[<span class="number">25</span>]) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(res,tasks.length); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回文子串">647. 回文子串⭐</h1><h2 id="中心扩张法">中心扩张法</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303151020749.png" />.</p><p>中等题，其实思路很简单，就是确定一个中间，两边同时扩张。</p><p>中心需要分类讨论，如果中心是 1 个元素，那么扩张后的元素个数都是奇数；如果中心是 2 个元素，那么扩张后的元素个数都是偶数。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">//中心</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i, end = i;</span><br><span class="line">            <span class="keyword">while</span> (start&gt;=<span class="number">0</span> &amp;&amp; end&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[start] == sc[end]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    start--;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i, end = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (start&gt;=<span class="number">0</span> &amp;&amp; end&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[start] == sc[end]) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    start--;</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组中的-k-diff-数对">532、数组中的 k-diff 数对</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626711.png" alt="image-20221009161302609" /><figcaption aria-hidden="true">image-20221009161302609</figcaption></figure><p>本题思路，先将数组升序。</p><p>设置一个i和j，注意 i 如果遇到重复的就跳过，j是找 nums[i]+k 的值，对于越来越大的i，如果他的j存在，那么一定再前一个i的j的后面。</p><p>但是需要注意的是i可能会跑到j后面，所以每次要对j做判断是否需要更新位置。</p><h1 id="二叉树中第二小的节点">671、二叉树中第二小的节点</h1><h2 id="方法一替换法">方法一、替换法</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626712.png" alt="image-20221008121811267" /><figcaption aria-hidden="true">image-20221008121811267</figcaption></figure><p>更新新的最小值，实际上也是遍历整个数，逻辑相对复杂一些。</p><p>核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isLeaf(root)) &#123;</span><br><span class="line">    <span class="keyword">return</span> root.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == temp &amp;&amp; b == temp) &#123;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == temp) &#123;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b == temp) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.min(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二dfs">方法二、DFS</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626713.png" alt="image-20221008121848938" /><figcaption aria-hidden="true">image-20221008121848938</figcaption></figure><p>利用DFS深度优先搜索，提前设置好全局变量记录最小和第二小的值，DFS遍历整个树，找到第二小的值。</p><p><strong>DFS的使用方法：void函数，当root==null时return;，否则调用dfs(root.left)和dfs(root.right)，当全部遍历完后，全局变量也被修改了</strong></p><h1 id="设计链表">707、设计链表</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626714.png" alt="image-20220923102230396" /><figcaption aria-hidden="true">image-20220923102230396</figcaption></figure><p>Java语言使用链表格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node head;</span><br><span class="line">    <span class="type">int</span> size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        head.next = head;</span><br><span class="line">        head.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">MyLinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyLinkedList</span>();</span><br><span class="line">linkedList.get(<span class="number">1</span>);    </span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机含手续费">714、买卖股票的最佳时机含手续费⭐</h1><h2 id="方法一贪心">方法一、贪心</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626715.png" alt="image-20221027164450020" /><figcaption aria-hidden="true">image-20221027164450020</figcaption></figure><p>比较晦涩难懂，对left的定义很重要，特别是在<code>prices[i]&gt;left+fee</code>情况的left改变比较难。看代码理解吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i]&lt;left) &#123;   <span class="comment">// prices[i]+fee &lt; left+fee</span></span><br><span class="line">                left = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i]&gt;left+fee) &#123;    <span class="comment">//如果后面的减去left和fee依然有收益，那就可以尝试将股票卖出</span></span><br><span class="line">                sum += prices[i]-left-fee;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//但是为了防止遇到的是局部最优：</span></span><br><span class="line">                <span class="comment">// left       prices[i]          prices[i+1]</span></span><br><span class="line">                <span class="comment">//实际上的真实收益应该是：prices[i+1]-left-free</span></span><br><span class="line">                <span class="comment">// prices[i]-left-free    + 一个收益   =   prices[i+1]-left-free</span></span><br><span class="line">                <span class="comment">// 解得这个收益为：prices[i+1]-prices[i]</span></span><br><span class="line">                <span class="comment">// 但是 sum += prices[i+1]-prices[i]-fee;，所以left应该设定为prices[i]-fee</span></span><br><span class="line"></span><br><span class="line">                left = prices[i]-fee;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划-1">方法二、动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626716.png" alt="image-20221027164704099" /><figcaption aria-hidden="true">image-20221027164704099</figcaption></figure><p>唉，动态规划，容易理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[i][0]表示i天结束后手上没有股票的最大收益</span></span><br><span class="line">        <span class="comment">//dp[i][1]表示i天结束后手上有一张股票的最大收益</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];    </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化">优化</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626717.png" alt="image-20221027165234692" /><figcaption aria-hidden="true">image-20221027165234692</figcaption></figure><p>动态规划常规优化喽~</p><h1 id="每日温度">739. 每日温度</h1><h2 id="方法一单调栈">方法一、单调栈⭐</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303150918217.png" /></p><p>如果本题使用从后往前进行遍历，每次循环内嵌套循环，必然会超出时间复杂度，因此不能只用简单得线性查找，需要使用新的查找技术——<strong>单调栈</strong>。</p><p><strong>应用场景：</strong> 在一个一维数组中，找到某个数得左边或者右边第一个最小或者最大得元素位置。</p><p>题解：<a href="https://leetcode.cn/problems/daily-temperatures/solutions/71433/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">题解</a></p><p>本题需要找右边第一个大于它的元素与它的距离。如果栈为空，则直接放入当前元素的下标；如果不为空，我们需要拿当前元素依次与栈顶元素的进行比较，如果当前元素比栈顶元素大，表示它是栈顶元素之后第一个大于栈顶元素的值，那么栈顶元素出栈，他们俩之间的距离就是栈顶元素下标的结果，再继续循环上述步骤，直到当前元素比栈顶元素小，则表示栈顶元素之后的都更小，那么直接将当前元素下标入栈。当全部遍历完后，如果栈内还有元素，表示这些元素没有遇到比他们更大的，那么依次出栈，并在对应值上设置为 0。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> temperatures[i];</span><br><span class="line">            <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dq.peekLast();</span><br><span class="line">                <span class="keyword">if</span> (temperatures[j] &lt; k) &#123;</span><br><span class="line">                    res[j] = i - j;</span><br><span class="line">                    dq.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            res[dq.pollLast()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除并获得点数">740、删除并获得点数⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626718.png" alt="image-20221017202842714" /><figcaption aria-hidden="true">image-20221017202842714</figcaption></figure><p>题目中说的是如果选取i值，就不能选取所有的i-1和i+1。</p><p>这看似是涉及到左右，但是实际上只要考虑左边就行了。</p><p>考虑每个值选还是不选即可（变成了<code>198、打家劫舍</code>小偷问题）。</p><h1 id="使用最小花费爬楼梯">746、使用最小花费爬楼梯</h1><h2 id="方法一动态规划-1">方法一、动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626719.png" alt="image-20221016212056771" /><figcaption aria-hidden="true">image-20221016212056771</figcaption></figure><p>注意找到规律：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">dp[i] = Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br></pre></td></tr></table></figure><h3 id="尝试优化空间">尝试优化空间</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626720.png" alt="image-20221016214807512" /><figcaption aria-hidden="true">image-20221016214807512</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>, temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    temp = Math.min(b+cost[i-<span class="number">1</span>],a+cost[i-<span class="number">2</span>]);</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br></pre></td></tr></table></figure><p>但是奇怪的是更慢了</p><h1 id="最多能完成排序的块">769、最多能完成排序的块⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626721.png" alt="image-20221014091237039" /><figcaption aria-hidden="true">image-20221014091237039</figcaption></figure><p>思路：<a href="https://leetcode.cn/problems/max-chunks-to-make-sorted/solutions/1888391/by-ac_oier-4uny/">769. 最多能完成排序的块 - 力扣（Leetcode）</a></p><p>注意题干：它表示在 <code>[0, n - 1]</code> 范围内的整数的排列，表示这n个数是0~n-1。</p><p>思路：所以这个数组的下标就是整体排序好的数值。</p><p>因此我们可以从头到尾遍历，记录最左边的值和最右边的值，记录在这一段中的max和min，当且仅当max==当前块的最右边值的下标且min==当前块的最左值的下标时，这一块结束。</p><p>此时最左边的下标更新为max的值+1，再将min和max都初始化。</p><h1 id="在lr字符串中交换相邻字符">777、在LR字符串中交换相邻字符⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626722.png" alt="image-20221002122050879" /><figcaption aria-hidden="true">image-20221002122050879</figcaption></figure><p>思路：</p><p>由题意可以知道，L是可以穿过X向左移动，R可以穿过X向右移动，但是L和R都无法互相穿过。因此，单纯地觉得只要将start和end去掉所有的X只要相等就返回true，像下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canTransform</span><span class="params">(String start, String end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start.length() != end.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> start.length();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (start.charAt(i) != <span class="string">&#x27;X&#x27;</span> ) &#123;</span><br><span class="line">                sb1.append(start.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (end.charAt(i) != <span class="string">&#x27;X&#x27;</span> ) &#123;</span><br><span class="line">                sb2.append(end.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb1.toString().equals(sb2.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而出现了一个不可忽略的错误：</p><blockquote><p>例：</p><p>"LXXLXRLXXL"</p><p>"XLLXRXLXLX"</p></blockquote><p>题意是：<code>XL ==&gt; LX；RX ==&gt; XR</code> 。</p><p>按照上面代码所述，不仅可以XL变为LX，也可以LX变为XL，这是不合题意的！</p><p>因此需要增加一个限定条件，即<strong>start中的L要比end中对应的L的下标要大，start中的R要比end中对应的R的下标要小。</strong></p><p>所以，不能使用一次循环，需要使用双指针进行判断。</p><p>新代码思路是：</p><p>对于i和j分别指向start和end字符串，每次分别找一个非X字符，如果相同且满足i和j的关系的，则i++和j++；如果不满足直接返回false。这样的匹配规则，如果是可以完成匹配的，应该是i和j在某一次循环内同时到达终点，<strong>不会存在i卡在某个非X字符，j已经到了终点</strong>，如果是这种情况（即只有一个到了终点的），则之间判断i和j是否相等，如果相等，则返回true，不相等则返回false。</p><h1 id="第k个语法符号">779、第K个语法符号</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626724.png" alt="image-20221020103345966" /><figcaption aria-hidden="true">image-20221020103345966</figcaption></figure><p>本题使用递归思想，不算很难，但是需要找到规律。</p><blockquote><p>第一行：0</p><p>第二行：<strong>0</strong>1</p><p>第三行：<strong>01</strong>10</p><p>第四行：<strong>0110</strong>1001</p><p>第五行：<strong>01101001</strong>10010110</p></blockquote><p>发现什么了！</p><p><strong>每一行的前一半字符是上一行的完整字符。</strong></p><p><strong>每一行的后一半字符是前一半字符的取反，也就是上一行的完整字符取反。</strong></p><p>那结果很明显了！</p><p>使用递归的思想，找到k在这一行的位置，用位运算轻松得到每一行的len。在前半段，它的值就等于上一行的k的位置；在后半段，那它的值就等于上一行的(k-len/2)的位置的值的<strong>取反</strong>。当然这里不是二进制，取反有风险，if判断一下喽！</p><p>完美解决~</p><h1 id="旋转数字">788、旋转数字</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626725.png" alt="image-20220925165535500" /><figcaption aria-hidden="true">image-20220925165535500</figcaption></figure><h1 id="匹配子序列的单词数">792、匹配子序列的单词数</h1><h2 id="方法一暴力微优化">方法一、暴力+微优化</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626789.png" alt="Screenshot_20221117_093435_com.huawei.browser" /> 对words中的每个字符进行判断，加入一定的提前跳出判断，勉强不超时（不推荐）。</p><h2 id="方法二首字母队列">方法二、首字母+队列</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626790.png" alt="Screenshot_20221117_094650_com.huawei.browser" /><figcaption aria-hidden="true">Screenshot_20221117_094650_com.huawei.browser</figcaption></figure><p>很妙！直接看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line"><span class="comment">// 将words中的每个word根据首字母进行分类 </span></span><br><span class="line"><span class="comment">// 设计一个容器，存储以26个字母开头的字符串，这里选择用队列 </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numMatchingSubseq</span><span class="params">(String s, String[] words)</span> &#123; </span><br><span class="line">Deque&lt;String&gt;[] dq = <span class="keyword">new</span> <span class="title class_">Deque</span>[<span class="number">26</span>]; </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123; </span><br><span class="line">dq[i] = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化加入，将所有字符串根据首字母分类 </span></span><br><span class="line"><span class="keyword">for</span> (String word : words) &#123; </span><br><span class="line">dq[word.charAt(<span class="number">0</span>)-<span class="string">&#x27;a&#x27;</span>].addLast(word); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">char</span> sc : s.toCharArray()) &#123; <span class="comment">// 顺序遍历s的每个字母 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> dq[sc-<span class="string">&#x27;a&#x27;</span>].size(); </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123; </span><br><span class="line"><span class="comment">// 对以当前字母开头的字符串判断 </span></span><br><span class="line"><span class="type">String</span> <span class="variable">p</span> <span class="operator">=</span> dq[sc-<span class="string">&#x27;a&#x27;</span>].pollFirst(); </span><br><span class="line"><span class="keyword">if</span> (p.length()==<span class="number">1</span>) &#123; <span class="comment">// 表示只有它本身 </span></span><br><span class="line">sum++; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">dq[p.charAt(<span class="number">1</span>)-<span class="string">&#x27;a&#x27;</span>].addLast(p.substring(<span class="number">1</span>)); <span class="comment">//将除去第一个字符的剩下的字符串再次根据首字母加入 </span></span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> sum; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旋转字符串">796、旋转字符串</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626726.png" alt="image-20221014092503892" /><figcaption aria-hidden="true">image-20221014092503892</figcaption></figure><p>最长对的思路就是：两个字符串合并，如果在其中<code>contains()</code>，那么就存在。</p><h1 id="香槟塔">799、香槟塔</h1><h2 id="方法一动态规划模拟">方法一、动态规划（模拟）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626791.png" alt="Pasted image 20221120093751" /><figcaption aria-hidden="true">Pasted image 20221120093751</figcaption></figure><p>虽然是动态规划，确实不好想，但是想通了很简单。</p><p>我们可以假设第一次<strong>将所有的香槟都倒在第一层的杯里，然后从第一层开始遍历，对于每一个多出来的部分，分给它下面的两个杯子</strong>。</p><p>直接构建一个二维数组即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = (<span class="type">double</span>)poured;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=query_row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;=i; j++) &#123;       <span class="comment">//i行j列（都是从0开始）</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">half</span> <span class="operator">=</span> (dp[i][j]-<span class="number">1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    dp[i][j] = <span class="number">1.0</span>;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j] += half;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] += half;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> dp[query_row][query_glass];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-1">优化</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626792.png" alt="Pasted image 20221120100619" /><figcaption aria-hidden="true">Pasted image 20221120100619</figcaption></figure><p>也就是将二维数组变成一维数组。</p><p>我们可以发现每一层的结构都是依赖上层的结果，所以可以直接设置一维数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">champagneTower</span><span class="params">(<span class="type">int</span> poured, <span class="type">int</span> query_row, <span class="type">int</span> query_glass)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[] dp = &#123;poured&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=query_row; i++) &#123;</span><br><span class="line">            <span class="type">double</span>[] temp = <span class="keyword">new</span> <span class="title class_">double</span>[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;       <span class="comment">//i行j列（都是从0开始）</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">half</span> <span class="operator">=</span> (dp[j]-<span class="number">1</span>)/<span class="number">2.0</span>;</span><br><span class="line">                    temp[j] += half;</span><br><span class="line">                    temp[j+<span class="number">1</span>] += half;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = temp;              <span class="comment">// 直接指针指向</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(<span class="number">1</span>, dp[query_glass]);     <span class="comment">//可能要求输出的不是最后一层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使序列递增的最小交换次数">801、使序列递增的最小交换次数⭐⭐</h1><p>难题！</p><h2 id="方法一分类讨论动态规划">方法一、分类讨论+动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626727.png" alt="image-20221014093122666" /><figcaption aria-hidden="true">image-20221014093122666</figcaption></figure><p>本题题目是问要使得两边都是递增，且<strong>同下标交换</strong>需要的最小的次数。</p><p>所以一共有三种情况： <strong>第一种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; !(nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>第二种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>]) &amp;&amp; !(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>第三种情况：</strong>下标为i的nums1和nums2的值，比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大，且比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; (nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>构建dp数组：<code>int[][] dp = new int[n][2];</code></p><p>第一列对应的是如果这一组不交换所需要的最小次数，第二列对应的是这一组交换所对应的最小次数。</p><p>根据这三种情况分别分析对应的操作：</p><p><strong>第一种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大。如果选择不交换，那么万事大吉，直接<code>dp[i][0] = dp[i-1][0];</code>；如果要交换，为了满足题目的要求，i-1下标的两个值也要交换，所以<code>dp[i][1] = dp[i-1][1] + 1;</code>。</p><p><strong>第二种情况：</strong>下标为i的nums1和nums2的值，只比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。如果选择不交换，为了满足题目意思，需要将i-1下标的两个值交换，所以<code>dp[i][0] = dp[i-1][1];</code>；如果要交换，为了满足题目的要求，i-1下标的就不用交换，所以<code>dp[i][1] = dp[i-1][0] + 1;</code>。</p><p><strong>第三种情况：</strong>下标为i的nums1和nums2的值，比其对应的下标为i-1的<strong>nums1</strong>和<strong>nums2</strong>值大，且比其对应的下标为i-1的<strong>nums2</strong>和<strong>nums1</strong>值大。如果选择不交换，只需要取i-1下标交换或者不交换的更小值即可，即<code>dp[i][0] = Math.min(dp[i-1][0],dp[i-1][1]);</code>；如果要交换，取i-1下标交换或者不交换的更小值，再+1即可，即<code>dp[i][1] = Math.min(dp[i-1][0],dp[i-1][1]) + 1;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; (nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; !(nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!(nums1[i]&gt;nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums2[i-<span class="number">1</span>]) &amp;&amp; (nums1[i]&gt;nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i]&gt;nums1[i-<span class="number">1</span>])) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二方法一dp数组改变">方法二、方法一dp数组改变</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626728.png" alt="image-20221014104859252" /><figcaption aria-hidden="true">image-20221014104859252</figcaption></figure><p>将方法一的<code>int[][] dp = new int[n][2];</code>变成<code>int[][] dp = new int[2][n];</code>，其他思路一致。</p><p>空间换时间的操作。</p><h2 id="方法三优化">方法三、优化</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626729.png" alt="image-20221014105138512" /><figcaption aria-hidden="true">image-20221014105138512</figcaption></figure><p>只保存i-1状态的两个值即可。</p><h1 id="分汤">808、分汤⭐</h1><h2 id="方法一dfs记忆化">方法一、DFS+记忆化</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626793.png" alt="Pasted image 20221121112857" /><figcaption aria-hidden="true">Pasted image 20221121112857</figcaption></figure><p>注意到四种分汤情况都是25的倍数，所以可以先对n进行简化</p><p>然后进行dfs， 当<code>i≤0 &amp;&amp; j≤0</code>时，表示两种汤都分配完了，此时应该返回 <code>0.5</code>； 当 <code>i≤0</code> 时，表示汤 A 先分配完了，此时应该返回 <code>1</code>； 当 <code>j≤0</code> 时，表示汤 B 先分配完了，此时应该返回 <code>0</code>。</p><p><code>double ans = 0.25 * (dfs(i - 4, j) + dfs(i - 3, j - 1) + dfs(i - 2, j - 2) + dfs(i - 1, j - 3));</code></p><p>但是需要注意，之这样写一定会显示时间超出</p><h3 id="优化1">优化1</h3><p>加入记忆化方式，也就是加入一个数组，记录在A有i和B有j的情况下的概率信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (memo[i][j]==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.25</span> * (dfs(i-<span class="number">4</span>,j) + dfs(i-<span class="number">3</span>,j-<span class="number">1</span>) + dfs(i-<span class="number">2</span>,j-<span class="number">2</span>) + dfs(i-<span class="number">1</span>,j-<span class="number">3</span>));</span><br><span class="line">memo[i][j] = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是仍然会出现空间超出</p><h3 id="优化2">优化2</h3><p>借助数学的方式，在<code>n=4800</code>时，结果为0.999994994426，而题目要求的精度为<span class="math inline">\(10^{-5}\)</span>，并且随着n的增大，结果越来越接近1，因此，当<code>n&gt;4800</code>时，直接返回1即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (n&gt;=<span class="number">4800</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码">完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">double</span>[][] memo;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">0</span> &amp;&amp; j&lt;=<span class="number">0</span>) &#123;    <span class="comment">//表示都分配完了  </span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (i&lt;=<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (j&lt;=<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//记忆化（否则会超出时间）  </span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j]==<span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0.25</span> * (dfs(i-<span class="number">4</span>,j) + dfs(i-<span class="number">3</span>,j-<span class="number">1</span>) + dfs(i-<span class="number">2</span>,j-<span class="number">2</span>) + dfs(i-<span class="number">1</span>,j-<span class="number">3</span>));  </span><br><span class="line">            memo[i][j] = sum;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> memo[i][j];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 在 10-5 下接近1，所以直接输出1即可（否则会超出空间）  </span></span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">4800</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        n = (n+<span class="number">24</span>)/<span class="number">25</span>;     <span class="comment">//如果一开始给的汤不是25的倍数，就向上取整（多出来的一部分也可以分配）  </span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];  </span><br><span class="line">        <span class="keyword">return</span> dfs(n,n);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划-2">方法二、动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626794.png" alt="Pasted image 20221121115908" /><figcaption aria-hidden="true">Pasted image 20221121115908</figcaption></figure><p>动态规划难在初始化。本题需要一个二维数组进行动态规划。</p><ol type="1"><li><p>表示A和B都没有了</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.5</span>;     </span><br></pre></td></tr></table></figure></p></li><li><p>表示A没有了</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span>;     <span class="comment">//表示A没有 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>表示B没有了（B没有返回0，所以根据初始化自动为0）</p></li></ol><h3 id="完整代码-1">完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">soupServings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n&gt;=<span class="number">4800</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = (n+<span class="number">24</span>)/<span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span>[][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0.5</span>;     <span class="comment">//表示A和B都没有了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;     <span class="comment">//表示A没有 </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;      <span class="comment">//当j=0时就是0，而数组初始化时自动为0</span></span><br><span class="line">                dp[i][j] = <span class="number">0.25</span> * (dp[Math.max(<span class="number">0</span>,i-<span class="number">4</span>)][j] + dp[Math.max(<span class="number">0</span>,i-<span class="number">3</span>)][Math.max(<span class="number">0</span>,j-<span class="number">1</span>)] + dp[Math.max(<span class="number">0</span>,i-<span class="number">2</span>)][Math.max(<span class="number">0</span>,j-<span class="number">2</span>)] + dp[Math.max(<span class="number">0</span>,i-<span class="number">1</span>)][Math.max(<span class="number">0</span>,j-<span class="number">3</span>)]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="情感丰富的文字">809、情感丰富的文字</h1><h2 id="方法一逐字对比长度加速">方法一、逐字对比+长度加速</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626795.png" alt="Pasted image 20221126195121" /><figcaption aria-hidden="true">Pasted image 20221126195121</figcaption></figure><p>对每个字符串进行检索，找到当前字符连续的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">expressiveWords</span><span class="params">(String s, String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w.length() &gt; s.length()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">char</span>[] wc = w.toCharArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;s.length() &amp;&amp; j&lt;w.length()) &#123;    <span class="comment">// i定位s，j定位w</span></span><br><span class="line">                <span class="keyword">if</span> (sc[i] == wc[j]) &#123;    <span class="comment">//如果字符相等</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> sc[i];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((i+<span class="number">1</span>)&lt;s.length() &amp;&amp; sc[i+<span class="number">1</span>]==t) &#123;</span><br><span class="line">                        l1++;</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> ((j+<span class="number">1</span>)&lt;w.length() &amp;&amp; wc[j+<span class="number">1</span>]==t) &#123;</span><br><span class="line">                        l2++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (l1==l2 || (l1 &gt; l2 &amp;&amp; l1 &gt;= <span class="number">3</span>)) &#123;</span><br><span class="line">                        i++;</span><br><span class="line">                        j++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        isFind = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isFind = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==s.length() &amp;&amp; j == w.length() &amp;&amp; isFind) &#123;</span><br><span class="line">                sum ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="子域名访问计数">811、子域名访问计数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626730.png" alt="image-20221005111235484" /><figcaption aria-hidden="true">image-20221005111235484</figcaption></figure><p>本题逻辑简单，但是涉及很多java语法知识。</p><h3 id="hashmap散列表">HashMap（散列表）</h3><p>创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line"></span><br><span class="line">添加键值对</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">hash.put(<span class="string">&quot;abc&quot;</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>查找值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.get(<span class="string">&quot;abc&quot;</span>);    <span class="comment">//输出2</span></span><br></pre></td></tr></table></figure><p>更新值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.replace(<span class="string">&quot;abc&quot;</span>,<span class="number">3</span>);    <span class="comment">//以后hash里面&quot;abc&quot;对应的value就是3</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.replace(<span class="string">&quot;abc&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);    <span class="comment">//只对hash键值对为&quot;abc&quot;-2的修改value为3，如果键值对不符合则返回false</span></span><br></pre></td></tr></table></figure><p>查找键值对数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.size()</span><br></pre></td></tr></table></figure><p>判断是否为空</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.isEmpty()    <span class="comment">//如果为空返回true</span></span><br></pre></td></tr></table></figure><p>判断是否有某个key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.containsKey(<span class="string">&quot;abc&quot;</span>)    <span class="comment">//如果有则返回true</span></span><br></pre></td></tr></table></figure><p>判断是否有某个value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.containsValue(<span class="number">3</span>)    <span class="comment">//如果有则返回true</span></span><br></pre></td></tr></table></figure><p>遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一、forEach</span></span><br><span class="line">hash.forEach((key,value)-&gt; &#123;</span><br><span class="line">    <span class="comment">//对于每一组key和value的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> value.toString() + key;</span><br><span class="line">    res.add(s);</span><br><span class="line">&#125;);    <span class="comment">//不要忘记分号</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法二、最推荐，遍历entey获取key和value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;  <span class="comment">//entrySet()返回hashMap中所有映射项的集合集合视图。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法三、单独取出key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : hash.KeySet()) &#123;    <span class="comment">//keySet()返回hashMap中所有key组成的集合视图。</span></span><br><span class="line">    <span class="comment">//对key操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (String value : hash.values()) &#123;    <span class="comment">//values()返回hashMap中所有value组成的集合视图。</span></span><br><span class="line">    <span class="comment">//对key操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除所有键值对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.clear();</span><br></pre></td></tr></table></figure><h3 id="字符串按空格分割">字符串按空格分割</h3><p>对于<code>String s = "a  b     c  d e f      g"</code></p><p>分割单个空格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="comment">//遍历输出后：</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="comment">//e</span></span><br><span class="line"><span class="comment">//f</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//g</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>分割多个连续空格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] sa = s.split(<span class="string">&quot;\\s+&quot;</span>);    <span class="comment">//正则</span></span><br><span class="line"><span class="comment">//遍历后：</span></span><br><span class="line"><span class="comment">//a</span></span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="comment">//c</span></span><br><span class="line"><span class="comment">//d</span></span><br><span class="line"><span class="comment">//e</span></span><br><span class="line"><span class="comment">//f</span></span><br><span class="line"><span class="comment">//g</span></span><br></pre></td></tr></table></figure><h3 id="字符串转为整数">字符串转为整数</h3><p>使用<code>Integer.parseInt(s)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(s);</span><br></pre></td></tr></table></figure><h3 id="长度函数">长度函数</h3><ol type="1"><li><p><code>length</code>：<strong>数组</strong>长度</p></li><li><p><code>length()</code>：<strong>字符串</strong>长度</p></li><li><p><code>size()</code>：<strong>列表</strong>长度</p></li></ol><h3 id="list的构建">List的构建</h3><p>对于单个List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>对于嵌套List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; ll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h1 id="链表组件">817、链表组件</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626731.png" alt="image-20221009164428565" /><figcaption aria-hidden="true">image-20221009164428565</figcaption></figure><p>先用一个容器将nums里的所有数值全都存储起来，之后在遍历链表判断当前值是否在nums数组中。</p><p>什么样的容器具有这样的功能呢？String？Map？对！Map最合适！</p><p>所以我们选择HashMap,和他的containsKey（也可以使用containsValue）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer,Boolean&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Boolean&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">    hash.put(num,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (hash.containsKey(p.val)) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再判断有多少个组件，常规思路。</p><h1 id="隐藏个人信息">831. 隐藏个人信息</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304011156916.png" /></p><p>中等题，简单构造题。</p><h1 id="考场就座">855. 考场就座⭐</h1><p><a href="https://leetcode.cn/problems/exam-room/solutions/2037441/liang-chong-jie-fa-you-xu-ji-he-you-xian-bjrv/">题解</a></p><h2 id="方法一有序集合">方法一、有序集合</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626796.png" alt="Pasted image 20221230231503" /><figcaption aria-hidden="true">Pasted image 20221230231503</figcaption></figure><p>考察<a href="LeetCode总结笔记.md#有序集合TreeSet">有序集合 TreeSet</a> 的应用。</p><p>思路其实并不复杂，对于 leave 其实就是 remove () 函数；对于 seat 其实就是判断<strong>每一段之间的距离的一半</strong>和<strong>最左边与左端点的距离</strong>和<strong>最右边与右端点的距离</strong>的最大值。如果是段之间的距离更大，那么点就在段中点；如果左边的距离更大，那么点就在 0；如果右边距离更大，那么点就在 n-1。</p><p>此外还需要注意局部变量和全局变量之间的转换。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExamRoom</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义全局变量</span></span><br><span class="line">    TreeSet&lt;Integer&gt; ts;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExamRoom</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.n = n;      <span class="comment">//将局部变量转为全局变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">seat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ts.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            ts.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当有一个时，第二个需要放在最后</span></span><br><span class="line">        <span class="comment">//但是需要考虑如果一开始放了两个，但是把第一个leave，只有最后一个了，应该怎么处理</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从左向右遍历每一段之间的最短（暂时不考虑两端）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> ts.first();</span><br><span class="line">        <span class="type">int</span> <span class="variable">disl</span> <span class="operator">=</span> ts.first()-<span class="number">0</span>;           <span class="comment">//初始为最左边离左端点的距离，变量表示两个向量之间的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">inx</span> <span class="operator">=</span> <span class="number">0</span>;                     <span class="comment">//要放置的位置，初始是0，是考虑到端点没有放，但是中间有值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : ts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disl &lt; (x-left)/<span class="number">2</span>) &#123;</span><br><span class="line">                disl = (x-left)/<span class="number">2</span>;</span><br><span class="line">                inx = (x+left)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时得到的disl表示 左边距离左端点 和 每一段之间若放置的两边的距离的最大值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">disr</span> <span class="operator">=</span> n-<span class="number">1</span>-ts.last();        <span class="comment">//表示最右边距离右端点的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (disl &lt; disr) &#123;    <span class="comment">//表示最右边距离右端点的距离最大，应该放置在右端点处</span></span><br><span class="line">            inx = n-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ts.add(inx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> inx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leave</span><span class="params">(<span class="type">int</span> p)</span> &#123;</span><br><span class="line">        ts.remove(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二有序集合优先队列">方法二、有序集合+优先队列</h2><p>见题解。</p><h1 id="括号的分数">856、括号的分数</h1><h2 id="方法一栈">方法一、栈</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626732.png" alt="image-20221009165925676" /><figcaption aria-hidden="true">image-20221009165925676</figcaption></figure><p>遇到括号匹配，第一时间想到什么？——栈！！</p><p><strong>但是Java没有栈，只能用Deque双端队列代替。</strong></p><p>需要多次使用的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line">Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">dq.addLast(st);</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出并返回</span></span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> dq.pollLast();</span><br></pre></td></tr></table></figure><h3 id="拓展-1">拓展：</h3><p>String的相等操作： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2);</span><br></pre></td></tr></table></figure></p><p>char的相等操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c1 == c2;</span><br></pre></td></tr></table></figure><p>char转为String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">st</span> <span class="operator">=</span> String.valueOf(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p>char转为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="string">&#x27;5&#x27;</span> - <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>String转为int</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = Integer.parseInt(<span class="string">&#x27;23&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="方法二一次遍历">方法二、一次遍历⭐</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626733.png" alt="image-20221009170918190" /><figcaption aria-hidden="true">image-20221009170918190</figcaption></figure><p>这个方法思路真的很妙！</p><ol type="1"><li><p>首先，所有的<code>()</code>都是<code>1</code>，所以用replace将<code>()</code>换成<code>1</code></p></li><li><p>对s进行遍历，遇到1个<code>(</code>，则对于后面的1乘以2，遇到<code>)</code>，则对后面的1除以2</p><blockquote><p><strong>例子：((())(())())</strong></p><p>可以看出这题的结果时：(1*2 + 1*2 + 1)*2 = 1*2*2 + 1*2*2 + 1*2</p><ol type="1"><li><p>替换：((1)(1)1)</p></li><li><p>从左遍历，第一个1左边有2个(、0个)，所以对于1*2*2</p><p>第二个1左边有3个(、1个)，所以对于1*2*2*2/2 = 1*2*2</p><p>第三个1左边有3个(、2个)，所以对于1*2*2*2/2/2 = 1*2</p></li></ol></blockquote></li></ol><p>注意：<code>连续乘以n个2</code>的操作，可以用<code>number &lt;&lt; n</code>表示。</p><h1 id="和至少为k的最短子数组">862、和至少为K的最短子数组⭐⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626734.png" alt="image-20221026215844261" /><figcaption aria-hidden="true">image-20221026215844261</figcaption></figure><p>很难且恶心人的一题。</p><p>贴上我的心路历程：</p><p>一开始我是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>]&gt;=k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j&lt;n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;=k) &#123;</span><br><span class="line">                    min = Math.min(min,step);</span><br><span class="line">                    temp -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                    step--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp += nums[j];</span><br><span class="line">                    step++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp&gt;=k) &#123;</span><br><span class="line">                    min = Math.min(min,step);</span><br><span class="line">                    temp -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                    step--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp -= nums[i];</span><br><span class="line">                    i++;</span><br><span class="line">                    step--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==<span class="number">100001</span> ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后来发现，如果出现 k=5， 1, -2, 2, 7这种情况就没法找到真正的最短。</p><p>然后我使用双层for循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] preadd = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];    <span class="comment">//记录当前i以前的元素的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            preadd[i] = preadd[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j-i&gt;=min) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (preadd[j]-preadd[i]&gt;=k) &#123;</span><br><span class="line">                    min = Math.min(min,j-i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==<span class="number">100001</span> ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，根据题解……我转换了思路。⭐</p><p>以每个元素为开始的最短的长度是一定的</p><p>preadd的作用看代码能懂吧，所以以i为开始的满足条件的数组的长度就是<code>preadd[j]-preadd[i]</code>，长度就是<code>j-i</code>。</p><p>利用一个for循环控制结束的字符，用一个队列控制开始的字符。（其实数组也可，但是会慢些）</p><p>第一个while是确定结束位置，依次更新初始位置。</p><p>第二个while是对结束位置的左边进行筛选，为了减少复杂度，如果它的相邻左边的preadd比它的preadd要大，根据<code>preadd[j]-preadd[i]</code>，如果preadd[i]要比preadd[i-1]小，那么以某个j结尾的，一定会选择i而不会以i-1开头，所以在这里可以删掉i-1了。</p><p>每次都将当前j加入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">long</span>[] preadd = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];    <span class="comment">//记录当前i以前的元素的和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            preadd[i] = preadd[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];     <span class="comment">//存的是当前值之前的所有的和</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> n+<span class="number">1</span>;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();    <span class="comment">//dq存的是需要查询的起始位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n+<span class="number">1</span>;j++) &#123;     <span class="comment">//以i为结尾，以dq.pollFirst()为开始</span></span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; preadd[j]-preadd[dq.peekFirst()]&gt;=k) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">                min = Math.min(min,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; preadd[dq.peekLast()]&gt;=preadd[j]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min==n+<span class="number">1</span> ? -<span class="number">1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优势洗牌">870、优势洗牌⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626735.png" alt="image-20221009202231681" /><figcaption aria-hidden="true">image-20221009202231681</figcaption></figure><p>本题思路简单，但是操作困难，需要知道如何保证不动nums2的前提下，根据其值对其下标进行排序的方法</p><p>这里涉及到sort的匿名函数表达式的知识点： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] index = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    index[i] = i;     <span class="comment">//此时index的值对应nums2的每个值的下标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重点：对index排序，排序的规则是对于index的值a和b，如果nums2[a]&gt;nums2[b]，则a在b后面</span></span><br><span class="line">Arrays.sort(index,(a,b)-&gt;nums2[a]-nums[b]);</span><br><span class="line"><span class="comment">//这里的意思是，如果nums[a]-nums[b]&gt;0，返回的是1，表示前者更大，按照我们的约定，应该将b放在a前面</span></span><br></pre></td></tr></table></figure></p><p>这里需要注意的是：</p><ol type="1"><li>使用匿名表达式的数组必须是原始数组，也就在这里index数组是不能是int，只能是Integer</li><li><code>Arrays.sort(index,(a,b)-&gt;function);</code>表示的是对于<code>index数组</code>而言，只有当<code>function&gt;0</code>时，会将<code>(a,b)</code>变成<code>(b,a)</code></li></ol><p>关于sort函数复写排序规则，还有一种更加常规的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(index, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;       <span class="comment">//注意index一定要是Integer（不能是int）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;       <span class="comment">//注意是和上面的In&#x27;te&#x27;g</span></span><br><span class="line">        <span class="keyword">if</span> (nums2[a] &gt; nums2[b]) &#123;    <span class="comment">//按照要求，a应该在b后面，也就是要从(a,b)变成(b,a)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;         <span class="comment">//return 1表示调换</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;       <span class="comment">//return -1表示保持不变</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="第n个神奇数字">878、第N个神奇数字⭐🌟</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626736.png" alt="image-20221009172307797" /><figcaption aria-hidden="true">image-20221009172307797</figcaption></figure><p>这题思路很巧妙，我们会第一时间想到找到所有的满足条件的数，直到第ｎ个，但是这样的工作量真的太大了，应为涉及到加法和乘法。</p><p>所以我们不妨换个思路，在很大的范围内，找到这个符合条件的数。</p><ol type="1"><li><p>首先确定搜索方法，一般查找都会选择<strong>二分查找</strong>，效率高。</p></li><li><p>再确定范围，起点范围0，终点范围呢？其实用<code>max(a,b)*n</code>或者<code>min(a,b)*n</code>都可以。但是通过测试，我们的目标值其实更接近<code>min(a,b)*n</code>，但是正因为这样，如果使用<code>min(a,b)*n</code>，需要更多步骤才能找到，所以我们选择<code>max(a,b)*n</code>。</p></li><li><p>那判断是否为目标数值的条件呢？</p><p>我们通过小数找规律，可以发现，第n个符合规则的数一定是</p><p><code>num/a + num/b - num/gbs(a,b) == n</code>，可以好好揣摩一下这个规则。</p><p>但是并不是只有我们目标的那个第n个符合规则的数满足，第n和第n+1个数之间的数都满足，所以我们需要找到符合这个条件的最左值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心代码，判断一个数是不是我们要的第n个数</span></span><br><span class="line">    <span class="keyword">if</span> (mid/a + mid/b - mid/gbs_num &lt; n) &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;    <span class="comment">//注意：当在第n~n+1个数之间的所有数都满足这个条件（因为/只保留了商），因此我们需要找到第一个满足这个条件的数</span></span><br><span class="line">        right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后返回<code>left%MOD</code>即可。</p></li></ol><p>（找最小公倍数，需要找到最小公因数，这个很简单。）</p><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gys</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gys(b,a%b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gbs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a*b/gys(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1_000_000_007</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里使用max或者min都行，但是max内存消耗更少，因为右边界越大，目标就月靠近中间，能更快找到。如果使用min，反而目标靠近边界，复杂度更高。</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> (<span class="type">long</span>) Math.max(a,b)*n;      <span class="comment">// 注意Math库返回的是int类型</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">gbs_num</span> <span class="operator">=</span> gbs(a,b);    <span class="comment">//找到最小公倍数</span></span><br><span class="line">        <span class="comment">// System.out.println(gbs_num);</span></span><br><span class="line">        <span class="keyword">while</span> (left&lt;right) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right-left)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//核心代码，判断一个数是不是我们要的第n个数</span></span><br><span class="line">            <span class="keyword">if</span> (mid/a + mid/b - mid/gbs_num &lt; n) &#123;     </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//注意：当在第n~n+1个数之间的所有数都满足这个条件（因为/只保留了商），因此我们需要找到第一个满足这个条件的数</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (left%MOD);    <span class="comment">//需要注意：(int)只对后面相邻的数有效，所以别忘了括号。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tips">tips</h4><p>一定要注意Math库返回的都是int类型，本题需要转为long型</p><h1 id="细分图中的可到达节点">882、细分图中的可到达节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="子序列宽度之和">891、子序列宽度之和</h1><p>典型数学题目</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626797.png" alt="Screenshot_20221118_105117_com.huawei.browser" /><figcaption aria-hidden="true">Screenshot_20221118_105117_com.huawei.browser</figcaption></figure><p>仔细分析题目，可以发现子序列只与最大值和最小值有关，和序列的顺序无关。</p><p>所以可以先对数组进行排序。</p><p>再按照下面思路进行：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626798.jpg" alt="1 3 5 8_202211181058_07318 1" /><figcaption aria-hidden="true">1 3 5 8_202211181058_07318 1</figcaption></figure><p>直接看代码更容易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubseqWidths</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">long</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++) &#123;</span><br><span class="line">            k = (k &lt;&lt; <span class="number">1</span>)%MOD;</span><br><span class="line">            temp = (temp*<span class="number">2</span>%MOD + nums[i-<span class="number">1</span>])%MOD;</span><br><span class="line">            sum = (sum + (nums[i]*(k-<span class="number">1</span>) - temp)%MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="股票价格跨度">901、股票价格跨度⭐</h1><h2 id="方法一栈-1">方法一、栈⭐</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626737.png" alt="image-20221021183314076" /><figcaption aria-hidden="true">image-20221021183314076</figcaption></figure><h4 id="题目翻译">题目翻译</h4><p>返回每一天的比这一天的股票价格小于或者等于的连续天数。</p><h4 id="思路">思路</h4><p>构造一个二元栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stock</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.day = day;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于输入的每一个节点，默认day是1。<a href="https://leetcode.cn/problems/online-stock-span/solutions/1910400/-by-muse-77-byhj/">题解</a></p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626738.png" alt="image-20221021183855971" /><figcaption aria-hidden="true">image-20221021183855971</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!st.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">            <span class="type">Stock</span> <span class="variable">temp</span> <span class="operator">=</span> st.peekLast();</span><br><span class="line">            <span class="keyword">if</span> (price&gt;=temp.price) &#123;</span><br><span class="line">                st.pollLast();</span><br><span class="line">                day = day + temp.day;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    st.addLast(<span class="keyword">new</span> <span class="title class_">Stock</span>(price,day));</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码-2">完整代码</h4><p>（面向对象的写法，注意结构体的构造等知识）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StockSpanner</span> &#123;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Stock&gt; st;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Stock</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> price;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> day;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Stock</span><span class="params">(<span class="type">int</span> price, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.price = price;</span><br><span class="line">            <span class="built_in">this</span>.day = day;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">        st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Stock&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!st.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Stock</span> <span class="variable">temp</span> <span class="operator">=</span> st.peekLast();</span><br><span class="line">                <span class="keyword">if</span> (price&gt;=temp.price) &#123;</span><br><span class="line">                    st.pollLast();</span><br><span class="line">                    day = day + temp.day;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st.addLast(<span class="keyword">new</span> <span class="title class_">Stock</span>(price,day));</span><br><span class="line">        <span class="keyword">return</span> day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二数组">方法二、数组</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626739.png" alt="image-20221021184036499" /><figcaption aria-hidden="true">image-20221021184036499</figcaption></figure><p>思路一致。</p><p>我们还需要两个指针，分别是index指针，用来指向“待输入股票”；p指针，index指针的前一个指针，用来与“待输入股票”进行price对比用的，如果它的price小于等于“待输入股票”的price，p就会向前移动。</p><p>关于p向前移动还有一点需要注意的就是，p向前移动格子的数量，就是days的具体值；当days等于1时，就向前移动1个格子；如果days等于2时，就向前移动2个格子（因为days等于2，说明已经是两个格子聚合过的值了，就不需要重复统计了）。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626740.png" alt="image-20221021184303533" /><figcaption aria-hidden="true">image-20221021184303533</figcaption></figure><p>初始化时注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    prices = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">    days = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100010</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三list">方法三、List</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626741.png" alt="image-20221021184138152" /><figcaption aria-hidden="true">image-20221021184138152</figcaption></figure><p>思路一致。</p><h1 id="最大为-n-的数字组合">902、最大为 N 的数字组合⭐⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626742.png" alt="image-20221018223704471" /><figcaption aria-hidden="true">image-20221018223704471</figcaption></figure><p>非常难的一题，难在实现上！</p><h1 id="水果成篮">904、水果成篮</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626743.png" alt="image-20221017104714073" /><figcaption aria-hidden="true">image-20221017104714073</figcaption></figure><p>构建两个数组，分别记录某一个连续值的值和出现的次数，比较简单。（当然可以将两个数组并为一个二维数组）</p><h1 id="子数组的最小值之和">907、子数组的最小值之和⭐⭐</h1><h2 id="方法一单调栈动态规划">方法一、单调栈+动态规划</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626744.png" alt="image-20221028190348577" /><figcaption aria-hidden="true">image-20221028190348577</figcaption></figure><p>维护两个数组，分别维护左边界和右边界（对于下标为i的辐射左范围为left[i]+1（left[i]不在范围内））。</p><p>建立一个单调栈，两次遍历数组，更新左边界和右边</p><blockquote><p>3 4 1 2 5 6</p><p>对于1的辐射范围，左边范围长度为3，右边为4 1, 41, 12, 341, 412, 125, 3412, 4125, 1256, 34125, 41256, 341256，共12个</p><p>对于4的辐射范围，左边范围长度为1，右边为1 4，共1个</p><p>对于6的辐射范围，左边范围长度为1，右边为1 6，共1个</p></blockquote><p>看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//对于下标为i的辐射左范围为left[i]+1（left[i]不在范围内）</span></span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; arr[i]&lt;arr[dq.peekLast()]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq.isEmpty()) &#123;</span><br><span class="line">                left[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left[i] = dq.peekLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dq.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; arr[i]&lt;=arr[dq.peekLast()]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq.isEmpty()) &#123;</span><br><span class="line">                right[i] = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right[i] = dq.peekLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3 4 1 2 5 6</span></span><br><span class="line">        <span class="comment">// 对于1的辐射范围，左边范围长度为3，右边为4</span></span><br><span class="line">        <span class="comment">// 1, 41, 12, 341, 412, 125, 3412, 4125, 1256, 34125, 41256, 341256，共12个</span></span><br><span class="line">        <span class="comment">// 对于4的辐射范围，左边范围长度为1，右边为1</span></span><br><span class="line">        <span class="comment">// 4，共1个</span></span><br><span class="line">        <span class="comment">// 对于6的辐射范围，左边范围长度为1，右边为1</span></span><br><span class="line">        <span class="comment">// 6，共1个</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            sum = (sum + (<span class="type">long</span>)arr[i] * (i-left[i]) * (right[i]-i)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分割数组">915、分割数组</h1><h2 id="方法一最小值分割">方法一、最小值分割</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626745.png" alt="image-20221025214008642" /><figcaption aria-hidden="true">image-20221025214008642</figcaption></figure><p>先找到数组的最小值，最小值包括左边的部分和右边的部分一定需要分开的，如果左边的最大值&lt;=右边的最小值，那么ok，否则对右边部分继续找最小值，继续划分。</p><h2 id="方法二两次遍历">方法二、两次遍历</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626746.png" alt="image-20221025220514828" /><figcaption aria-hidden="true">image-20221025220514828</figcaption></figure><p>先从后向前遍历一遍，用min[i]表示i位置及其以后区域的最小值。</p><p>再从前往后遍历一遍，用max记录以当前元素结尾的区域的最大值。</p><p>第二次遍历过程中，如果某一次遍历时发现<code>max &lt;= min[i+1]</code>，则i就是分隔符，返回i+1个元素。</p><h1 id="环形子数组的最大和">918、环形子数组的最大和⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626747.png" alt="image-20221019211520951" /><figcaption aria-hidden="true">image-20221019211520951</figcaption></figure><p>本题是<code>53、最大子数组和</code>的加强版。使用的仍然是动态规划的内容。</p><h4 id="分析">分析</h4><p>本题因为是环形，所以需要考虑两种情况。</p><p>情况1：我们的最终答案是<code>53</code>题中的不考虑环的情况。</p><p>情况2：我们的答案包含nums的尾部和nums的首部。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626748.png" alt="image-20221019211933787" /><figcaption aria-hidden="true">image-20221019211933787</figcaption></figure><h4 id="思路-1">思路</h4><p>情况1很简单，直接仿照<code>53</code>题进行即可。</p><p>情况2复杂，需要考虑首位，但是首位又是动态的，很麻烦。但是我们能不能换种思路，我们要找到nums的<strong>最小子数组和</strong>min。那么最长的首位组合就是整个nums之和减去这个最小子数组和。</p><h4 id="特殊">特殊</h4><p>我们需要考虑，如果情况一得到的max小于0，说明整个nums中没有一个元素是&gt;0的，那么直接输出max（矮子当中选将军），它就是最大的那个了。否则表示数组中存在正数，那么输出max和sum-min中的最大值</p><h1 id="三等分">927、三等分</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626749.png" alt="image-20221006155904427" /><figcaption aria-hidden="true">image-20221006155904427</figcaption></figure><p>思路有点复杂，实现不难：</p><p>先判断每一组有多少个1，把每个1的下标都放在一个新的数组中，然后判断三组之间对应的1和1之间的距离是否相等，再判断最后一组的最后一个1后的空格其他组是否能满足。</p><h1 id="最短的桥">934、最短的桥⭐</h1><p>比较难的一题，题目难懂，方法难想到。</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626750.png" alt="image-20221025210227986" /><figcaption aria-hidden="true">image-20221025210227986</figcaption></figure><h4 id="思路-2">思路</h4><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626751.png" alt="image-20221025210421377" /><figcaption aria-hidden="true">image-20221025210421377</figcaption></figure><h4 id="代码">代码</h4><p>详细的思路看代码更好理解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] step = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    Deque&lt;<span class="type">int</span>[]&gt; edge;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        edge = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过找到一个岛屿的一块，利用DFS找到这个岛屿的所有块，并标记为2</span></span><br><span class="line">        <span class="comment">//并找到它的边源水域，也标记成为2，并加入edge队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>) &#123;    <span class="comment">//表示已经找到了第一个岛屿的一块了</span></span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                    Mark(grid,i,j);     <span class="comment">//对当前块进行标记为2（通过DFS岛屿标记）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">//目前已经扩充一波水域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时第一轮扩充已经完成</span></span><br><span class="line">        <span class="keyword">while</span> (!edge.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edge.size();    <span class="comment">//获取第一个岛屿的边缘水域</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="type">int</span>[] loc = edge.pollFirst();    <span class="comment">//第一个区域的边缘位置</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[]s : step) &#123;    <span class="comment">//对当前位置的四个方向进行扩充</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> loc[<span class="number">0</span>]+s[<span class="number">0</span>], y = loc[<span class="number">1</span>]+s[<span class="number">1</span>];    </span><br><span class="line">                    <span class="keyword">if</span> (!isLegal(x,y,grid.length)) &#123;       <span class="comment">//如果位置不合法</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>) &#123;    <span class="comment">//表示已经找到了另一个岛屿</span></span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[x][y] == <span class="number">0</span>) &#123;    <span class="comment">//扩充水域</span></span><br><span class="line">                        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        edge.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Mark</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLegal(i,j,grid.length)) &#123;    <span class="comment">//如果不是合法位置，退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]==<span class="number">2</span>) &#123;    <span class="comment">//如果是同一个岛屿且已经被标记，退出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>) &#123;     <span class="comment">//如果是同一个岛屿但是还没有被标记</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[]s : step) &#123;</span><br><span class="line">                Mark(grid,i+s[<span class="number">0</span>],j+s[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j]==<span class="number">0</span>) &#123;     <span class="comment">//如果遇到水域，则表示已经到了这个岛屿的边界了，将这个水也变成岛屿的一部分，在存储边界水域的edge中添加</span></span><br><span class="line">            grid[i][j] = <span class="number">2</span>;</span><br><span class="line">            edge.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLegal</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> n)</span> &#123;    <span class="comment">//判断是否在合法区域（没有超过边界）</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;=n || j&lt;<span class="number">0</span> || j&gt;=n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="强整数">970. 强整数</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305021012403.png" /></p><p>中等题，但是比较简单。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">powerfulIntegers</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> bound)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; x_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; y_list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">1</span>) &#123;</span><br><span class="line">            x_list.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">1</span> &amp;&amp; sum &lt;= bound) &#123;</span><br><span class="line">            x_list.add(sum);</span><br><span class="line">            sum = sum*x;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y==<span class="number">1</span>) &#123;</span><br><span class="line">            y_list.add(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (y!=<span class="number">1</span> &amp;&amp; sum &lt;= bound) &#123;</span><br><span class="line">            y_list.add(sum);</span><br><span class="line">            sum = sum*y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;x_list.size();i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;y_list.size();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x_list.get(i)+y_list.get(j)&lt;=bound) &#123;</span><br><span class="line">                    set.add(x_list.get(i)+y_list.get(j));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : set) &#123;</span><br><span class="line">            res.add(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按位与为零的三元组">982. 按位与为零的三元组</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303041201279.png" /></p><p>我们可以先枚举任意两个数 x 和 y，用数组统计它们的按位与结果 x&amp;y出现的次数。然后枚举 x 和 y 的按位与结果 xy，再枚举 z，如果 xy&amp;z=0，则将 cnt[xy] 的值加入答案。</p><blockquote><p>常识：两个数相与的结果一定是小于等于这两个数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countTriplets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 两个数相与的结果一定是小于等于这个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            max_n = Math.max(max_n, n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] re = <span class="keyword">new</span> <span class="title class_">int</span>[max_n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> b : nums) &#123;</span><br><span class="line">                re[a &amp; b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;max_n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                        res += re[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="检查替换后的词是否有效">1003. 检查替换后的词是否有效</h1><h2 id="方法一字符串操作">方法一、字符串操作</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305032222985.png" /></p><p>不断对 s 删除"abc"字符串，如果最后能删除干净，那么返回 true，否则返回 false。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s.length()!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(s);</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s.length()-<span class="number">2</span>;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.substring(i,i+<span class="number">3</span>).compareTo(<span class="string">&quot;abc&quot;</span>)==<span class="number">0</span>) &#123;</span><br><span class="line">                    s = s.substring(<span class="number">0</span>,i) + s.substring(i+<span class="number">3</span>);</span><br><span class="line">                    isFind = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isFind) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二栈">方法二、栈</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305032240065.png" /></p><p>其实思路与上面一致，但是上面的方法每次都要重新构造 s，会有很大的时间和空间开销，所以用栈将字符串的每个字符依次入栈，如果遇到"abc"，弹出去，依次进行，如果栈空则 true。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            dq.addLast(sc[i]);</span><br><span class="line">            <span class="keyword">while</span> (dq.size()&gt;=<span class="number">3</span> &amp;&amp; dq.peekLast()==<span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                <span class="keyword">if</span> (a!=<span class="string">&#x27;a&#x27;</span> || b!=<span class="string">&#x27;b&#x27;</span> || c!=<span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                    dq.addLast(a);</span><br><span class="line">                    dq.addLast(b);</span><br><span class="line">                    dq.addLast(c);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dq.size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三stringbuilder">方法三、StringBuilder</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305032246039.png" /></p><p>这是上面两种方法的结合。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()%<span class="number">3</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++) &#123;</span><br><span class="line">            sb.append(sc[i]);</span><br><span class="line">            <span class="keyword">if</span> (sb.length()&gt;=<span class="number">3</span> &amp;&amp; <span class="string">&quot;abc&quot;</span>.equals(sb.substring(sb.length()-<span class="number">3</span>))) &#123;</span><br><span class="line">                sb.delete(sb.length()-<span class="number">3</span>,sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sb.length()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="填充书架">1105. 填充书架⭐</h1><blockquote><p>考察： #动态规划</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304230907525.png" /></p><p>中等题，思路难。</p><p>题解：<a href="https://blog.csdn.net/snailbuster/article/details/98311032?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">题解</a></p><p>这里 <code>dp[i]</code> 表示在放到第 <code>i</code> 本书的时候的总高度最优解，但这并不一定是放到最后一本书的最优解。要想找到第 i 本书的最优解，需要从后往前依次判断，如果第 <code>[j, i]</code> 本书都放在同一层（前提是厚度不超过）, 那么总高度会不会变小。这样判断直到 <code>i</code> 所在的这一层的厚度到顶了，将最优解的高度存入 <code>dp[i]</code>，表示我放到 <code>i</code> 这本书的时候的高度最优解。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minHeightShelves</span><span class="params">(<span class="type">int</span>[][] books, <span class="type">int</span> shelfWidth)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> books.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1000</span>*<span class="number">1000</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i]表示在放到第i本书的时候的最优解</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w + books[j-<span class="number">1</span>][<span class="number">0</span>] &lt;= shelfWidth) &#123;   <span class="comment">// 表示第j本书放入新的一层</span></span><br><span class="line">                    w += books[j-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                    h = Math.max(h, books[j-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j-<span class="number">1</span>]+h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最佳观光组合">1014、最佳观光组合⭐</h1><h4 id="动态规划-1">动态规划</h4><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626752.png" alt="image-20221021185104168" /><figcaption aria-hidden="true">image-20221021185104168</figcaption></figure><p>数学的正则运算。</p><p><code>values[i] + values[j] + i - j == (values[i] + i) +  (values[j] - j)</code></p><p>完整代码，思路很清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScoreSightseeingPair</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxi</span> <span class="operator">=</span> values[<span class="number">0</span>];    <span class="comment">//记录最大的values[i]+i</span></span><br><span class="line">        <span class="comment">//找最大的values[j]-j</span></span><br><span class="line">        <span class="keyword">for</span>  (<span class="type">int</span> j=<span class="number">1</span>;j&lt;values.length;j++) &#123;</span><br><span class="line">            <span class="comment">//以当前节点为j，将它和前面的最大的i对应的值相加，和原有的res比较</span></span><br><span class="line">            res = Math.max(res, maxi+values[j]-j);</span><br><span class="line">            <span class="comment">//判断如果当前节点不是j而是i，和原本的maxi进行比较更新maxi</span></span><br><span class="line">            maxi = Math.max(maxi, values[j]+j);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="负二进制转换">1017. 负二进制转换⭐</h1><blockquote><p>考察： #位运算</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304060949672.png" /></p><p>思路：构建 bits 数组，bits[i] 表示需要 <span class="math inline">\((-2)^i\)</span> 的次数。但是此时只需要对每个元素进行计数，有以下的规律。</p><ul><li>对于 <span class="math inline">\(2^i\)</span>，如果 i 为偶数时，此时 <span class="math inline">\(2^i = (-2)^i\)</span>；</li><li>对于 <span class="math inline">\(2^i\)</span>，如果 i 为奇数时，此时 <span class="math inline">\(2^i = (-2)^{i+1} + (-2)^i\)</span></li><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;     <span class="comment">// 如果i是偶数</span></span><br><span class="line">bits[i] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;      <span class="comment">// 如果i是奇数</span></span><br><span class="line">bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">bits[i] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对已经构造好的 bits 数组处理，要求每个值只能是 0 或者-1。</p><p>如果 h[i]&gt;=2： - 如果 h[i+1]&gt;0，那么 h[i]的两份可以抵消 h[i+1]的一份（因为他们是异号）。 - 否则，h[i]的两份等价于 h[i+1]的一份和 h[i+2]的一份的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span> &amp;&amp; bits[i+<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">bits[i] -= <span class="number">2</span>;</span><br><span class="line">bits[i+<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">bits[i] -= <span class="number">2</span>;</span><br><span class="line">bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">bits[i+<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解：<a href="https://leetcode.cn/problems/convert-to-base-2/solutions/1898036/daydayuppp-jian-dan-de-zhi-guan-mo-ni-by-g2y2/">负二进制转换 题解</a></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">baseNeg2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] bits = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    bits[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                    bits[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span> &amp;&amp; bits[i+<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                bits[i] -= <span class="number">2</span>;</span><br><span class="line">                bits[i+<span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (bits[i]&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">                bits[i] -= <span class="number">2</span>;</span><br><span class="line">                bits[i+<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                bits[i+<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isstart</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">31</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bits[i]!=<span class="number">0</span>) &#123;</span><br><span class="line">                isstart = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isstart) &#123;</span><br><span class="line">                sb.append(String.valueOf(bits[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中的下一个更大节点">1019. 链表中的下一个更大节点</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304102203153.png" /></p><p>中等题。思路：将链表先变成数组，然后利用栈的原理找到第一个大于的元素，存入栈的是元素在数组的下标。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">t</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t!=<span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            t = t.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        t = head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (t!=<span class="literal">null</span>) &#123;</span><br><span class="line">            nums[i] = t.val;</span><br><span class="line">            t = t.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[dq.peekLast()]&lt;nums[i]) &#123;</span><br><span class="line">                    res[dq.pollLast()] = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (dq.size()!=<span class="number">0</span>) &#123;</span><br><span class="line">            res[dq.pollFirst()] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="驼峰式匹配">1023. 驼峰式匹配</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304140819106.png" /></p><p>中等题，但是很简单，直接对应遍历即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">camelMatch</span><span class="params">(String[] queries, String pattern)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">char</span>[] pc = pattern.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">pl</span> <span class="operator">=</span> pc.length;</span><br><span class="line">        ArrayList&lt;Boolean&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Boolean&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> queries[i];</span><br><span class="line">            <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;sc.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k&lt;pl &amp;&amp; sc[j]==pc[k]) &#123;</span><br><span class="line">                    k++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sc[j]&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; sc[j]&lt;=<span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                        isTrue = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isTrue &amp;&amp; k==pl) &#123;</span><br><span class="line">                res.add(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="节点与其祖先之间的最大差值">1026. 节点与其祖先之间的最大差值</h1><blockquote><p>考察： #树 #前序遍历</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304181524869.png" /></p><p>中等题，需要认真审题。要注意得是：A、B 必须在一条枝上，但不一定是相邻得。这里使用得前序遍历。</p><p>前序遍历核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode r)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (r==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(r.val);</span><br><span class="line">find(r.left);</span><br><span class="line">find(r.right);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAncestorDiff</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root,-<span class="number">1</span>,<span class="number">100001</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode r, <span class="type">int</span> max, <span class="type">int</span> min)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> r.val;</span><br><span class="line">        max = Math.max(max, d);</span><br><span class="line">        min = Math.min(min, d);</span><br><span class="line">        res = Math.max(res, Math.abs(max-min));</span><br><span class="line">        dfs(r.left, max, min);</span><br><span class="line">        dfs(r.right, max, min);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长等差数列">1027. 最长等差数列⭐⭐</h1><blockquote><p>考察： #动态规划 #递归</p></blockquote><p>题解：<a href="https://leetcode.cn/problems/longest-arithmetic-subsequence/solutions/2239191/ji-yi-hua-sou-suo-di-tui-chang-shu-you-h-czvx/">题解</a></p><h2 id="方法一递归-1">方法一、递归</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221639277.png" /></p><p>思路在题解，代码有注释。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Integer&gt;[] maxLen;    <span class="comment">// 这是一个hash数组，长度为n。每个元素为一个hash表，key为方差，value为在这个方差下的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        maxLen = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer,Integer&gt; <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// 之前已经计算过了以i下标元素为结尾的hash表了，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (maxLen[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> maxLen[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        maxLen[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充以nums[i]为结尾的hash表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i] - nums[j];    <span class="comment">// 这两个数之间的方差</span></span><br><span class="line">            <span class="keyword">if</span> (!maxLen[i].containsKey(d)) &#123;    <span class="comment">// 如果这个方差没有计算过就放进去，如果已经计算过说明在j~i之间出现过一样的数字，这里就不要考虑了</span></span><br><span class="line">                maxLen[i].put(d, dfs(j).getOrDefault(d,<span class="number">1</span>)+<span class="number">1</span>);    <span class="comment">// 如果以j为结尾的方差为d的长度没有，那么j位置算1个，i位置算一个，一共2个</span></span><br><span class="line">                res = Math.max(res, maxLen[i].get(d));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxLen[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-2">优化</h3><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221640989.png" /></p><p>将代码合并在一个函数内。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt;[] maxLen = <span class="keyword">new</span> <span class="title class_">HashMap</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;    <span class="comment">// 从0开始，方便初始化</span></span><br><span class="line">            maxLen[i] = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i] - nums[j];    <span class="comment">// 这两个数之间的方差</span></span><br><span class="line">                <span class="keyword">if</span> (!maxLen[i].containsKey(d)) &#123;    <span class="comment">// 如果这个方差没有计算过就放进去，如果已经计算过说明在j~i之间出现过一样的数字，这里就不要考虑了</span></span><br><span class="line">                    maxLen[i].put(d, maxLen[j].getOrDefault(d,<span class="number">1</span>)+<span class="number">1</span>);    <span class="comment">// 如果以j为结尾的方差为d的长度没有，那么j位置算1个，i位置算一个，一共2个</span></span><br><span class="line">                    res = Math.max(res, maxLen[i].get(d));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划-3">方法二、动态规划</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304221641848.png" /></p><p>关键是区间映射。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestArithSeqLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1001</span>];      <span class="comment">// nums[i]的范围为[0,500]，所以d最小为-500，最大为500。把[-500,500]映射到[0,1000]中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;   </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[i] - nums[j] + <span class="number">500</span>;    <span class="comment">// 区间映射到[0,1000]</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][d]==<span class="number">0</span>) &#123;   </span><br><span class="line">                    dp[i][d] = dp[j][d] + <span class="number">1</span>;    <span class="comment">// 注意这里是不包括i位置自己的</span></span><br><span class="line">                    res = Math.max(res, dp[i][d]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两个非重叠子数组的最大和">1031. 两个非重叠子数组的最大和</h1><blockquote><p>考察： #滑动窗口</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304260928945.png" /></p><p>中等题，但是比较简单，注意审题。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumTwoNoOverlap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> firstLen, <span class="type">int</span> secondLen)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">// pre[i]表示i之前的元素再firstlen长度的总和</span></span><br><span class="line">        <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[n];      <span class="comment">// end[i]表示i及其之后的firstlen长度的总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (firstLen+secondLen&gt;n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0 1 2 3 4 5   len=2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;firstLen-<span class="number">1</span>) &#123;</span><br><span class="line">                pre[i] = <span class="number">0</span>;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i == firstLen-<span class="number">1</span>) &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                pre[i] = sum;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[i];</span><br><span class="line">                sum -= nums[i-firstLen];</span><br><span class="line">                pre[i] = Math.max(pre[i-<span class="number">1</span>], sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0 1 2 3 4 5   len=2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&gt;n-firstLen) &#123;</span><br><span class="line">                end[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i==n-firstLen) &#123;</span><br><span class="line">                end[i] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum -= nums[i+firstLen];</span><br><span class="line">                end[i] = Math.max(end[i+<span class="number">1</span>],sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i&lt;secondLen-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-secondLen&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                    sum -= nums[i-secondLen];</span><br><span class="line">                    res = Math.max(res, sum + pre[i-secondLen]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n) &#123;</span><br><span class="line">                    res = Math.max(res, sum + end[i+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;      // 表示i之前的 和 i及其之后的</span></span><br><span class="line">        <span class="comment">//     System.out.print(pre[i]);</span></span><br><span class="line">        <span class="comment">//     System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     System.out.println(end[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符流">1032. 字符流⭐</h1><blockquote><p>考察： #前缀树</p><p>基础：<a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303241046436.png" /></p><p>典型的<strong>前缀树</strong>题，写这一题前一定要先写 208 题。本题实际上就是前缀树的反思路，是以当前输入的字符为结尾，往前找。而存储 word 的时候是将每个 word 倒着存。</p><p>优化：注意条件 <code>1 &lt;= words[i].length &lt;= 200</code>，所以在遍历时可以设置提前退出条件，否则会超时。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    TreeNode[] children;</span><br><span class="line">    <span class="type">boolean</span> isStart;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">26</span>];</span><br><span class="line">        isStart = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StreamChecker</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();    </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StreamChecker</span><span class="params">(String[] words)</span> &#123;    <span class="comment">//后缀树</span></span><br><span class="line">        TreeNode r;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            r = root;</span><br><span class="line">            <span class="type">char</span>[] sc = word.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=word.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> sc[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (r.children[idx]==<span class="literal">null</span>) &#123;</span><br><span class="line">                    r.children[idx] = <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                r = r.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">            r.isStart = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">query</span><span class="params">(<span class="type">char</span> letter)</span> &#123;</span><br><span class="line">        sb.append(letter);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">r</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=sb.length()-<span class="number">1</span>,j=<span class="number">0</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;<span class="number">201</span>; i--,j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> sb.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.children[idx]==<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = r.children[idx];</span><br><span class="line">                <span class="keyword">if</span> (r.isStart==<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StreamChecker obj = new StreamChecker(words);</span></span><br><span class="line"><span class="comment"> * boolean param_1 = obj.query(letter);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="移动石子直到连续">1033. 移动石子直到连续👍</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301630827.png" /></p><p>思路：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304301629603.png" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numMovesStones(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">        Arrays.sort(map);</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">2</span>]-map[<span class="number">0</span>]==<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[<span class="number">1</span>]-map[<span class="number">0</span>]&lt;=<span class="number">2</span> || map[<span class="number">2</span>]-map[<span class="number">1</span>]&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, map[<span class="number">2</span>]-map[<span class="number">0</span>]-<span class="number">2</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, map[<span class="number">2</span>]-map[<span class="number">0</span>]-<span class="number">2</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多边形三角剖分的最低得分">1039. 多边形三角剖分的最低得分⭐</h1><blockquote><p>考察： #动态规划 #记忆搜索</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304021115756.png" /></p><p>中等题，有难度，但是只要思路对了那就好算。</p><p>动态规划（递推）的思路。dp[i][j]表示从第 i 节点到第 j 节点的最短乘积和。转换为子问题，遍历 i 和 j 中的点 k，k 将整个图形分割为三部分，分别是 dp[i][k]、dp[k][j]、以 ijk 为顶点的三角形。按照这样的思路配合利用数组记录 dp[i][j]，可以快速求出 dp[0][n-1]。值得注意的是：如果 <code>k == i + 1</code>，那么直接返回 0，如果 <code>j == i + 2</code> 直接表示 i 到 j 就是一个三角形，直接返回他们的乘积。return 之前都别忘了保存，搜索之前别忘了记忆化查找。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] dp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] values;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minScoreTriangulation</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="built_in">this</span>.values = values;</span><br><span class="line">        <span class="built_in">this</span>.dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">return</span> find(<span class="number">0</span>,n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[start][end]!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            dp[start][end] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - start == <span class="number">2</span>) &#123;</span><br><span class="line">            dp[start][end] = values[start]*values[start+<span class="number">1</span>]*values[end];</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start+<span class="number">1</span>; i &lt;= end-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            min = Math.min(min, find(start,i) + find(i,end) + values[start]*values[i]*values[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][end] = min;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="移动石子直到连续-ii">1040. 移动石子直到连续 II⭐</h1><blockquote><p>考察： #滑动窗口 #双指针</p></blockquote><blockquote><p>基础：1033</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304070918507.png" /></p><p>题解：<a href="https://leetcode.cn/problems/moving-stones-until-consecutive-ii/solutions/2212638/tu-jie-xia-tiao-qi-pythonjavacgo-by-endl-r1eb/">题解</a></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] numMovesStonesII(<span class="type">int</span>[] stones) &#123;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">e1</span> <span class="operator">=</span> stones[n-<span class="number">2</span>]-stones[<span class="number">0</span>]-<span class="number">1</span>-(n-<span class="number">3</span>); </span><br><span class="line">        <span class="type">int</span> <span class="variable">e2</span> <span class="operator">=</span> stones[n-<span class="number">1</span>]-stones[<span class="number">1</span>]-<span class="number">1</span>-(n-<span class="number">3</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">MaxMove</span> <span class="operator">=</span> Math.max(e1,e2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">MinMove</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (e1==<span class="number">0</span> || e2==<span class="number">0</span>) &#123;     <span class="comment">// 需要端点一个作为跳板移动过来，再将另一个端点跳过去</span></span><br><span class="line">            MinMove = Math.min(<span class="number">2</span>, MaxMove);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">MaxCount</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">// 定义左端点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; n; right++) &#123;    <span class="comment">// right点一定位于一个石子上</span></span><br><span class="line">                <span class="comment">// 目标是找到一个窗口，它的起点和终点都一定是有石子的</span></span><br><span class="line">                <span class="keyword">while</span> (stones[right] - stones[left] + <span class="number">1</span> &gt; n) &#123;    <span class="comment">// 窗口大小大于n（石子的数量），这能让窗口一直维持在n的长度以内</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                MaxCount = Math.max(MaxCount, right-left+<span class="number">1</span>);   <span class="comment">// right-left+1表示这个窗口内已经放了多少的石子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时MaxCount为最大，则空位有n-MaxCount</span></span><br><span class="line">            MinMove = n - MaxCount;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;MinMove,MaxMove&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="困于环中的机器人">1041. 困于环中的机器人</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304110918373.png" /></p><p>简单的中等题，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isRobotBounded</span><span class="params">(String instructions)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ic = instructions.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] loc = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">face</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;ic.length;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ic[i]==<span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">                    loc[face]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ic[i]==<span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">                    face = (face+<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ic[i]==<span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">                    face = (face+<span class="number">4</span>-<span class="number">1</span>)%<span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (loc[<span class="number">0</span>]==loc[<span class="number">2</span>] &amp;&amp; loc[<span class="number">1</span>]==loc[<span class="number">3</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不邻接植花">1042. 不邻接植花⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304151324483.png" /></p><p>中等题。题解：<a href="https://leetcode.cn/problems/flower-planting-with-no-adjacent/solutions/2226271/bu-lin-jie-zhi-hua-by-leetcode-solution-bv74/">题解</a>。思路如下：</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304151325213.png" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] gardenNoAdj(<span class="type">int</span> n, <span class="type">int</span>[][] paths) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] al = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            al[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;paths.length;i++) &#123;</span><br><span class="line">            al[paths[i][<span class="number">0</span>]-<span class="number">1</span>].add(paths[i][<span class="number">1</span>]-<span class="number">1</span>);</span><br><span class="line">            al[paths[i][<span class="number">1</span>]-<span class="number">1</span>].add(paths[i][<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] color = <span class="keyword">new</span> <span class="title class_">int</span>[n];      <span class="comment">// 表示n个花园的颜色，初始化时为0表示没有颜色</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">boolean</span>[] tc = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">5</span>];     <span class="comment">// 表示4中颜色是否可以选，0表示初始化，默认为false，表示都能选</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 相邻的花园的颜色都设置为true，表示不可选择了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k : al[i]) &#123;</span><br><span class="line">                tc[color[k]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!tc[j]) &#123;    <span class="comment">// 表示颜色没有选</span></span><br><span class="line">                    color[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分隔数组以得到最大和">1043. 分隔数组以得到最大和⭐</h1><blockquote><p>考察： #递归 #动态规划</p></blockquote><p>题解：<a href="https://leetcode.cn/problems/partition-array-for-maximum-sum/solutions/2234242/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-rq5i/?languageTags=java">题解</a></p><h2 id="方法一递归记忆化搜索">方法一、递归+记忆化搜索⭐</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191002832.png" /></p><p>中等题。思路：构造一个函数 dfs (i)，表示以位置 i 为结尾的前面的结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] memo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">        <span class="built_in">this</span>.k = k;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(memo,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;    <span class="comment">// 从右往左进行</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">// 表示以[0,i]这段的最大结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span> &amp;&amp; j&gt;=i-k+<span class="number">1</span>; j--) &#123;</span><br><span class="line">            max = Math.max(max, arr[j]);    <span class="comment">// 表示在[j,i]这段中，最大值为max，长度为i-j+1</span></span><br><span class="line">            res = Math.max(res, dfs(j-<span class="number">1</span>) + max*(i-j+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        memo[i] = res;</span><br><span class="line">        <span class="keyword">return</span> memo[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划-4">方法二、动态规划</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191113666.png" /></p><p>从左向右正向判断，每次直接计算出以 i 结尾的结果。最终结果就是 <code>dp[n]</code>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">// dp[i]存的是以i-1结尾的前面段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span> &amp;&amp; j&gt;=i-k+<span class="number">1</span>; j--) &#123;</span><br><span class="line">                max = Math.max(max, arr[j]);</span><br><span class="line">                dp[i+<span class="number">1</span>] = Math.max(dp[i+<span class="number">1</span>], dp[j] + max*(i-j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化空间">优化空间</h3><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304191119429.png" /></p><p>我们可以发现在动态规划中，计算 i 值只需要 <code>[i-k+1, i]</code> 区间的结果，长度为 k。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumAfterPartitioning</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k+<span class="number">1</span>];     <span class="comment">// dp[i]存的是以i-1结尾的前面段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=<span class="number">0</span> &amp;&amp; j&gt;=i-k+<span class="number">1</span>; j--) &#123;</span><br><span class="line">                max = Math.max(max, arr[j]);</span><br><span class="line">                <span class="comment">// 注意在循环结束前，f[(i+1)%k] 是需要用到的，不能提前覆盖</span></span><br><span class="line">                res = Math.max(res, dp[j%k] + max*(i-j+<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[(i+<span class="number">1</span>)%k] = res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n%k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长字符串链">1048. 最长字符串链</h1><blockquote><p>考察： #动态规划 #双指针</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304270921812.png" /></p><p>中等题。比较简单，只需要先将数组按照长度排序，然后遍历每个数组，将它与比它长度少 1 的字符串比较，比较时用一个指针即可，当 i 指针是两个字符串不同的位置，那么长字符串 i 之后的元素一定是与短字符串 i 及其之后的元素是相等的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestStrChain</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        Arrays.sort(words, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> a.length()-b.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (words[j].length() &lt; words[i].length()-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (words[j].length() == words[i].length()-<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isTrue(words[i],words[j])==<span class="number">0</span>) &#123;    <span class="comment">// 前面长，后面短</span></span><br><span class="line">                        dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">isTrue</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ac = a.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] bc = b.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;b.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ac[i]!=bc[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==b.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i位置是a新加入的</span></span><br><span class="line">        <span class="keyword">return</span> a.substring(i+<span class="number">1</span>).compareTo(b.substring(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="交换一次的先前排列">1053. 交换一次的先前排列</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304031000331.png" /></p><p>中等题，实际上就是找规律。本题实际上找的是比当前数字组合更小的最大数字组合，但是只能交换一组数。通过规律定义如下步骤：</p><ol type="1"><li>从右往左找降序（包括相等），找到第一个不是降序的数字位置，记作 loc1。<ul><li>如果 loc1 还是初始值（定义为-1），表示整个数字组合都是升序，所以直接返回 arr 即可。</li><li>如果 loc1 不是初始值，那么继续下面步骤。</li></ul></li><li>在 loc1 后面找比它小一点点的数，这里不要求数一定更靠左还是靠右，只要找到比它小的最大数的第一次出现位置，记作 loc2。</li><li>交换 loc1 的数字和 loc2 的数字。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] prevPermOpt1(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">loc1</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                loc1 = i;       <span class="comment">// 这个loc1后面一定有比它更小的，如果都比它大，那它还是在升序里</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (loc1 == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc2</span> <span class="operator">=</span> loc1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=loc1+<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i]&lt;arr[loc1] &amp;&amp; arr[i]&gt;arr[loc2]) &#123;</span><br><span class="line">                loc2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[loc1];</span><br><span class="line">        arr[loc1] = arr[loc2];</span><br><span class="line">        arr[loc2] = temp;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最短公共超序列">1092. 最短公共超序列⭐⭐</h1><blockquote><p>考察： #递归</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303281018733.png" /></p><p>困难题。题解：<a href="https://leetcode.cn/problems/shortest-common-supersequence/solutions/2194615/cong-di-gui-dao-di-tui-jiao-ni-yi-bu-bu-auy8z/">题解</a></p><p>思路：利用 dfs 检索以 s1 的 i 下标结尾和 s2 的 j 下标结尾的结果的最短长度。利用 FindStr 按照 dfs 正确的顺序进行查找。</p><p>最终代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] map;</span><br><span class="line">    <span class="keyword">public</span> String s1, s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">shortestCommonSupersequence</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        s1 = str1;</span><br><span class="line">        s2 = str2;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">int</span>[s1.length()][s2.length()];</span><br><span class="line">        <span class="keyword">return</span> FindStr(s1.length()-<span class="number">1</span>,s2.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;     <span class="comment">// 表示在s1[0,i]和s2[0,j]的情况下，返回结果的最短长度</span></span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map[i][j]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            map[i][j] = dfs(i-<span class="number">1</span>,j-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> map[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map[i][j] = Math.min(dfs(i-<span class="number">1</span>,j), dfs(i,j-<span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">FindStr</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.substring(<span class="number">0</span>,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FindStr(i-<span class="number">1</span>,j-<span class="number">1</span>) + s1.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfs(i,j) == dfs(i-<span class="number">1</span>,j) + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> FindStr(i-<span class="number">1</span>,j) + s1.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FindStr(i,j-<span class="number">1</span>) + s2.charAt(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="花括号展开-ii">1096. 花括号展开 II⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303071725462.png" /></p><p>困难题，实际上就是找规律题。通过阅读题目，发现如下的规律：</p><p>如果当前字符为 <code>&#123;</code> ： - 如果前面有字母或者 <code>&#125;</code>，则先入栈 <code>*</code>，再入栈 <code>&#123;</code>。 - 否则直接入栈 <code>&#123;</code>。</p><p>如果当前字符为字母：找到以此字母为首的连续字母串，将这个串存入 Treeset 中。</p><p>如果当前字符为 <code>,</code> : - 如果栈顶为 <code>*</code>，为了保证乘法优先级更高，先取 Treeset 中的两个和此 <code>*</code> 进行处理……直到栈顶不是 <code>*</code>，再将 <code>+</code> 入栈。 - 否则直接将 <code>+</code> 入栈。</p><p>如果当前字符为 <code>&#125;</code> ：取栈顶运算符和两个 set 中的元素进行处理，直到遇到 <code>&#123;</code>，直接将 <code>&#123;</code> 出栈。</p><p>在遍历数组之后，如果栈中还有运算符，则依次出栈并处理。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303071735376.png" /></p><blockquote><p>这里注意运用的 TreeSet 数据结构，不能使用 HashSet，因为答案是有序的，只能使用 TreeSet 按照其默认顺序即可。</p><p>在操作时也要注意两个操作数的前后顺序，如果顺序相反则结果也会出错。</p></blockquote><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Deque&lt;Character&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">    List&lt;TreeSet&lt;String&gt;&gt; lss = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;TreeSet&lt;String&gt;&gt;();    <span class="comment">// set()避免重复</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Option</span><span class="params">(<span class="type">char</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            TreeSet&lt;String&gt; set1 = lss.get(lss.size()-<span class="number">1</span>);</span><br><span class="line">            TreeSet&lt;String&gt; set2 = lss.get(lss.size()-<span class="number">2</span>);</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.add(set1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            List&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(lss.get(lss.size()-<span class="number">2</span>));</span><br><span class="line">            List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(lss.get(lss.size()-<span class="number">1</span>));</span><br><span class="line">            TreeSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;list1.size();j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;list2.size();k++) &#123;</span><br><span class="line">                    set.add((String)(list1.get(j)+list2.get(k)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.remove(lss.size()-<span class="number">1</span>);</span><br><span class="line">            lss.add(set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">braceExpansionII</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ec= expression.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;ec.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ec[i]==<span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; (ec[i-<span class="number">1</span>]==<span class="string">&#x27;&#125;&#x27;</span> || (ec[i-<span class="number">1</span>]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ec[i-<span class="number">1</span>]&lt;=<span class="string">&#x27;z&#x27;</span>))) &#123;</span><br><span class="line">                    dq.addLast(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dq.addLast(<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ec[i]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ec[i]&lt;=<span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                TreeSet&lt;String&gt; ss = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; ec[i-<span class="number">1</span>]==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                    dq.addLast(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (p&lt;ec.length &amp;&amp; (ec[p]&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ec[p]&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                    p++;</span><br><span class="line">                &#125;</span><br><span class="line">                ss.add(expression.substring(i,p));</span><br><span class="line">                i = p - <span class="number">1</span>;</span><br><span class="line">                lss.add(ss);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ec[i]==<span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; dq.peekLast()==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                    Option(t);</span><br><span class="line">                &#125;</span><br><span class="line">                dq.addLast(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ec[i]==<span class="string">&#x27;&#125;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">                    <span class="keyword">if</span> (t == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Option(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Option(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(lss.get(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="表现良好的最长时间段">1124. 表现良好的最长时间段</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302140906059.png" /></p><p>中等题。</p><p>思路：找子串最大长度，表示满足一个子串，使得其左边和右边要么是边界、要么是不劳累，且其内部劳累大于不劳累。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="comment">// 最大长度，表示满足一个子串，使得其左边和右边要么是边界，要么是不劳累，且其内部劳累大于不劳累</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> hours.length;</span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);     <span class="comment">//下标，劳累，不劳累</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, nl = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hours[i]&gt;<span class="number">8</span>) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nl++;</span><br><span class="line">                al.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,l,nl&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        al.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n,l,nl&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> left=<span class="number">0</span>; left&lt;al.size(); left++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(al.get(left)[2]);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> right=left+<span class="number">1</span>; right&lt;al.size(); right++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> al.get(right)[<span class="number">1</span>]-al.get(left)[<span class="number">1</span>] , nt = al.get(right)[<span class="number">2</span>]-al.get(left)[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span> (al.get(right)[<span class="number">0</span>]&gt;=<span class="number">0</span> &amp;&amp; al.get(right)[<span class="number">0</span>]&lt;n) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (hours[al.get(right)[<span class="number">0</span>]]&gt;<span class="number">8</span>) &#123;</span><br><span class="line">                        t--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        nt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (t &gt; nt) &#123;</span><br><span class="line">                    <span class="comment">// System.out.print(left);</span></span><br><span class="line">                    <span class="comment">// System.out.print(&quot; &quot;);</span></span><br><span class="line">                    <span class="comment">// System.out.println(right);</span></span><br><span class="line">                    max = Math.max(max,al.get(right)[<span class="number">0</span>]-al.get(left)[<span class="number">0</span>]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小的必要团队">1125. 最小的必要团队⭐</h1><blockquote><p>考察： #背包问题</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304081833720.png" /></p><p>题解：<a href="https://leetcode.cn/problems/smallest-sufficient-team/solutions/2214387/zhuang-ya-0-1-bei-bao-cha-biao-fa-vs-shu-qode/">题解</a></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> all;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] skill;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestSufficientTeam(String[] req_skills, List&lt;List&lt;String&gt;&gt; people) &#123;</span><br><span class="line">        HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> req_skills.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            hash.put(req_skills[i],i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> people.size();</span><br><span class="line">        skill = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;people.get(i).size();j++) &#123;</span><br><span class="line">                skill[i] = skill[i] | <span class="number">1</span>&lt;&lt;hash.get(people.get(i).get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">long</span>[n][<span class="number">1</span>&lt;&lt;m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            Arrays.fill(memo[i],-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        all = (<span class="number">1L</span> &lt;&lt; n) - <span class="number">1</span>;     <span class="comment">// 表示所有人员都参与</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> dfs(n-<span class="number">1</span>, (<span class="number">1</span>&lt;&lt;m)-<span class="number">1</span>);     <span class="comment">// n-1 表示最后一个人，(1&lt;&lt;m)-1表示最终状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// res是结果的人的集合，需要将每一位提取出来</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[Long.bitCount(res)];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((res &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                ans[j] = i;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs(i,j) 定义成从前 i 个人中选择一些人，他们的技能并集为j， 所选择的最少人的集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">//全装满了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> all;     <span class="comment">// 没办法装满背包，返回全集</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;    <span class="comment">// 记忆化搜索</span></span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">long</span> <span class="variable">res1</span> <span class="operator">=</span> dfs(i-<span class="number">1</span>,j);    <span class="comment">//如果不选当前people</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">res2</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; i) | dfs(i-<span class="number">1</span>, j &amp; ~skill[i]);    <span class="comment">// ~skill[i]表示取反，即i这个人拥有的能力为0，没有的为1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Long.bitCount(res1) &lt; Long.bitCount(res2)) &#123;</span><br><span class="line">            memo[i][j] = res1;</span><br><span class="line">            <span class="keyword">return</span> res1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[i][j] = res2;</span><br><span class="line">            <span class="keyword">return</span> res2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第-n-个斐波那契数">1137、第 N 个斐波那契数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626753.png" alt="image-20221015214614019" /><figcaption aria-hidden="true">image-20221015214614019</figcaption></figure><p>简单哦~</p><h1 id="字母板上的路径">1138. 字母板上的路径</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302121135849.png" /></p><p>思路：构建一个 hash 表，存储每个字母的位置。在移动时一定要注意‘z’的判断，如果 <code>if (start[0]+1==5 &amp;&amp; start[1]&gt;=1)</code> 成立，则不能向下移动。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alphabetBoardPath</span><span class="params">(String target)</span> &#123;</span><br><span class="line">        HashMap&lt;Character,<span class="type">int</span>[]&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            hash.put((<span class="type">char</span>)(<span class="string">&#x27;a&#x27;</span>+i),<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i/<span class="number">5</span>,i%<span class="number">5</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] tc = target.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;tc.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] end = hash.get(tc[i]);</span><br><span class="line">            <span class="keyword">while</span> (start[<span class="number">0</span>]!=end[<span class="number">0</span>] || start[<span class="number">1</span>]!=end[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">0</span>]&gt;end[<span class="number">0</span>]) &#123;    <span class="comment">//需要上移</span></span><br><span class="line">                    start[<span class="number">0</span>]--;</span><br><span class="line">                    sb.append(<span class="string">&quot;U&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">0</span>]&lt;end[<span class="number">0</span>]) &#123;    <span class="comment">//需要下移</span></span><br><span class="line">                    <span class="keyword">if</span> (start[<span class="number">0</span>]+<span class="number">1</span>==<span class="number">5</span> &amp;&amp; start[<span class="number">1</span>]&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        start[<span class="number">0</span>]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(<span class="string">&quot;D&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">1</span>]&gt;end[<span class="number">1</span>]) &#123;    <span class="comment">//需要左移</span></span><br><span class="line">                    start[<span class="number">1</span>]--;</span><br><span class="line">                    sb.append(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (start[<span class="number">1</span>]&lt;end[<span class="number">1</span>]) &#123;    <span class="comment">//需要右移</span></span><br><span class="line">                    start[<span class="number">1</span>]++;</span><br><span class="line">                    sb.append(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大的以-1-为边界的正方形">1139. 最大的以 1 为边界的正方形</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302171115497.png" /></p><p>中等题，思路比较简单。构造两个二维数据，分别记录以当前为止 (i, j) 的上方连续 1 和左方连续 1 的个数（都包括自己），然后取其中较小值，判断如果以这个值作为边的长度，另外两个顶点是否能满足条件，如果不满足则缩小边的长度，继续判断。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length , m = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] u1 = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];    <span class="comment">//记录包括其上面的连续1的个数</span></span><br><span class="line">        <span class="type">int</span>[][] l1 = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];    <span class="comment">//记录包括其左边的连续1的个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//对第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            l1[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>]==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    u1[i][<span class="number">0</span>] = u1[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    u1[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对第一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            u1[<span class="number">0</span>][i] = grid[<span class="number">0</span>][i];</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][i]==<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    l1[<span class="number">0</span>][i] = l1[<span class="number">0</span>][i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    l1[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                res = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;m;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    u1[i][j] = u1[i-<span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    l1[i][j] = l1[i][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> <span class="variable">edge</span> <span class="operator">=</span> Math.min(u1[i][j],l1[i][j]);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> e=edge;e&gt;<span class="number">0</span>;e--) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (u1[i][j-e+<span class="number">1</span>]&gt;=e &amp;&amp; l1[i-e+<span class="number">1</span>][j]&gt;=e) &#123;</span><br><span class="line"></span><br><span class="line">                            res = Math.max(res,e);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res*res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递减元素使数组呈锯齿状">1144. 递减元素使数组呈锯齿状</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302270900017.png" /></p><p>中等题，但是思路比较简单。只需要判断<strong>奇数下标比偶数下标的小</strong>和<strong>偶数下标比奇数下标小</strong>这两种情况下，需要的最小操作的次数。</p><p>小优化：当判断<strong>奇数下标比偶数下标的小</strong>的情况时，只需要以奇数位置为判断点，如果它比两边大就缩小，如果比两边小则继续判断下一个奇数下标。当判断<strong>偶数下标比奇数下标小</strong>的情况时，只需要判断偶数位置，如果比两边大则缩小，如果比两边小则继续判断下一个偶数下标。</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movesToMakeZigzag</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先判断奇数下标小，只要判断奇数位置元素即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; k&gt;=nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                res += k - nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n &amp;&amp; k&gt;=nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                res += k - nums[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先判断偶数下标小，只要判断偶数位置元素即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i=i+<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i-<span class="number">1</span>&gt;=<span class="number">0</span> &amp;&amp; k&gt;=nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                total += k - nums[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;n &amp;&amp; k&gt;=nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                total += k - nums[i+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                k = nums[i+<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(res,total);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树着色游戏">1145. 二叉树着色游戏</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303121637065.png" /></p><p>题解：<a href="https://leetcode.cn/problems/binary-tree-coloring-game/solutions/2089813/mei-you-si-lu-yi-zhang-tu-miao-dong-pyth-btav/">没有思路？一张图秒懂！（Python/Java/C++/Go） - 二叉树着色游戏 - 力扣（LeetCode）</a></p><p>看完题解，可能还有点懵。简单说就是以 x 为中心，可以分为三部分，分别是其左子树、右子树、还有剩下的部分。要如果 y 在第一步先占领了 x 四周的某一个部分，那么这一部分的所有元素都是 y 所有了。如果这一部分的元素个数比其他部分的元素个数之和还多，那么 y 是<strong>稳赢</strong>！</p><p><strong>所以正确的步骤应该是：</strong> 先利用 dfs 找到 x 的节点 node，再分别用 dfs 算出其左子树的元素个数、右子树的元素个数、其他部分的元素个数。选其中元素个数最多的部分作为 y 要占领的，如果这一部分的元素比其他部分的元素个数和都多，那么稳赢。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findn1</span><span class="params">(TreeNode root, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (findn1(root.left,x)!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> findn1(root.left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findn1(root.right,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left) + dfs(root.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">btreeGameWinningMove</span><span class="params">(TreeNode root, <span class="type">int</span> n, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        root = findn1(root,x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ln</span> <span class="operator">=</span> dfs(root.left); </span><br><span class="line">        <span class="type">int</span> <span class="variable">rn</span> <span class="operator">=</span> dfs(root.right); </span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> Math.max(ln, Math.max(rn, n - ln - rn - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (n2 &gt; n - n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="段式回文">1147. 段式回文</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304120859713.png" /></p><p>困难题。因为找分的最多的 k 的数量，所以直接双指针+贪心即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// aba    aba</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestDecomposition</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] tc = text.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tc.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;    <span class="comment">// 窗口大小</span></span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> end - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;=j) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (;i&lt;start+l;i++,j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tc[i]!=tc[j]) &#123;</span><br><span class="line">                    isFind = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                res += <span class="number">2</span>;</span><br><span class="line">                start = start + l;</span><br><span class="line">                end = end - l;</span><br><span class="line">                l = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按字典序排在最后的子串">1163. 按字典序排在最后的子串⭐⭐</h1><blockquote><p>考察： #双指针</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304241459815.png" /></p><p>困难题，使用暴力会超时。很抽象的解法。题解：<a href="https://leetcode.cn/problems/last-substring-in-lexicographical-order/solutions/2242562/python3javacgotypescript-yi-ti-yi-jie-sh-3amj/?languageTags=java">题解</a></p><p><strong>思路：</strong> 定义两个指针 i，j。i 表示最终结果的起始位置，j 表示开始判断的起始位置，定义 k 表示判断的偏移。每次判断 <code>sc[i+k]</code> 和 <code>sc[j+k]</code> ： - 如果 <code>sc[i+k]==sc[j+k]</code>，则 <code>k++</code>，这表示 <code>[i, i+k]</code> 和 <code>[j, j+k]</code> 的元素完全一样，但因为 i 一直在 j 之前，所以以 i 开头的字符串一定比以 j 结尾的字符串要大。 - 如果 <code>sc[i+k]&lt;sc[j+k]</code>，这表示 <code>[i, i+k-1]</code> 和 <code>[j, j+k-1]</code> 的元素完全一样，那么但是因为 j+k 位置的元素比 i+k 大，那么 i 就不能作为开头了，因为 j 作为开始位置的字符串一定是大于 i 作为开始位置的字符串的。<strong>那 i 直接等于 j 吗？</strong> 这也不对，因为 i 只是表示以 i 开头进行判断，可能 i+1、i+2……开头会有更大的结果，但是我们可以发现在 <code>[i, i+k-1]</code> 开头都比不过 <code>[j, j+k-1]</code> 开头，<strong>但是 i+k 开头我们能判断出来吗？</strong> 显然不能，所以我们将 <code>i=i+k+1</code>，j 如果大于新的 i 那就不变，如果 j 小于等于新的 i，那就 <code>j=i+1</code>，k 重置为 0。 - 如果 <code>sc[i+k]&gt;sc[j+k]</code>，这表示 <code>[i, i+k-1]</code> 和 <code>[j, j+k-1]</code> 的元素完全一样，但是 i+k 的元素更大，那么表示在选择 <code>[i, i+k-1]</code> 为开头都已经是已经是已知的最大，但是以 i 结束的一定就是最大的吗，不一定，我们需要重新将 j 置为 <code>j+k+1</code>，k 重置为 0，再对应 i 重新判断。</p><p>思路很抽象，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">lastSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j+k&lt;n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i+k]==sc[j+k]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sc[i+k] &lt; sc[j+k]) &#123;    <span class="comment">// 表示[i,i+k-1]和[j,j+k-1]之间的内容一模一样，这之间的内容谁当开头i都行，但是k不一样，导致i+k这个位置不能当当开头，就算当也要在j+k这个位置</span></span><br><span class="line">                i = i+k+<span class="number">1</span>;</span><br><span class="line">                j = Math.max(i+<span class="number">1</span>, j);</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;     <span class="comment">// 表示[i,i+k-1]和[j,j+k-1]之间的内容一模一样，这之间的内容谁当开头i都行。但是k不一样，i+k依然可以当开头，但是j+k已经不能了</span></span><br><span class="line">                j = j+k+<span class="number">1</span>;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="餐盘栈">1172. 餐盘栈</h1><blockquote><p>考察： #小根堆 #栈</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304281043671.png" /></p><p>困难题。典型的思维题。题解：<a href="https://leetcode.cn/problems/dinner-plate-stacks/solutions/2248707/yu-qi-wei-hu-di-yi-ge-wei-man-zhan-bu-ru-sphs/">题解</a>。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DinnerPlates</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Deque&lt;Integer&gt;&gt; stacks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">// list的每一个元素是一个栈，这里保存所有的栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; idx = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();    <span class="comment">// 最小堆返回的永远都是最小的值，这里存储的是没有存满的栈的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DinnerPlates</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!idx.isEmpty() &amp;&amp; idx.peek()&gt;=stacks.size()) &#123;    <span class="comment">// idx中所有元素都是越界下标，直接清空</span></span><br><span class="line">            idx.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!idx.isEmpty()) &#123;     <span class="comment">// 有未满栈，且最小的下标没有越界，表示可以取出来用</span></span><br><span class="line">            Deque&lt;Integer&gt; temp = stacks.get(idx.peek());     <span class="comment">// 相当于指针</span></span><br><span class="line">            temp.push(val);</span><br><span class="line">            <span class="keyword">if</span> (temp.size() == capacity) &#123;</span><br><span class="line">                idx.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">// 所有的栈都已经满了</span></span><br><span class="line">            Deque&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            temp.push(val);</span><br><span class="line">            stacks.add(temp);</span><br><span class="line">            <span class="keyword">if</span> (capacity &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                idx.add(stacks.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> popAtStack(stacks.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popAtStack</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 非法操作</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= stacks.size() || stacks.get(index).isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; temp = stacks.get(index);    <span class="comment">// 相当于一个指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp.size() == capacity) &#123;</span><br><span class="line">            idx.add(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> temp.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stacks.isEmpty() &amp;&amp; stacks.get(stacks.size()-<span class="number">1</span>).isEmpty()) &#123;</span><br><span class="line">            stacks.remove(stacks.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your DinnerPlates object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * DinnerPlates obj = new DinnerPlates(capacity);</span></span><br><span class="line"><span class="comment"> * obj.push(val);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.popAtStack(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="使数组严格递增">1187. 使数组严格递增⭐</h1><blockquote><p>考察： #动态规划</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201108404.png" /></p><p>困难题，思路很重要。</p><p>题解：<a href="https://leetcode.cn/problems/make-array-strictly-increasing/solutions/491950/yi-wei-dp-si-lu-xiang-jie-cpy3-by-newhar/">题解</a></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304201110411.png" /></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">makeArrayIncreasing</span><span class="params">(<span class="type">int</span>[] arr1, <span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        arr2 = Arrays.stream(arr2).sorted().distinct().toArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr1.length+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置左右哨兵-1和MAXN</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        arr[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">2</span>;i++) &#123;</span><br><span class="line">            arr[i+<span class="number">1</span>] = arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[n-<span class="number">1</span>] = MAXN;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">// 记录在i不变的情况下，[0,i]升序的最小次数</span></span><br><span class="line">        Arrays.fill(dp,MAXN);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// 第一个元素是-1，在它不动的情况下，变化0次可以保证升序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> lower_bound(arr2, arr[i]);    <span class="comment">// j是在arr2的下标，这是比arr[i]大于或等于的最小数的位置，j是不可以用的。替换i-1的值应该从j-1开始。但是j反映了[0,j-1]的个数为j个</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果下标i不换，i-1换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k&lt;=Math.min(i-<span class="number">1</span>, j); k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i-k-<span class="number">1</span>] &lt; arr2[j-k]) &#123;     <span class="comment">// 这里打算替换arr[i-k]为arr2[j-k]，所以先要判断arr[i-k-1]是不是严格小于arr2[j-k]</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-k-<span class="number">1</span>]+k);     <span class="comment">// 对比dp[i]和在下标i-k-1不动的情况下，之后k个元素都变了的最小次数。     </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果下标i不换，i-1不换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i-<span class="number">1</span>] &lt; arr[i]) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> dp[n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (res&gt;=MAXN) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lower_bound</span><span class="params">(<span class="type">int</span>[] arr2, <span class="type">int</span> k)</span> &#123;    <span class="comment">// 找&gt;=k的第一个数的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr2.length;</span><br><span class="line">        <span class="keyword">while</span> (l&lt;r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr2[m]&lt;k) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-4">注意</h3><ul><li><a href="LeetCode总结笔记.md#数组#排序+去重">数组的排序+去重（Stream）</a></li><li><a href="LeetCode总结笔记.md#二分查找">模拟 C++的 <code>lower_bound()</code> 和 <code>upper_bound()</code></a></li></ul><h1 id="穿过迷宫的最少移动次数">1210. 穿过迷宫的最少移动次数</h1><h2 id="方法一广度优先搜索">方法一、广度优先搜索</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302052359281.png" /></p><blockquote><p>当遇到<strong>最少移动次数</strong>，首先想到的就是<strong>广度优先搜索</strong>，广度优先搜索使用的是<strong>队列</strong>。</p></blockquote><p>思路：以蛇尾巴为考察点，蛇有两种状态，当蛇为横着时，蛇只会向右、向下平行、顺时针旋转；当蛇为竖着时，蛇只会向下、向右平行、逆时针旋转。每次考察的时候需要判断当前位置当前状态是否第一次访问、是否越界、是否有墙。</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumMoves</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span>[][][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][<span class="number">2</span>];    <span class="comment">// 记录在此格子此姿势下的移动次数（只会向右边和下面，所以不会来回跑，不用记录最小次数）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                Arrays.fill(dist[i][j],-<span class="number">1</span>);     <span class="comment">//相当于dis[i][j][0]和dis[i][j][1]都初始化为-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只考虑尾巴</span></span><br><span class="line">        dist[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();     <span class="comment">//int[]记录的是三元组</span></span><br><span class="line">        dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] arr = dq.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[<span class="number">0</span>], y = arr[<span class="number">1</span>], status = arr[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">// 基于当前尾巴位置进行广度优先搜索</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前是横着的</span></span><br><span class="line">            <span class="keyword">if</span> (status==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 有三种情况，分别是平行向下，向右，以尾巴为中心顺时针转(要求另外的两个单元都是空的)</span></span><br><span class="line">                <span class="comment">// 1. 向右</span></span><br><span class="line">                <span class="keyword">if</span> (y+<span class="number">2</span> &lt; n &amp;&amp; grid[x][y+<span class="number">2</span>] == <span class="number">0</span> &amp;&amp; dist[x][y+<span class="number">1</span>][<span class="number">0</span>] == -<span class="number">1</span>) &#123;    <span class="comment">//如果已经走过，那一定比这次的次数要小</span></span><br><span class="line">                    dist[x][y+<span class="number">1</span>][<span class="number">0</span>] = dist[x][y][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y+<span class="number">1</span>, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2. 平行向下</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">1</span> &lt; n &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dist[x+<span class="number">1</span>][y][<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x+<span class="number">1</span>][y][<span class="number">0</span>] = dist[x][y][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x+<span class="number">1</span>, y, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">1</span> &lt; n &amp;&amp; y+<span class="number">1</span> &lt; n &amp;&amp; grid[x+<span class="number">1</span>][y] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; dist[x+<span class="number">1</span>][y][<span class="number">1</span>] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dist[x][y][<span class="number">1</span>] = dist[x][y][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 向右</span></span><br><span class="line">                <span class="keyword">if</span> (y+<span class="number">1</span> &lt; n &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dist[x][y+<span class="number">1</span>][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x][y+<span class="number">1</span>][<span class="number">1</span>] = dist[x][y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y + <span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2. 向下</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">2</span> &lt; n &amp;&amp; grid[x+<span class="number">2</span>][y] == <span class="number">0</span> &amp;&amp; dist[x+<span class="number">1</span>][y][<span class="number">1</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x+<span class="number">1</span>][y][<span class="number">1</span>] = dist[x][y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x + <span class="number">1</span>, y, <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3. 旋转</span></span><br><span class="line">                <span class="keyword">if</span> (x+<span class="number">1</span> &lt; n &amp;&amp; y+<span class="number">1</span> &lt; n &amp;&amp; grid[x][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; grid[x+<span class="number">1</span>][y+<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; dist[x][y][<span class="number">0</span>] == -<span class="number">1</span>) &#123;</span><br><span class="line">                    dist[x][y][<span class="number">0</span>] = dist[x][y][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dq.offerLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y, <span class="number">0</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[n - <span class="number">1</span>][n - <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除子文件夹">1233. 删除子文件夹</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302081040786.png" /></p><p>比较简单，字符串的匹配问题。</p><h1 id="替换子串得到平衡字符串">1234. 替换子串得到平衡字符串⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302132232292.png" /></p><p>非常难且恶心的一道题。</p><p>思路和很多题一样，找中间的最小子串，实际上要找的是两边的满足条件的最大子串。定义一个 left=0，先遍历 right 从头到尾，当遇到某个 right 不满足外面每个字母&lt;=l 这个条件时，继续右移 left，一直更新最小的 min。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.length/<span class="number">4</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">int</span>[] remainder = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        hash.put(<span class="string">&#x27;Q&#x27;</span>,<span class="number">0</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;W&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;E&#x27;</span>,<span class="number">2</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;R&#x27;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sc.length;i++) &#123;</span><br><span class="line">            remainder[hash.get(sc[i])]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remainder[<span class="number">0</span>]==l &amp;&amp; remainder[<span class="number">1</span>]==l &amp;&amp; remainder[<span class="number">2</span>]==l &amp;&amp; remainder[<span class="number">3</span>]==l) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//right和left算在里面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right=<span class="number">0</span>;right&lt;sc.length;right++) &#123;</span><br><span class="line">            remainder[hash.get(sc[right])]--;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;=right &amp;&amp; remainder[<span class="number">0</span>]&lt;=l &amp;&amp; remainder[<span class="number">1</span>]&lt;=l &amp;&amp; remainder[<span class="number">2</span>]&lt;=l &amp;&amp; remainder[<span class="number">3</span>]&lt;=l) &#123;</span><br><span class="line">                min = Math.min(min,right-left+<span class="number">1</span>);</span><br><span class="line">                remainder[hash.get(sc[left])]++;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找出给定方程的正整数解">1237. 找出给定方程的正整数解</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303121721337.png" /></p><p>中等题，但是是阅读理解，唯一有用的是 <code>Arrays.asList</code> 的使用。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * // This is the custom function interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class CustomFunction &#123;</span></span><br><span class="line"><span class="comment"> *     // Returns f(x, y) for any given positive integers x and y.</span></span><br><span class="line"><span class="comment"> *     // Note that f(x, y) is increasing with respect to both x and y.</span></span><br><span class="line"><span class="comment"> *     // i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)</span></span><br><span class="line"><span class="comment"> *     public int f(int x, int y);</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSolution</span><span class="params">(CustomFunction customfunction, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">1</span>;x&lt;=z;x++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> y=<span class="number">1</span>;y&lt;=z;y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (customfunction.f(x,y)==z) &#123;</span><br><span class="line">                    res.add(Arrays.asList(x,y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环码排列">1238. 循环码排列⭐</h1><h1 id="方法一格雷编码">方法一、格雷编码</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230951037.png" /></p><p>详细见 <strong>89. 格雷编码</strong>，这里唯一的不同是定义了一个 start，其实不难想到先将整个二进制数组转化为格雷码数组，从 start 开始进行写入 res，再将前面部分补上即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">circularPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] gray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>&lt;&lt;n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//记录格雷码为start的位置</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存每个数的格雷码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            gray[i] = i ^ (i&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (gray[i]==start) &#123;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=j;i&lt;j+(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i%(<span class="number">1</span>&lt;&lt;n);</span><br><span class="line">            res.add(k ^ (k&gt;&gt;<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优化-3">优化</h3><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302230935328.png" /></p><p>但是这其实是可以优化的，标准的格雷码是从 0 开始，其实 <code>start ⊕ 0 = start</code>，所以直接将标准的格雷码⊕ start 即可。详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">circularPermutation</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++) &#123;</span><br><span class="line">            res.add(i ^ (i&gt;&gt;<span class="number">1</span>) ^ start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="交换字符使得字符串相同">1247. 交换字符使得字符串相同</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302251656447.png" /></p><p>中等题，但容易想的很复杂。其实思路很简单，对于 s1 和 s2 不同的组合，有如下的处理情况：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302251659131.jpg" alt="51391c182efbd1f86b0c93246c15503.jpg" /><figcaption aria-hidden="true">51391c182efbd1f86b0c93246c15503.jpg</figcaption></figure><p>不难看出，只要有偶数个 xy 对或者偶数个 yx 对，都能通过一半的次数消去不同；对于一个 yx 对和一个 xy 对，需要 2 次处理。只有在处理完后还有 1 个 xy 对或者 yx 对时，表示无法完全消除。详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSwap</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1c = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2c = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">xy</span> <span class="operator">=</span> <span class="number">0</span>, yx = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;s1c.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1c[i]!=s2c[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1c[i]==<span class="string">&#x27;x&#x27;</span>) &#123;</span><br><span class="line">                    xy ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    yx ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += xy/<span class="number">2</span>;</span><br><span class="line">        xy = xy%<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        res += yx/<span class="number">2</span>;</span><br><span class="line">        yx = yx%<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xy==<span class="number">0</span> &amp;&amp; yx==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (xy==<span class="number">1</span> &amp;&amp; yx==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res+<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="得分最高的单词集合">1255. 得分最高的单词集合</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302261756195.png" /></p><p>困难题，使用的是 DFS 遍历每种情况。<a href="https://leetcode.cn/problems/maximum-score-words-formed-by-letters/solutions/2133515/hui-su-san-wen-si-kao-hui-su-wen-ti-de-t-kw3y/">题解</a></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302261758306.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] surplus = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] score;</span><br><span class="line">    String[] words;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> total)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            res = Math.max(res,total);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不选words[i]</span></span><br><span class="line">        dfs(i-<span class="number">1</span>,total);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选words[i]</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">haveAll</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">char</span>[] wc = words[i].toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : wc) &#123;</span><br><span class="line">            surplus[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (surplus[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                haveAll = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += score[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (haveAll==<span class="literal">true</span>) &#123;    <span class="comment">//当前单词可以完全拼出</span></span><br><span class="line">            dfs(i-<span class="number">1</span>,total);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恢复现场</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : wc) &#123;</span><br><span class="line">            surplus[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScoreWords</span><span class="params">(String[] words, <span class="type">char</span>[] letters, <span class="type">int</span>[] score)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.words = words;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;letters.length;i++) &#123;</span><br><span class="line">            surplus[letters[i]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(words.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="找出井字棋的获胜者">1275、找出井字棋的获胜者</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626754.png" alt="image-20221009160316785" /><figcaption aria-hidden="true">image-20221009160316785</figcaption></figure><p>常规简单题。</p><h3 id="注意-5">注意</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];    <span class="comment">//初始化为null</span></span><br><span class="line"><span class="type">int</span>[] i = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];          <span class="comment">//初始化为0</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">3</span>];    <span class="comment">//初始化为false</span></span><br></pre></td></tr></table></figure><h1 id="灌溉花园的最少水龙头数目">1326. 灌溉花园的最少水龙头数目⭐⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302211041920.png" /></p><p>题解：<a href="https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden/solutions/2124024/python3javacgotypescript-yi-ti-yi-jie-ta-hwfe/">题解</a></p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302211047624.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minTaps</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] ranges)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];     <span class="comment">//表示以下标为起点的最远能去的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> Math.max(<span class="number">0</span>,i-ranges[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i+ranges[i];</span><br><span class="line">            right[l] = Math.max(right[l],r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">//i表示的是起点</span></span><br><span class="line">            last = Math.max(last,right[i]);    <span class="comment">//表示目前能一直到达的地方</span></span><br><span class="line">            <span class="keyword">if</span> (last&lt;=i) &#123;      <span class="comment">//表示目前能到的地方比判断的起点还小</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==pre) &#123;    <span class="comment">//表示这一段结束了</span></span><br><span class="line">                res++;</span><br><span class="line">                pre = last;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通知所有员工所需的时间">1376. 通知所有员工所需的时间</h1><blockquote><p>考察： #图 #dfs #bfs</p></blockquote><h2 id="方法一邻接表dfs">方法一、邻接表+dfs</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202305011043569.png" /></p><p>中等题，按部就班 dfs 即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; list;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] informTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numOfMinutes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> headID, <span class="type">int</span>[] manager, <span class="type">int</span>[] informTime)</span> &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.informTime = informTime;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">// 构建邻接表</span></span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;      <span class="comment">// 遍历manager    </span></span><br><span class="line">            <span class="keyword">if</span> (manager[i]==-<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(manager[i]).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (manager[i]==-<span class="number">1</span>) &#123;</span><br><span class="line">                dfs(i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> time)</span> &#123;    <span class="comment">//表示当前节点是i，传给他的时候的时间已经是time</span></span><br><span class="line">        res = Math.max(res, time);</span><br><span class="line">        <span class="keyword">if</span> (list.get(i).size()==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;list.get(i).size(); j++) &#123;</span><br><span class="line">            dfs(list.get(i).get(j),time+informTime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用栈操作构建数组">1441、用栈操作构建数组</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626755.png" alt="image-20221015120642642" /><figcaption aria-hidden="true">image-20221015120642642</figcaption></figure><p>比较简单，注意ArrayList的构建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h1 id="保证文件名唯一">1487. 保证文件名唯一</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303031107630.png" /></p><p>利用 HashMap 记录，其 value 记录的值 v 表示[1, v]都是确定已经用过的了，下次可以直接从 v+1 进行查找。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] getFolderNames(String[] names) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> names.length;</span><br><span class="line">        String[] sc = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        HashMap&lt;String,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> names[i];</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(name)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> hash.get(name);</span><br><span class="line">                <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> name + <span class="string">&quot;(&quot;</span> + (v+<span class="number">1</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (hash.containsKey(temp)) &#123;</span><br><span class="line">                    v++;</span><br><span class="line">                    hash.replace(name,v);</span><br><span class="line">                    temp = name + <span class="string">&quot;(&quot;</span> + (v+<span class="number">1</span>) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                hash.put(temp,<span class="number">0</span>);</span><br><span class="line">                sc[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.put(name,<span class="number">0</span>);</span><br><span class="line">                sc[i] = name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乘积为正数的最长子数组长度">1567、乘积为正数的最长子数组长度⭐</h1><p>本题是<code>152、乘积最大子数组和</code>的升级版。</p><h2 id="方法一常规思路">方法一、常规思路</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626756.png" alt="image-20221020214723468" /><figcaption aria-hidden="true">image-20221020214723468</figcaption></figure><p>本思路其实很简单。</p><p>先遍历一遍找到所有的0，在0与0之间找我们的答案。</p><p>在每个0和0之间，如果负数的个数是0或者偶数，则这个范围长度就是这个范围内的max；如果不是偶数，用双指针对应范围内的首尾位置，找到第一个负数，返回除去这个负数的范围剩下的范围的长度，就是这个范围的max。具体可以看代码理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;z.size()-<span class="number">1</span>;i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> z.get(i)+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> z.get(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (f.get(i)%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">        max = Math.max(max,right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> j=left,t=right-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j&lt;=t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j==t) &#123;     <span class="comment">//一定是负数</span></span><br><span class="line">                max = Math.max(max,j-left);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[j]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                max = Math.max(max,right-j-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[t]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                max = Math.max(max,t-left);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            t--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划-5">方法二、动态规划⭐</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626757.png" alt="image-20221020221331318" /><figcaption aria-hidden="true">image-20221020221331318</figcaption></figure><p><a href="https://leetcode.cn/problems/maximum-length-of-subarray-with-positive-product/solutions/441152/cheng-ji-wei-zheng-shu-de-zui-chang-zi-shu-zu-ch-3/">题解</a></p><p>这个很厉害！</p><p>建立两个数组zs和fs：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] zs = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//记录以当前下标i结尾的乘积为正数的长度</span></span><br><span class="line"><span class="type">int</span>[] fs = <span class="keyword">new</span> <span class="title class_">int</span>[n];    <span class="comment">//记录以当前下标i结尾的乘积为负数的长度</span></span><br></pre></td></tr></table></figure><p>处理第一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[<span class="number">0</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    zs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nums[<span class="number">0</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">    fs[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果是0，那么zs和fs都是0</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> zs[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>对i&gt;=1后的所有元素进行分析：</p><p>对于nums[i]&lt;0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//连续正数的个数+1</span></span><br><span class="line">    zs[i] = zs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//当前数为正数</span></span><br><span class="line">    <span class="keyword">if</span> (fs[i-<span class="number">1</span>]==<span class="number">0</span>) &#123;    <span class="comment">//如果在此之前都没有能成为负数的乘积，再加上这个正数，负数长度仍然为0</span></span><br><span class="line">        fs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fs[i] = fs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于nums[i]&lt;0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fs[i-<span class="number">1</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">        zs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        zs[i] = fs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fs[i] = zs[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于nums[i]==0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i]==<span class="number">0</span>) &#123;</span><br><span class="line">    zs[i] = <span class="number">0</span>;</span><br><span class="line">    fs[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划优化">动态规划优化</h3><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626758.png" alt="image-20221020221215423" /><figcaption aria-hidden="true">image-20221020221215423</figcaption></figure><p>每次只使用了i-1的相关值，可以设置两个变量即可。</p><h1 id="删除最短的子数组使剩余数组有序">1574. 删除最短的子数组使剩余数组有序</h1><blockquote><p>考察： #滑动窗口</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303252314502.png" /></p><p>中等题，但是比较考验思路。首先找到左边非降序的子序列，left 为其结尾位置；再从右往左找右边部分的非降序子序列，right 为其开始位置。在 left 计算出来之后直接处理，如果 left 为结尾，那么表示全部元素非降序，那么直接返回 0。之后初始化窗口，也就是<strong>最大的窗口其实就是只要左边非降序部分的剩余部分或者只要右边非降序部分的剩余部分，取最小值</strong>，再依次从头移动 start，和 right 判断，如果 arr[start]&lt;=arr[right]，那么更新窗口；否则继续右移 right 直到 right 到 n，那么意思就是只要左边非降序部分。注意窗口更新时都需要与自己取 min。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfShortestSubarray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="keyword">for</span> (left=<span class="number">0</span>;left&lt;n-<span class="number">1</span>;left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left] &gt; arr[left+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (right=n-<span class="number">1</span>;right&gt;<span class="number">0</span>;right--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[right] &lt; arr[right-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(left);</span><br><span class="line">        System.out.println(right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.min(n-left-<span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= left) &#123;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; n &amp;&amp; arr[start] &gt; arr[right]) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.min(res, right-start-<span class="number">1</span>);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使数组和能被-p-整除">1590. 使数组和能被 P 整除</h1><h2 id="方法一前缀和-余数">方法一、前缀和 + 余数</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303101013283.png" /></p><p>思路：我们要找到一个子数组，使得整个数组减去它就能被 p 整数，那么可以发现：<strong>子数组的余数等于整个数组的余数</strong>，我们需要找到一个最短的满足这个要求的子数组。</p><p>这里涉及到几个小优化。我们设置前缀，是防止在后面求子数组和的时候要进行遍历求和，而前缀和直接用收尾的前缀和相减即可得到。但是为了优化代码和简化操作，这里实际上是前缀和的余数，一样的，他们对比的标准也是 nums 的余数。在下面的两层 for 循环内，我们不应该一个设置头一个设置尾进行循环，而是应该一个设置长度，一个设置头，这样找到一个最小的子数组就可以直接返回了。</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果子数组的余数 == 整个数组的余数，则就是答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 前缀和的余数</span></span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 整个nums的余数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            y = (y + nums[i] % p) % p;</span><br><span class="line">            pre[i] = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果整个nums的余数就是0，那么无需操作</span></span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;     <span class="comment">//子数组的长度</span></span><br><span class="line">            <span class="comment">// 子数组的起点下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> start=<span class="number">0</span>;start&lt;=n-i;start++) &#123;</span><br><span class="line">                <span class="comment">// 如果起点下标为0</span></span><br><span class="line">                <span class="keyword">if</span> (start==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pre[i-<span class="number">1</span>]==y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果起点下标不是0</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((pre[start+i-<span class="number">1</span>] - pre[start-<span class="number">1</span>] + p)%p == y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="经营摩天轮的最大利润">1599. 经营摩天轮的最大利润</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303051034143.png" /></p><p>中等题，读懂题目很重要！代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperationsMaxProfit</span><span class="params">(<span class="type">int</span>[] customers, <span class="type">int</span> boardingCost, <span class="type">int</span> runningCost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">surplus</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ready</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=customers.length;i++) &#123;</span><br><span class="line">            surplus += customers[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 这一圈一定会亏损，如果需要转，在后面计算的时候会默认转，如果不转，这里的最大盈利就是当前的上一个情况的盈利值。</span></span><br><span class="line">            <span class="keyword">if</span> (surplus==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (surplus&lt;<span class="number">4</span> &amp;&amp; surplus&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                ready += surplus;</span><br><span class="line">                surplus = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;      <span class="comment">// &gt;=4个人</span></span><br><span class="line">                ready += <span class="number">4</span>;</span><br><span class="line">                surplus -= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ready * boardingCost - i * runningCost &gt; res) &#123;</span><br><span class="line">                res = ready * boardingCost - i * runningCost;</span><br><span class="line">                max = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 游客不再添加</span></span><br><span class="line">        <span class="keyword">while</span> (surplus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (surplus &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">                ready += surplus;</span><br><span class="line">                <span class="keyword">if</span> (ready * boardingCost - i * runningCost &gt; res) &#123;</span><br><span class="line">                    res = ready * boardingCost - i * runningCost;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ready += <span class="number">4</span>;</span><br><span class="line">                surplus -= <span class="number">4</span>;</span><br><span class="line">                <span class="keyword">if</span> (ready * boardingCost - i * runningCost &gt; res) &#123;</span><br><span class="line">                    res = ready * boardingCost - i * runningCost;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (res&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="警告一小时内使用相同员工卡大于等于三次的人">1604. 警告一小时内使用相同员工卡大于等于三次的人</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302071247679.png" /></p><p>我们先用哈希表 hash 记录每个员工的所有打卡时间。注意这里需要将字符串的时间转为以分钟为单位的整形时间。</p><p>然后遍历哈希表，对于每个员工，我们先判断员工的打卡次数是否大于等于 3，如果不是，则跳过该员工。否则，我们将该员工的所有打卡时间按照时间先后排序，然后遍历排序后的打卡时间，判断下标距离为 2 的两个时间是否在同一小时内，如果是，则将该员工加入答案数组。</p><p>最后，将答案数组按照字典序排序，即可得到答案。</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">alertNames</span><span class="params">(String[] keyName, String[] keyTime)</span> &#123;</span><br><span class="line">        HashMap&lt;String,ArrayList&lt;Integer&gt;&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;keyName.length;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> Integer.parseInt(keyTime[i].substring(<span class="number">0</span>, <span class="number">2</span>)) * <span class="number">60</span> + Integer.parseInt(keyTime[i].substring(<span class="number">3</span>));     <span class="comment">//将时间转为分钟</span></span><br><span class="line">            <span class="keyword">if</span> (!hash.containsKey(keyName[i])) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">                al.add(t);</span><br><span class="line">                hash.put(keyName[i],al);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; al = hash.get(keyName[i]);</span><br><span class="line">                al.add(t);</span><br><span class="line">                hash.replace(keyName[i],al);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,ArrayList&lt;Integer&gt;&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            ArrayList&lt;Integer&gt; value = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (value.size()&lt;=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Collections.sort(value);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;value.size()-<span class="number">2</span>;i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value.get(i+<span class="number">2</span>)-value.get(i)&lt;=<span class="number">60</span>) &#123;</span><br><span class="line">                        res.add(key);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="给定行和列的和求可行矩阵">1605. 给定行和列的和求可行矩阵</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303140824625.png" /></p><p>贪心到底。每次 <code>res[i][j] = Math.min(rowSum[i],colSum[j])</code> 并同时更新 <code>rowSum[i] -= res[i][j]</code> 和 <code>colSum[j] -= res[i][j]</code>，一定存在解。详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] restoreMatrix(<span class="type">int</span>[] rowSum, <span class="type">int</span>[] colSum) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> rowSum.length;    <span class="comment">// 行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> colSum.length;    <span class="comment">// 列</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                res[i][j] = Math.min(rowSum[i],colSum[j]);</span><br><span class="line">                rowSum[i] -= res[i][j];</span><br><span class="line">                colSum[j] -= res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大网络秩">1615. 最大网络秩</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303150823244.png" /></p><p>中等题，但是比较简单想到，利用邻接矩阵再小优化即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalNetworkRank</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] roads)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n][n+<span class="number">1</span>];     <span class="comment">//最后一列记录总数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] road : roads) &#123;</span><br><span class="line">            map[road[<span class="number">0</span>]][road[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">            map[road[<span class="number">0</span>]][n]++;</span><br><span class="line">            map[road[<span class="number">1</span>]][road[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">            map[road[<span class="number">1</span>]][n]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map[i][j]==<span class="number">1</span>) &#123;</span><br><span class="line">                    max = Math.max(max, map[i][n]+map[j][n]-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    max = Math.max(max, map[i][n]+map[j][n]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j=0;j&lt;n+1;j++) &#123;</span></span><br><span class="line">        <span class="comment">//         System.out.print(map[i][j]);</span></span><br><span class="line">        <span class="comment">//         System.out.print(&quot; &quot;);</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     System.out.println(&quot;&quot;);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分割两个字符串得到回文串">1616. 分割两个字符串得到回文串⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303181158607.png" /></p><blockquote><p>考察： #回文串</p></blockquote><p>中等题，但是想要在 O (n) 的时间复杂度里通过还是需要思考的。</p><p>我们可以分为两种情况，分别是 a 在 b 前面和 b 在 a 前面。现在讨论 a 在 b 前面的情况，我们可以直接进行判断 a 的头和 b 的尾是否相等，如果相等，则双指针继续往中间移动。如果直到两个指针遇到了，那就表示一定可以 true，如果在某一处两个指针不相等，那么开始判断 a 或者 b 这两个指针之间的元素是不是构成回文串，如果 a 或者 b 构成，那么也 true，如果不行则返回 false。讨论 b 在 a 前面的情况同理。</p><blockquote><p>举个例子：<br />a = abcabaaaa<br />b = aaabdacba<br />按照上面的规则：<br />abc|abaaaa<br />aaabda|cba<br />我们需要判断 aba 或者 bda 是不是回文串，如本例，第一个 a 子串的 aba 是，那么最后可以划分：<br /><strong>abcaba</strong>|aaa<br />aaabda|<strong>cba</strong><br />变成：abcabacba</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i]!=sc[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span> <span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = a.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j &amp;&amp; a.charAt(i)==b.charAt(j)) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (isPalindrome(a,i,j) || isPalindrome(b,i,j));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPalindromeFormation</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (check(a,b) || check(b,a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行操作后字典序最小的字符串">1625. 执行操作后字典序最小的字符串</h1><blockquote><p>考察： #哈希 #队列</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303191053748.png" /></p><p>中等题，利用 Hash 存储和 queue 队列进行判断。每次从队列中取出一个字符串，对它做两种操作，如果已经存在于 hash 中，则不管；如果没有在 hash 中，则存入 hash，并再放入 queue 中。结束条件为：队列为空。</p><blockquote><p>感悟：本题说明了，bfs 是利用队列进行完成，优化可以搭配 hash 进行查重（hash 可以是 hashset、treeset、hashmap 等等，只要包含 contains () 即可）</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Add</span><span class="params">(String s, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i=i-<span class="number">2</span>) &#123;</span><br><span class="line">            sc[i] = Integer.toString((sc[i] - <span class="string">&#x27;0&#x27;</span> + a)%<span class="number">10</span>).charAt(<span class="number">0</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> String.valueOf(sc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">Rotate</span><span class="params">(String s, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">return</span> s.substring(n-b) + s.substring(<span class="number">0</span>,n-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLexSmallestString</span><span class="params">(String s, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> s;</span><br><span class="line">        Deque&lt;String&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        TreeSet&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">        dq.addLast(s);</span><br><span class="line">        ts.add(s);</span><br><span class="line">        <span class="keyword">while</span> (!dq.isEmpty()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> dq.pollFirst();</span><br><span class="line">            <span class="keyword">if</span> (res.compareTo(t)&gt;<span class="number">0</span>) &#123;     <span class="comment">//res更大</span></span><br><span class="line">                res = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> Add(t,a);</span><br><span class="line">            <span class="keyword">if</span> (!ts.contains(s1)) &#123;</span><br><span class="line">                ts.add(s1);</span><br><span class="line">                dq.addLast(s1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> Rotate(t,b);</span><br><span class="line">            <span class="keyword">if</span> (!ts.contains(s2)) &#123;</span><br><span class="line">                ts.add(s2);</span><br><span class="line">                dq.addLast(s2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="无矛盾的最佳球队">1626. 无矛盾的最佳球队⭐</h1><blockquote><p>考察： #动态规划 #最长递增子序列</p><p>基础题：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303221004200.png" /></p><p>中等题，典型的动态规划题。</p><p>按照分数进行从小到大排序，分数相等的按照年龄进行从小到大排序。只需要从左向右遍历构建 dp，dp 数组表示以当前数结尾的最大和。每遍历一个数时，再从当前数左边那个数从右往左遍历，因为越往前面表示分数越小，如果满足条件那年龄应该是相等或者更小，所以如果前面的年龄更大则直接 continue，直到把前面遍历完，找到最大和放入这个数的 dp 下。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bestTeamScore</span><span class="params">(<span class="type">int</span>[] scores, <span class="type">int</span>[] ages)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scores.length;</span><br><span class="line">        <span class="type">int</span>[][] sl = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            sl[i][<span class="number">0</span>] = ages[i];</span><br><span class="line">            sl[i][<span class="number">1</span>] = scores[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(sl, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>]!=b[<span class="number">1</span>]) &#123;      <span class="comment">// 分数不一样，则按照分数从小到大</span></span><br><span class="line">                    <span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>]-b[<span class="number">0</span>];      <span class="comment">// 分数一样，则按照年龄从小到大</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = sl[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sl[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sl[j][<span class="number">0</span>]&gt;sl[i][<span class="number">0</span>]) &#123;     <span class="comment">//前面的表示分数小。如果前面的年龄更大</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m = Math.max(m, sl[i][<span class="number">1</span>] + dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = m; </span><br><span class="line">            max = Math.max(max,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="等差子数组">1630. 等差子数组</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303230818106.png" /></p><p>中等题，但是暴力模拟即可。</p><p>用到了<strong>数组的深拷贝</strong>：<code>System.arraycopy(原数组, 原数组起点, 新数组, 新数组起点, 长度);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Boolean&gt; <span class="title function_">checkArithmeticSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] l, <span class="type">int</span>[] r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, m = l.length;</span><br><span class="line">        ArrayList&lt;Boolean&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> l[i], right = r[i];</span><br><span class="line">            <span class="type">int</span>[] child = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">            System.arraycopy(nums, left, child, <span class="number">0</span>, right-left+<span class="number">1</span>);</span><br><span class="line">            Arrays.sort(child);</span><br><span class="line">            <span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span> child[<span class="number">1</span>]- child[<span class="number">0</span>];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;child.length;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (child[j]-child[j-<span class="number">1</span>] != dis) &#123;</span><br><span class="line">                    isTrue = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(isTrue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两点之间不包含任何点的最宽垂直区域">1637. 两点之间不包含任何点的最宽垂直区域</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303300832320.png" /></p><p>中等题，但是很简单。</p><h1 id="统计只差一个字符的子串数目">1638. 统计只差一个字符的子串数目</h1><h2 id="方法一暴力">方法一、暴力</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303270843071.png" /></p><p>直接遍历两个字符串的起点 i、j，再同时遍历相同长度，看看在这个长度内是否只有一个不同，如果成立，sum++。时间复杂度 <span class="math inline">\(O(n^3)\)</span>。</p><h2 id="方法二极致优化">方法二、极致优化</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303271000198.png" /></p><p>题解：<a href="https://leetcode.cn/problems/count-substrings-that-differ-by-one-character/solutions/2192600/tu-jie-fei-bao-li-onm-suan-fa-pythonjava-k5og/">题解</a>，复杂度 <span class="math inline">\(O(nm)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tc = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>-m; d&lt;n; d++) &#123;    <span class="comment">// d表示i比j的位置大多少（可以是负数），i表示sc的最后一个元素、j表示tc的最后一个元素</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, d);     <span class="comment">// i一定是&gt;=0</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">k0</span> <span class="operator">=</span> i - <span class="number">1</span>, k1 = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; n &amp;&amp; i - d &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[i]!=tc[i-d]) &#123;     </span><br><span class="line">                    k0 = k1;</span><br><span class="line">                    k1 = i;     <span class="comment">//表示 (k0,k1] 是可以取s的起点</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum += k1 - k0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="能否连接形成数组">1640、能否连接形成数组</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626759.png" alt="image-20220922221718430" /><figcaption aria-hidden="true">image-20220922221718430</figcaption></figure><h1 id="统计字典序元音字符串的数目">1641. 统计字典序元音字符串的数目</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303292201695.png" /></p><p>中等题，找规律即可。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countVowelStrings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];   <span class="comment">// u o i e a</span></span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">            map[i] = <span class="number">1</span> + map[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map[<span class="number">4</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (k&lt;=n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                map[i] += map[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="拆炸弹">1652、拆炸弹</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626760.png" alt="image-20220924104449440" /><figcaption aria-hidden="true">image-20220924104449440</figcaption></figure><p>负数的求余：</p><p>被除数的绝对值与除数绝对值取余的值即为余数绝对值，余数符号与被除数一致。</p><h1 id="使字符串平衡的最少删除次数">1653. 使字符串平衡的最少删除次数⭐</h1><h2 id="方法一分割">方法一、分割</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061024105.png" /></p><p>中等题，遍历分隔符。在分隔符的左边删掉 b，右边（及其自己）删掉 a。记录删除最少时的位置所删除的次数。<a href="https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/solutions/2149746/qian-hou-zhui-fen-jie-yi-zhang-tu-miao-d-dor2/">题解</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[][] nn = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sc[i]==<span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;     <span class="comment">// 带当前i下标的前面的b</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sc[i]==<span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                    nn[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">                    nn[<span class="number">1</span>][i] = a;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nn[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">                    nn[<span class="number">1</span>][i] = a;</span><br><span class="line">                    a--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sc[i]==<span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                nn[<span class="number">0</span>][i] = nn[<span class="number">0</span>][i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                nn[<span class="number">1</span>][i] = a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nn[<span class="number">0</span>][i] = nn[<span class="number">0</span>][i-<span class="number">1</span>];</span><br><span class="line">                nn[<span class="number">1</span>][i] = a;</span><br><span class="line">                a--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;    <span class="comment">//i和i之后的都是b，删a</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                res = Math.min(res,nn[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i==n) &#123;</span><br><span class="line">                res = Math.min(res,nn[<span class="number">0</span>][i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.min(res,nn[<span class="number">0</span>][i-<span class="number">1</span>] + nn[<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划-6">方法二、动态规划</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303061103971.png" /></p><p>考虑 s 的最后一个字母：</p><ul><li>如果它是‘b’，则无需删除，问题规模缩小，变成「使 s 的前 n−1 个字母平衡的最少删除次数」。</li><li>如果它是‘a’：<ul><li>删除它，则答案为「使 s 的前 n−1 个字母平衡的最少删除次数」加上 1。</li><li>保留它，那么前面的所有‘b’ 都要删除；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumDeletions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bn</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                bn++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = Math.min(res + <span class="number">1</span>, bn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="将-x-减到-0-的最小操作数">1658. 将 x 减到 0 的最小操作数⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626799.png" alt="Pasted image 20230107130117" /><figcaption aria-hidden="true">Pasted image 20230107130117</figcaption></figure><p>本题较难，需要转换思路。</p><p>把问题转换成nums中移除一个最长的子数组，使得剩余元素的和为 x。 换句话说，要从nums中找最长的子数组，其元素和等于 s−x，这里 s为 nums所有元素之和。 最后答案为 nums 的长度减去最长子数组的长度。</p><p>题中想要找到两端最短和，转换思路就是<strong>找到 nums 的满足条件的最长子数组</strong>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">snums</span> <span class="operator">=</span> Arrays.stream(nums).sum() - x;    <span class="comment">//找到最长的子数组，常读等于snums</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (snums&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> right=<span class="number">0</span>;right&lt;n;right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; snums) &#123;      <span class="comment">//其实sum不可能减到负数的，应为while的限制条件会在减成0的时候及时打断</span></span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == snums) &#123;</span><br><span class="line">                res = Math.max(res, right-left+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res==-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n-res;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求数组和：</span><br><span class="line">```java</span><br><span class="line">sum = Arrays.stream(nums).sum();</span><br></pre></td></tr></table></figure><h1 id="具有给定数值的最小字符串">1663. 具有给定数值的最小字符串</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626800.png" alt="Pasted image 20230126163114" /><figcaption aria-hidden="true">Pasted image 20230126163114</figcaption></figure><p>比较简单的题目~</p><h1 id="生成平衡数组的方案数">1664. 生成平衡数组的方案数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626801.png" alt="Pasted image 20230128112355" /><figcaption aria-hidden="true">Pasted image 20230128112355</figcaption></figure><p>比较简单的一题，维护两个数组，动态区分正向和反向的偶数和和奇数和。</p><h1 id="合并两个链表">1669. 合并两个链表</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626802.png" alt="Pasted image 20230131093641" /><figcaption aria-hidden="true">Pasted image 20230131093641</figcaption></figure><p>比较简单。唯一要注意的是指针在没有定义时为 <code>null</code>，而不是 <code>NULL</code>。</p><h1 id="重新格式化电话号码">1694、重新格式化电话号码</h1><h2 id="方法一常规逻辑">方法一、常规逻辑</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626761.png" alt="image-20221001102615465" /><figcaption aria-hidden="true">image-20221001102615465</figcaption></figure><p>先除去多余字符，再插入'-'</p><p>substring()使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = s.substring(<span class="number">1</span>,<span class="number">5</span>);    <span class="comment">//截取下标1~4</span></span><br><span class="line"></span><br><span class="line">s = s.substring(<span class="number">5</span>);   <span class="comment">//截取下标为5~end</span></span><br></pre></td></tr></table></figure><p>replace()使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = s.replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);    <span class="comment">//将全文的-变成无</span></span><br></pre></td></tr></table></figure><h2 id="方法二stringbuilder方法">方法二、StringBuilder方法</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626762.png" alt="image-20221001115656084" /><figcaption aria-hidden="true">image-20221001115656084</figcaption></figure><blockquote><p>String内容是不可变的，StringBuilder内容是可变的</p><p>StringBuilder处理字符串性能比String好</p></blockquote><p>StringBuilder的创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br></pre></td></tr></table></figure><p>StringBuilder的尾部插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.append(<span class="string">&quot;wry&quot;</span>);</span><br></pre></td></tr></table></figure><p>StringBuilder的中间插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.insert(<span class="number">0</span>,<span class="string">&#x27;w&#x27;</span>);    <span class="comment">//在下标为0之前插入字符w</span></span><br></pre></td></tr></table></figure><p>StringBuilder的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br></pre></td></tr></table></figure><p>StringBuilder的删除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sb.delete(<span class="number">6</span>, <span class="number">14</span>);    <span class="comment">//删除下标为[6,14)</span></span><br></pre></td></tr></table></figure><p>StringBuilder转为String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><p>String转为StringBuilder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(s);</span><br></pre></td></tr></table></figure><h1 id="无法吃午餐的学生数量">1700、无法吃午餐的学生数量</h1><h2 id="方法一队列">方法一、队列</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626763.png" alt="image-20221019105203982" /><figcaption aria-hidden="true">image-20221019105203982</figcaption></figure><p>使用队列进行判断，容易想到。</p><h2 id="方法二优化-1">方法二、优化</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626764.png" alt="image-20221019105321277" /><figcaption aria-hidden="true">image-20221019105321277</figcaption></figure><p>披萨和学生数量相同，所以不会出现披萨没了学生还有的情况。</p><p>所以除了会因为卡在第一个披萨的情况而结束，就只可能是成功的状态而结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countStudents</span><span class="params">(<span class="type">int</span>[] students, <span class="type">int</span>[] sandwiches)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];    <span class="comment">//记录学生的0和1的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;students.length;i++) &#123;</span><br><span class="line">            nums[students[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sandwiches.length;i++) &#123;</span><br><span class="line">            nums[sandwiches[i]]--;</span><br><span class="line">            <span class="keyword">if</span> (nums[sandwiches[i]]==-<span class="number">1</span>) &#123;    <span class="comment">//表示本来就只有0个学生要这种披萨，但是目前披萨的第一个就是这种，所以在这里会卡住</span></span><br><span class="line">                <span class="keyword">return</span> sandwiches.length - i;    <span class="comment">//包含当前i</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//披萨和学生数量相同，所以不会出现披萨没了学生还有的情况。</span></span><br><span class="line">        <span class="comment">//所以除了会因为卡在第一个披萨的情况而结束，就只可能是成功的状态而结束</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="放置盒子">1739、放置盒子🌟</h1><blockquote><p>题解：<a href="https://leetcode.cn/problems/building-boxes/solutions/2031813/mei-xiang-ming-bai-yi-ge-dong-hua-miao-d-8vbe/">放置盒子</a></p></blockquote><h2 id="方法一数学找规律">方法一、数学找规律</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626803.png" alt="Pasted image 20221225135724" /><figcaption aria-hidden="true">Pasted image 20221225135724</figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626804.png" alt="Pasted image 20221225135834" /><figcaption aria-hidden="true">Pasted image 20221225135834</figcaption></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumBoxes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//底面数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//层数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//每层的数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            cs += i;</span><br><span class="line">            sum += cs;</span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">                res = i*(i+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">                sum -= cs;</span><br><span class="line">                c = i-<span class="number">1</span>;</span><br><span class="line">                res = c*(c+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c+<span class="number">1</span>;j++) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;</span><br><span class="line">                res += j;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">                res += j;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法-2开平方和开立方优化">方法 2、开平方和开立方优化</h2><p>详细看题解，不太会写……</p><h1 id="找到最高海拔">1732、找到最高海拔</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626805.png" alt="Screenshot_20221119_004204_com.huawei.browser" /><figcaption aria-hidden="true">Screenshot_20221119_004204_com.huawei.browser</figcaption></figure><p>简单题，没啥意思～</p><h1 id="删除字符串两端相同字符后的最短长度">1750. 删除字符串两端相同字符后的最短长度</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626806.png" alt="Pasted image 20221228112432" /><figcaption aria-hidden="true">Pasted image 20221228112432</figcaption></figure><p>很简单的题目，意义不大。</p><h1 id="检查数组是否经排序和轮转得到">1752、检查数组是否经排序和轮转得到</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626807.png" alt="Pasted image 20221127015201" /><figcaption aria-hidden="true">Pasted image 20221127015201</figcaption></figure><p>简单题，循环查数组，实现起来比较巧妙，判断是否有两个增区间，如果有则比较首位的大小；如果多于 2 个增区间，那就错；如果只有一个增区间，那就对。</p><h1 id="移除石子的最大得分">1753. 移除石子的最大得分</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626808.png" alt="Pasted image 20221221110600" /><figcaption aria-hidden="true">Pasted image 20221221110600</figcaption></figure><p>比较简单的一题，一共就三个数，每次动态选取最大的两个减 1 即可。</p><h1 id="构造字典序最大的合并字符串">1754、构造字典序最大的合并字符串⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626809.png" alt="Pasted image 20221224152639" /><figcaption aria-hidden="true">Pasted image 20221224152639</figcaption></figure><p>本题考查对 String 的 compareTo 的灵活运用，需要熟知 compareTo 的核心。compareTo 可以比较两个字符串，字典序和长度都会影响结果。</p><p>本题不能按照字符单独比较，因为如果出现：</p><blockquote><p>b a a b b a a a 按照字符比较，是 b a a b b a a a；但是正确的答案应该是 b b a a b a a a。</p></blockquote><p>因此只能用 compareTo 进行比较。每次提取较大的那个字符串的第一个字符，再继续比较，这样既考虑了大小比较，又考虑了上述例子中的情况。</p><blockquote><p>按照 compareTo 的情况： 分别出现：b (1) b (2) a (1) a (1) b (1) a (2) a (2) a (2)</p></blockquote><p>详细代码如下，代码不难，思想难：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestMerge</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> word1.length(), n2 = word2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i&lt;n1 &amp;&amp; j&lt;n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.substring(i).compareTo(word2.substring(j))&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sb.append(word1.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(word2.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;n1) &#123;</span><br><span class="line">            sb.append(word1.substring(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;n2) &#123;</span><br><span class="line">            sb.append(word2.substring(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="统计同构子字符串的数目">1759、统计同构子字符串的数目</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626810.png" alt="Pasted image 20221226002129" /><figcaption aria-hidden="true">Pasted image 20221226002129</figcaption></figure><p>简单题，注意 long 的定义和相加。</p><blockquote><p><code>res +=  (long)(i-start)*(i-start+1)/2%MOD;</code></p></blockquote><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countHomogenous</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// zzzzz</span></span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;    <span class="comment">//记录start</span></span><br><span class="line">            <span class="keyword">if</span> (sc[i]==sc[start]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res +=  (<span class="type">long</span>)(i-start)*(i-start+<span class="number">1</span>)/<span class="number">2</span>%MOD;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += (<span class="type">long</span>)(n-start)*(n-start+<span class="number">1</span>)/<span class="number">2</span>%MOD;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="袋子里最少数目的球">1760、袋子里最少数目的球⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626811.png" alt="Pasted image 20221220135905" /><figcaption aria-hidden="true">Pasted image 20221220135905</figcaption></figure><p>二分法，思路较难。</p><p>题目想要求得<strong>最小的最大值</strong>，这很容易想到<strong>二分法</strong>。但是二分法要怎么用呢，这里就是二分遍历。每次找到一个数，如果它成立则往一边二分，否则往另一边二分。</p><p>观察题目发现，在只有“操作至多 maxOperations 次”这么一个条件的限制下，很难把握把袋子平均分成几份才是最好的。所以我们考虑人为增加一个条件，即“每个袋子至多有 y 个球”。</p><p>此时问题便转化成了“<strong>给定 maxOperations 次操作次数，能否可以使得单个袋子里球数目的最大值不超过 y</strong>”。</p><p>从 1 和 nums 数组的最大值之间二分。如果 y 可以实现，我们尝试继续压低 y，即将 right 更新为 y-1，然后继续二分；如果 y 不能实现，我们将 y 提高，即将此时 left 更新为 y+1，然后继续二分。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumSize</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> maxOperations)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (left + right)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">                opt += (num-<span class="number">1</span>) / r;     <span class="comment">//如果刚好满足r，那么就不用分袋子了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (opt&gt;maxOperations) &#123;</span><br><span class="line">                left = r+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="通过连接另一个数组的子数组得到一个数组">1764. 通过连接另一个数组的子数组得到一个数组⭐⭐</h1><h2 id="方法一kmp">方法一、KMP⭐</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303131131903.png" /></p><p>经典 KMP，考察的就是 KMP 的计算和 next 数组的构建。</p><blockquote><p>KMP 算法的实现步骤其实就是：text（长） 和 pattern（短） 数组进行匹配，当在 <code>text[i]</code> 和 <code>pattern[j]</code> 位置发生了第一次的不相同，但是可以清楚 <code>pattern[0]~pattern[j-1]</code> 的位置和 <code>text[j]</code> 往前 <code>j</code> 个元素都是相同的。KMP 要求 <code>i</code> 不动，但 <code>j</code> 要进行移动到 <code>new_j</code>，使得 <code>pattern[0]~pattern[new_j]</code> 与 <code>text[i]</code> 前 <code>new_j</code> 个元素完全相等。</p><p>现在如何从 <code>j</code> 找到这个 <code>new_j</code> 就是新的问题。所以需要构建一个 next 数组，假设 <code>new_j=next[j]</code> ，那么 <code>0~new_j-1</code> 间的 <code>new_j</code> 个元素与 <code>j</code> 之前的 <code>new_j</code> 个元素都完全相同。此时可以直接比较 <code>text[i]</code> 和 <code>next[new_j]</code>，这表示已经匹配成功 <code>new_j</code> 个元素了。</p></blockquote><blockquote><p>注意：next 数组的长度和 group 的长度一致。默认 <code>next[0]=-1</code>，每一个<code>next[j]</code> 是为了求出 <code>next[j+1]</code>。</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] GetNext(<span class="type">int</span>[] group) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> group.length;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, t = next[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (j&lt;n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t==-<span class="number">1</span> || group[t]==group[j]) &#123;</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="comment">// System.out.println(j);</span></span><br><span class="line">                next[j] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t = next[t];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] group, <span class="type">int</span> start)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] next = GetNext(group);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, m = group.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start&lt;n &amp;&amp; j&lt;m) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j==-<span class="number">1</span> || nums[start]==group[j]) &#123;</span><br><span class="line">                start++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j==m) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;    <span class="comment">//下一个数组的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canChoose</span><span class="params">(<span class="type">int</span>[][] groups, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] group : groups) &#123;</span><br><span class="line">            start = KMP(nums, group, start);</span><br><span class="line">            <span class="keyword">if</span> (start == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="所有子字符串美丽值之和">1781、所有子字符串美丽值之和</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626812.png" alt="Pasted image 20221224200703" /><figcaption aria-hidden="true">Pasted image 20221224200703</figcaption></figure><p>暴力解法。循环固定左端和右端，再遍历这一段，找到最大和最小出现的次数，加入 res，3 个嵌套 for。意义不大。</p><h1 id="检查二进制字符串字段">1784、检查二进制字符串字段</h1><h2 id="方法一正常思路">方法一、正常思路</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626765.png" alt="image-20221003091100144" /><figcaption aria-hidden="true">image-20221003091100144</figcaption></figure><h2 id="方法二一行代码">方法二、一行代码</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626766.png" alt="image-20221003091323854" /><figcaption aria-hidden="true">image-20221003091323854</figcaption></figure><p>本题可以转化为只能出现一次<code>10</code>，也就是只能出现111111000000这种情况。</p><h1 id="构成特定和需要添加的最少元素">1785. 构成特定和需要添加的最少元素</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303130848990.png" /></p><p>虽然是中等题，但是很简单。只需要分类讨论：</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303130849378.jpg" alt="2191a50b89ff4f95a40b9bad3641d54.jpg" /><figcaption aria-hidden="true">2191a50b89ff4f95a40b9bad3641d54.jpg</figcaption></figure><p>根据规律，不难发现，其实只要将 dis 都转为正数，循环与 limit 比较即可。或者直接进行除法操作，注意存在什么都不用操作的可能。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minElements</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> limit, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            dis += n;</span><br><span class="line">        &#125;</span><br><span class="line">        dis = Math.abs(dis-goal);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)((dis + limit - <span class="number">1</span>) / limit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="仅执行一次字符串交换能否使两个字符串相等">1790、仅执行一次字符串交换能否使两个字符串相等</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626767.png" alt="image-20221011221427327" /><figcaption aria-hidden="true">image-20221011221427327</figcaption></figure><p>思路简单，不多说了。</p><h1 id="最大平均通过率">1792. 最大平均通过率⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302201059163.png" /></p><p>中等题，但是不太好想，如果有思路就会很简单。</p><p>首先我考虑的时背包问题，但是一顿操作后并不能实现。根据 <a href="https://leetcode.cn/problems/maximum-average-pass-ratio/solutions/2119717/python3javacgo-yi-ti-yi-jie-you-xian-dui-qrmo/">题解</a>，转换了思路，每次加一个学生，选择增量最大的确定永久增加，循环判断即可。</p><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302201102769.png" /></p><p>这里考察<a href="LeetCode总结笔记.md#大根堆">大根堆</a>的构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxAverageRatio</span><span class="params">(<span class="type">int</span>[][] classes, <span class="type">int</span> extraStudents)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> classes.length;</span><br><span class="line">        PriorityQueue&lt;<span class="type">double</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;<span class="type">double</span>[]&gt;((a,b) -&gt; &#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> (a[<span class="number">0</span>]+<span class="number">1</span>)/(a[<span class="number">1</span>]+<span class="number">1</span>) - a[<span class="number">0</span>]/a[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> (b[<span class="number">0</span>]+<span class="number">1</span>)/(b[<span class="number">1</span>]+<span class="number">1</span>) - b[<span class="number">0</span>]/b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> Double.compare(y, x);     <span class="comment">//如果后面的增量比前面的增量大，那么返回正值，则调换顺序</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] cl : classes) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;(<span class="type">double</span>)cl[<span class="number">0</span>],(<span class="type">double</span>)cl[<span class="number">1</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;extraStudents;i++) &#123;    </span><br><span class="line">            <span class="type">double</span>[] temp = q.poll();</span><br><span class="line">            temp[<span class="number">0</span>]++;</span><br><span class="line">            temp[<span class="number">1</span>]++;</span><br><span class="line">            q.offer(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">double</span>[] temp = q.poll();</span><br><span class="line">            res += temp[<span class="number">0</span>]/temp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res/c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="tips-1">tips</h2><p>double 元素比较大小，使用 <code>Double.compare(x,y)</code>，如果 <code>x&gt;y</code> 则返回正数，如果 <code>y&gt;x</code> 则返回负数。</p><h1 id="设计一个验证系统">1797. 设计一个验证系统</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302121226049.png" /></p><p>普通工程题，意义不大。</p><p>注意：hashmap 在 put 时如果有相同 key，value 会进行覆盖。</p><h1 id="你能构造出连续值的最大数目">1798. 你能构造出连续值的最大数目⭐</h1><h2 id="方法一动态规划贪心算法">方法一、动态规划+贪心算法</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302042351940.png" /></p><p>利用动态规划的思想。先使 coins 升序，我们假设 res 之前的数（连续的）都能凑出来，那么在考察 res 时，如果 coins[i] 能小于 res，那么 coins[i] 加上 res-coins[i] 就可以构造出来 res，其中 res-coins[i] 是一定能构造出来的；如果 coins[i]大于 res，那么没有办法通过加上什么数达到当前需要的 res。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaximumConsecutive</span><span class="params">(<span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        Arrays.sort(coins);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c&gt;res) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="n-次操作后的最大分数和">1799. N 次操作后的最大分数和⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626814.png" alt="Pasted image 20221222132834" /><figcaption aria-hidden="true">Pasted image 20221222132834</figcaption></figure><p><strong>动态规划+位运算压缩存储</strong></p><p>难题!!!</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626815.png" alt="Pasted image 20221222133224" /><figcaption aria-hidden="true">Pasted image 20221222133224</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcd(y, x%y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxScore</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造最大公约数矩阵</span></span><br><span class="line">        <span class="type">int</span>[][] gcdmap = <span class="keyword">new</span> <span class="title class_">int</span>[l][l];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;l;j++) &#123;</span><br><span class="line">                gcdmap[i][j] = gcd(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造res向量，下标i表示位运算中已经包含的值的最大结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; l;     <span class="comment">//一共l个数，则1后面l个0。len的十进制所表示的是多个元素的组合</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示res的下标从0（还没有一个元素进行判断），到二进制全是1（表示所有元素都判断完了）（res[len-1]就是我们要的最终结果）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>;k&lt;len;k++) &#123;      </span><br><span class="line">            <span class="comment">//对k中的任意一对数据拿出来，比较res[k]和没有这对数据时的res+这对数据的得分的最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> Integer.bitCount(k);     <span class="comment">//判断k的二进制由多少个1组成</span></span><br><span class="line">            <span class="keyword">if</span> (cnt%<span class="number">2</span>==<span class="number">0</span>) &#123;     <span class="comment">//偶数个1，表示成对的，那么可以进行判断</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;l;i++) &#123;     <span class="comment">//i表示第一个数是从nums[0]到nums[i-1]</span></span><br><span class="line">                    <span class="keyword">if</span> (((k&gt;&gt;i) &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;     <span class="comment">//如果第i个数据是在这个k中的</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;l;j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (((k&gt;&gt;j) &amp; <span class="number">1</span>) ==<span class="number">1</span>) &#123;     <span class="comment">//i和j两个数据都在k中，可以按照计划进行判断</span></span><br><span class="line">                                res[k] = Math.max(res[k],res[k^(<span class="number">1</span>&lt;&lt;i)^(<span class="number">1</span>&lt;&lt;j)]+cnt/<span class="number">2</span>*gcdmap[i][j]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res[len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大升序子数组和">1800、最大升序子数组和</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626768.png" alt="image-20221007095515941" /><figcaption aria-hidden="true">image-20221007095515941</figcaption></figure><p>思路简单，只要判断当前值是否比上一个值大，如果大，那以当前值结尾的最大升序子数组和 = 以上一个值为结尾的最大升序子数组和 + 当前值的大小。否则值为本身。</p><h1 id="积压订单中的订单总数">1801、积压订单中的订单总数</h1><h2 id="方法一hashmap-搜索arraylist-排序">方法一、HashMap 搜索+ArrayList 排序</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626816.png" alt="Pasted image 20230102130246" /><figcaption aria-hidden="true">Pasted image 20230102130246</figcaption></figure><p>思路比较简单，设置两个 hash 和两个 list，list 用来存储值，分别从小到大排序和从大到小排序，hash 可以根据 list 的值作为 key 查到对应的数量，再进行处理。涉及的 Java 基础语法比较多。</p><blockquote><p>需要注意 <code>(int)(res%MOD)</code> 才是正确的返回，<code>(int)res%MOD</code> 不对。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNumberOfBacklogOrders</span><span class="params">(<span class="type">int</span>[][] orders)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; buy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; sell = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; buylist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();    <span class="comment">//从大到小</span></span><br><span class="line">        ArrayList&lt;Integer&gt; selllist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();   <span class="comment">//从小到大</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//buy大于sell才能抵消</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] or : orders) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (or[<span class="number">2</span>]==<span class="number">0</span>) &#123;    <span class="comment">//表示buy采购，要找到小于等于它的最小的sell</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 or[0]&gt;=selllist.get(0) &amp;&amp; or[1]&gt;0，可以进行判断</span></span><br><span class="line">                <span class="comment">// 如果只满足 or[0]&gt;=selllist.get(0) 但不满足 or[1]&gt;0，直接退出</span></span><br><span class="line">                <span class="comment">// 如果只满足 or[1]&gt;0 但不满足 or[0]&gt;=selllist.get(0)，直接退出</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (selllist.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (or[<span class="number">0</span>]&gt;=selllist.get(<span class="number">0</span>) &amp;&amp; or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> selllist.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> sell.get(key);      <span class="comment">//当前sell值得数量</span></span><br><span class="line">                        <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;=value) &#123;    <span class="comment">//如果要加入的buy的值数量大于等于sell最小值的数量</span></span><br><span class="line">                            or[<span class="number">1</span>] -= value;</span><br><span class="line">                            <span class="comment">//将sell和selllist都删除对应的数据</span></span><br><span class="line">                            sell.remove(key);</span><br><span class="line">                            selllist.remove(<span class="number">0</span>);      <span class="comment">//可以进行接下来的判断 </span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            sell.replace(key,value-or[<span class="number">1</span>]);   <span class="comment">//更新sell散列表中的对应关系</span></span><br><span class="line">                            or[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;    <span class="comment">//只有当or[1]&gt;0时，表示现有的sell中没有比当前buy小的值了</span></span><br><span class="line">                    buy.put(or[<span class="number">0</span>],(buy.getOrDefault(or[<span class="number">0</span>],<span class="number">0</span>)+or[<span class="number">1</span>])%MOD);     <span class="comment">//如果原本就有这个值，那么取原来的值加上现在的值；如果原来没有，则设置初始值default为0再加上现在的值。</span></span><br><span class="line">                    buylist.add(or[<span class="number">0</span>]);</span><br><span class="line">                    Collections.sort(buylist, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;    <span class="comment">//升序排序</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer n1, Integer n2)</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> n2-n1;   <span class="comment">//如果return&gt;0则需要对调</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;        <span class="comment">//表示sell采购，要找到大于等于它的最大的buy</span></span><br><span class="line">                <span class="keyword">while</span> (buylist.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (or[<span class="number">0</span>]&lt;=buylist.get(<span class="number">0</span>) &amp;&amp; or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> buylist.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buy.get(key);      <span class="comment">//当前sell值得数量</span></span><br><span class="line">                        <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;=value) &#123;   </span><br><span class="line">                            or[<span class="number">1</span>] -= value;</span><br><span class="line">                            buy.remove(key);</span><br><span class="line">                            buylist.remove(<span class="number">0</span>); </span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            buy.replace(key,value-or[<span class="number">1</span>]);</span><br><span class="line">                            or[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (or[<span class="number">1</span>]&gt;<span class="number">0</span>) &#123; </span><br><span class="line">                    sell.put(or[<span class="number">0</span>],(sell.getOrDefault(or[<span class="number">0</span>],<span class="number">0</span>)+or[<span class="number">1</span>])%MOD);</span><br><span class="line">                    selllist.add(or[<span class="number">0</span>]);</span><br><span class="line">                    Collections.sort(selllist);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// System.out.println(&quot;=================buy====================&quot;);</span></span><br><span class="line">            <span class="comment">// System.out.print(buy.keySet());</span></span><br><span class="line">            <span class="comment">// System.out.println(buy.values());</span></span><br><span class="line">            <span class="comment">// System.out.println(&quot;=================sell====================&quot;);</span></span><br><span class="line">            <span class="comment">// System.out.print(sell.keySet());</span></span><br><span class="line">            <span class="comment">// System.out.println(sell.values());</span></span><br><span class="line">            <span class="comment">// System.out.println();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : sell.values()) &#123;</span><br><span class="line">            res += (<span class="type">long</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : buy.values()) &#123;</span><br><span class="line">            res += (<span class="type">long</span>)num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二题解">方法二、题解🐶</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626817.png" alt="Pasted image 20230102131042" /><figcaption aria-hidden="true">Pasted image 20230102131042</figcaption></figure><p><a href="https://leetcode.cn/problems/number-of-orders-in-the-backlog/solutions/2041077/by-lcbin-vf1s/">题解</a></p><h1 id="有界数组中指定下标处的最大值">1802. 有界数组中指定下标处的最大值</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626818.png" alt="Pasted image 20230104230948" /><figcaption aria-hidden="true">Pasted image 20230104230948</figcaption></figure><p>根据题目要求，其实只要从 index 左右递减，每次减少 1，如果还有多余的空位，全部设置为 1 即可。（getsum ()) 函数）</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626819.png" alt="0631e4632dfc62297ea12dadffdee8a" /><figcaption aria-hidden="true">0631e4632dfc62297ea12dadffdee8a</figcaption></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getsum</span><span class="params">(<span class="type">long</span> x, <span class="type">int</span> len)</span> &#123;     <span class="comment">//注意x必须是long，否则会在下面的乘法中越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; len) &#123;     <span class="comment">//有多余的1</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>)((<span class="number">1</span>+x)*x/<span class="number">2</span> + (len-x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">long</span>)((x-len+<span class="number">1</span>+x)*len/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> index, <span class="type">int</span> maxSum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">llen</span> <span class="operator">=</span> index + <span class="number">1</span>, rlen = n - index;       <span class="comment">//这里的长度是包括当前mid的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = maxSum;     <span class="comment">//right设置为maxsum，不能是n（nums.length）</span></span><br><span class="line">        <span class="comment">//找满足条件的最大的</span></span><br><span class="line">        <span class="comment">//需要在当前满足条件的前提下，不断右移，需要left存储最后一个判断成功的满足条件的</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right + <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((getsum(mid,llen)+getsum(mid,rlen)-mid)&lt;=maxSum) &#123;     <span class="comment">//注意需要减去重复加上的mid值</span></span><br><span class="line">                left = mid;    <span class="comment">//left不断存储成功的最大的值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="还原排列的最少操作步数">1806、还原排列的最少操作步数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626820.png" alt="Pasted image 20230109015856" /><figcaption aria-hidden="true">Pasted image 20230109015856</figcaption></figure><p>中等题，通过列举多个情况找规律即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reinitializePermutation</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (loc*<span class="number">2</span>&gt;=<span class="number">1</span> &amp;&amp; loc*<span class="number">2</span>&lt;n-<span class="number">1</span>) &#123;</span><br><span class="line">                loc = loc * <span class="number">2</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                loc = (loc * <span class="number">2</span> - n) + <span class="number">1</span>;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span> (loc!=<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="替换字符串中的括号内容">1807. 替换字符串中的括号内容</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626821.png" alt="Pasted image 20230112200229" /><figcaption aria-hidden="true">Pasted image 20230112200229</figcaption></figure><p>hash 的和 stringbuidler 的结合应用。比较简单~</p><h2 id="句子相似性-iii">1813、句子相似性 III⭐</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626822.png" alt="Pasted image 20230116024951" /><figcaption aria-hidden="true">Pasted image 20230116024951</figcaption></figure><p>简单但是需要考虑的比较多的题目。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isCon</span><span class="params">(String s1,String s2)</span> &#123;    <span class="comment">//判断s2是否包含在s1中且符合条件</span></span><br><span class="line">        String[] str1 = s1.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        String[] str2 = s2.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> str2.length;     <span class="comment">//n1一定大于n2</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (str1[i].equals(str2[i])) &#123;     <span class="comment">//说明最左边匹配成功</span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n2;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!str1[i].equals(str2[i])) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i==n2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//左匹配</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n1-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> n2-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str1[j].equals(str2[t])) &#123;        <span class="comment">//说明最右边匹配成功</span></span><br><span class="line">            <span class="keyword">for</span> (j=n1-<span class="number">1</span>,t=n2-<span class="number">1</span>;t&gt;=i;t--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!str1[j].equals(str2[t])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i==t+<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;             </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areSentencesSimilar</span><span class="params">(String sentence1, String sentence2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> sentence1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> sentence2.length();</span><br><span class="line">        <span class="keyword">if</span> (n1&lt;n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> isCon(sentence2,sentence1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n1&gt;n2) &#123;</span><br><span class="line">            <span class="keyword">return</span> isCon(sentence1,sentence2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sentence1.equals(sentence2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="统计一个数组中好对子的数目">1814. 统计一个数组中好对子的数目</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626823.png" alt="Pasted image 20230117122523" /><figcaption aria-hidden="true">Pasted image 20230117122523</figcaption></figure><p>比较难想也比较难操作的一题。核心思路：</p><p><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code> 与 <code>nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</code> 等价</p><p>此外，还需要注意在乘法时 long 的乘法，(long) 只能将紧跟着的变量或者括号强制转化为 long，如果后面跟的是括号，括号里的内容会先按照原来类型进行运算，再强转。</p><p><strong>所以：<code>res = (res + (long)((i-left)*(i-left-1)/2)%MOD);</code> 可能会越界，但是 <code>res = (res + (long)(i-left)*(i-left-1)/2)%MOD;</code> 不会</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rev</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            res = res * <span class="number">10</span> + n%<span class="number">10</span>;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNicePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(rev(nums[i]));</span></span><br><span class="line">            nums[i] = nums[i] - rev(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(nums[i]);</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[left]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-left &gt; <span class="number">1</span>) &#123;   <span class="comment">//不止一个数，能为数对</span></span><br><span class="line">                    res = (res + (<span class="type">long</span>)(i-left)*(i-left-<span class="number">1</span>)/<span class="number">2</span>)%MOD;     <span class="comment">//下标为3 4 5 6 7，实际上相同是4个，也就是3 4 5 6，一共有3+2+1对，即(1+3)*3/2</span></span><br><span class="line">                &#125;</span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != n-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(n);</span></span><br><span class="line">            res = (res + (<span class="type">long</span>)(n-left)*(n-left-<span class="number">1</span>)/<span class="number">2</span>)%MOD;   <span class="comment">//下标为6 7 (8)，实际上相同是2个，也就是6 7, 一共1对，即(1+(2-1))*(2-1)/2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(res%MOD);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找用户活跃分钟数">1817. 查找用户活跃分钟数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626824.png" alt="Pasted image 20230120125215" /><figcaption aria-hidden="true">Pasted image 20230120125215</figcaption></figure><p>虽然是中等题，但是很简单，只要注意使用<a href="LeetCode总结笔记.md#数组#自定义排序">数组的自定义排序</a>即可。</p><h1 id="序列中不同最大公约数的数目">1819. 序列中不同最大公约数的数目⭐</h1><p>困难题，原本思路是使用 list 和 hashmap 对 nums 的每对元素求最大公约数，但是超时。此方法不可行。注意：根据题目要求，每个单独的元素也算答案。</p><p><strong>0 和任何数 x 的最大公约数都是 x</strong></p><h2 id="方法一枚举">方法一、枚举</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626825.png" alt="Pasted image 20230114133455" /><figcaption aria-hidden="true">Pasted image 20230114133455</figcaption></figure><p>需要转换思路，枚举以 i 为因子的所有数，如果有 2 个或 2 个以上的数存在，判断这些数的最大公约数是不是 i，如果是，那么 res++。注意，每个单独元素也算答案。</p><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gys</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDifferentSubsequenceGCDs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] ishas = <span class="keyword">new</span> <span class="title class_">boolean</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            ishas[n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max;i++) &#123;     <span class="comment">//公约数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=max;j=j+i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ishas[j]) &#123;</span><br><span class="line">                    g = gys(j,g);      <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g==i) &#123;    <span class="comment">//表示满足存在2个或2个以上的数，使得i作为最大公约数</span></span><br><span class="line">                res++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二枚举优化">方法二、枚举优化</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626826.png" alt="Pasted image 20230114133600" /><figcaption aria-hidden="true">Pasted image 20230114133600</figcaption></figure><p>在嵌套的 for 的判断中增加：<code>g!=i</code>，这表示如果出现 <code>g==i</code> 的情况，也就是出现 2 个或 2 个以上的数，使得 i 作为最大公约数，那么直接可以跳出循环，返回 i。</p><p>详细代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gys</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (b!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a%b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDifferentSubsequenceGCDs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[nums.length-<span class="number">1</span>];</span><br><span class="line">        <span class="type">boolean</span>[] ishas = <span class="keyword">new</span> <span class="title class_">boolean</span>[max+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            ishas[n] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max;i++) &#123;     <span class="comment">//公约数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i;j&lt;=max &amp;&amp; g!=i;j=j+i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ishas[j]) &#123;</span><br><span class="line">                    g = gys(j,g);      <span class="comment">//</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (g==i) &#123;    <span class="comment">//表示满足存在2个或2个以上的数，使得i作为最大公约数</span></span><br><span class="line">                res++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三最强优化">方法三、最强优化</h2><p><a href="https://leetcode.cn/problems/number-of-different-subsequences-gcds/solutions/2061079/ji-bai-100mei-ju-gcdxun-huan-you-hua-pyt-get7/">1819题解</a></p><h1 id="数组元素积的符号">1822、数组元素积的符号</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626769.png" alt="image-20221027101133285" /><figcaption aria-hidden="true">image-20221027101133285</figcaption></figure><p>简单模拟题……</p><h1 id="最少侧跳次数">1824. 最少侧跳次数⭐</h1><h2 id="方法一动态规划二维">方法一、动态规划（二维）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626827.png" alt="Pasted image 20230121124109" /><figcaption aria-hidden="true">Pasted image 20230121124109</figcaption></figure><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626828.png" alt="Pasted image 20230121124138" /><figcaption aria-hidden="true">Pasted image 20230121124138</figcaption></figure><p>简而言之，在 i 点的 j 跑道上的最小侧翻次数来源于两个值，<strong>一个是 i-1 点的 j 跑道，另一个是 i 点的其他跑道。</strong> 这里需要注意，在求 i 点的其他跑道的值的时候，这些值也是来源于 i-1 点的相应的跑道，所以需要分为两步进行，先计算由 i-1 点的 j 跑道计算得到的，再计算由 i 点的其他跑道计算得到的。i 点的其他跑道实际上就是 i 点所有跑道的 dp 最小值。</p><p>详细代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSideJumps</span><span class="params">(<span class="type">int</span>[] obstacles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacles.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> n+<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">//从上一个点到这个点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]==j+<span class="number">1</span>) &#123;    <span class="comment">//表示有石头</span></span><br><span class="line">                    dp[i][j] = MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min_step</span> <span class="operator">=</span> Math.min(dp[i][<span class="number">0</span>],Math.min(dp[i][<span class="number">1</span>],dp[i][<span class="number">2</span>]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]!=j+<span class="number">1</span>) &#123;    <span class="comment">//表示没有石头</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j],min_step+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[n-<span class="number">1</span>][<span class="number">0</span>],Math.min(dp[n-<span class="number">1</span>][<span class="number">1</span>],dp[n-<span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二动态规划优化一维">方法二、动态规划优化（一维）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626829.png" alt="Pasted image 20230121125056" /><figcaption aria-hidden="true">Pasted image 20230121125056</figcaption></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSideJumps</span><span class="params">(<span class="type">int</span>[] obstacles)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacles.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> n+<span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="comment">//从上一个点到这个点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]==j+<span class="number">1</span>) &#123;    <span class="comment">//表示有石头</span></span><br><span class="line">                    dp[j] = MAX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min_step</span> <span class="operator">=</span> Math.min(dp[<span class="number">0</span>],Math.min(dp[<span class="number">1</span>],dp[<span class="number">2</span>]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacles[i]!=j+<span class="number">1</span>) &#123;    <span class="comment">//表示没有石头</span></span><br><span class="line">                    dp[j] = Math.min(dp[j],min_step+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[<span class="number">0</span>],Math.min(dp[<span class="number">1</span>],dp[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="统计一个圆中点的数目">1828. 统计一个圆中点的数目</h1><h2 id="方法一暴力-1">方法一、暴力</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626830.png" alt="Pasted image 20230124124708" /><figcaption aria-hidden="true">Pasted image 20230124124708</figcaption></figure><p>意义不大的中等题。</p><h2 id="方法二压缩搜索">方法二、压缩搜索</h2><p><a href="https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/solutions/1531794/by-mumuxinfei-shnh/?topicTags=er-fen">1828题解</a></p><h1 id="句子相似性iii">1913、句子相似性III</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626770.png" alt="image-20221009155406386" /><figcaption aria-hidden="true">image-20221009155406386</figcaption></figure><p>对于题目只有三种情况：</p><ol type="1"><li><p>A......</p><p>A</p></li><li><p>......A</p><p>​ A</p></li><li><p>A......B</p><p>AB</p></li></ol><p>首先要确定谁是长的句子，谁是短的句子。</p><p>可以从第一个单词进行匹配，如果匹配上了，说明一定是1、3情况，如果遇到匹配不成功的，则从各自的最后一个单词进行匹配，如果最后两个指针遇上了，则说明成立。结束的条件是短的字符串的做指针和右指针能遇上（i = t + 1）。具体思路可以看代码，更容易懂。</p><h1 id="寻找图中是否存在路径">1971. 寻找图中是否存在路径</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626831.png" alt="Pasted image 20221219132739" /><figcaption aria-hidden="true">Pasted image 20221219132739</figcaption></figure><p>典型 <a href="LeetCode总结笔记.md#并查集">并查集</a>题目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] bc, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bc[x]!=x) &#123;     <span class="comment">//如果自己不是根</span></span><br><span class="line">            bc[x] = find(bc,bc[x]);     <span class="comment">//将一条线上的所有的都变成直连根</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bc[x];    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] bc, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (find(bc,x)==find(bc,y)) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            bc[find(bc,x)] = find(bc,y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPath</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> source, <span class="type">int</span> destination)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] bc = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            bc[i] = i;     <span class="comment">// 初始每个节点的根就是自己</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;edges.length;i++) &#123;</span><br><span class="line">            union(bc,edges[i][<span class="number">0</span>],edges[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i=0;i&lt;n;i++) &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(bc[i]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (find(bc,source)==find(bc,destination)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="执行操作后的变量值">2011. 执行操作后的变量值</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626832.png" alt="Pasted image 20221223105336" /><figcaption aria-hidden="true">Pasted image 20221223105336</figcaption></figure><p>简单题，没意思~</p><h1 id="增量元素之间的最大差值">2016、增量元素之间的最大差值</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626771.png" alt="image-20221009153057630" /><figcaption aria-hidden="true">image-20221009153057630</figcaption></figure><p>本题思路很巧妙，目的是求一对升序的两个数，而且是差值最大的。</p><p>可以将左端点定为左边第一个数，开始遍历。</p><p>如果右边的某个值比左端点大，则记录他们之间的差值，并和已经保存的差值比较，保存更大的那个。</p><p>如果右边的某个值比左端点小，那么这个值就成为了新的左端点，然后再继续遍历。</p><blockquote><p>比如 3...9...2...10</p><p>以3作为左端点的时候，当遇到9时，res = 6</p><p>再往后遍历遇到比左端点3更小的2，那么更小左端点为2，继续往后遍历，遇到更大的10，发现差值为8，比6大，则更新res = 8</p></blockquote><h1 id="转换字符串的最少操作次数">2027. 转换字符串的最少操作次数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626833.png" alt="Pasted image 20221227115342" /><figcaption aria-hidden="true">Pasted image 20221227115342</figcaption></figure><p>简单题，不多说。</p><h1 id="链表最大孪生和">2130、链表最大孪生和</h1><h2 id="方法一常规遍历数组">方法一、常规遍历+数组</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626772.png" alt="image-20221014091817803" /><figcaption aria-hidden="true">image-20221014091817803</figcaption></figure><p>对链表遍历两次，第一次记录长度n；构建一个n/2长度的数据，第二次遍历的前一半直接放在数组中，后一半对数组从后往前分别加上，最后取得数组的最大值。</p><h2 id="方法二双端队列">方法二、双端队列</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626773.png" alt="image-20221014092114561" /><figcaption aria-hidden="true">image-20221014092114561</figcaption></figure><p>遍历一次链表，将所有的数值都按顺序加入队列中。对队列进行操作，如果队列不为空<code>!dq.isEmpyt()</code>，那么每次<code>pollFirst()</code>和<code>pollLast()</code>，并相加，用max记录最大的和，最后输出。</p><h1 id="至少在两个数组中出现的值">2032. 至少在两个数组中出现的值</h1><p>简单题，但涉及到<a href="LeetCode总结笔记.md#动态数组">动态数组</a>和<a href="LeetCode总结笔记.md#HashMap（散列表）">哈希表</a>。</p><h2 id="方法一hashmap位记录">方法一、HashMap+位记录</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626834.png" alt="Pasted image 20221229122222" /><figcaption aria-hidden="true">Pasted image 20221229122222</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">twoOutOfThree</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;(); </span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++) &#123;</span><br><span class="line">            hash.put(nums1[i], <span class="number">1</span>);     <span class="comment">//第1个有的在二进制第1位上至1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++) &#123;</span><br><span class="line">            hash.put(nums2[i], hash.getOrDefault(nums2[i],<span class="number">0</span>) | <span class="number">2</span>);   <span class="comment">//第2个有的在二进制第2位上至1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums3.length;i++) &#123;</span><br><span class="line">            hash.put(nums3[i], hash.getOrDefault(nums3[i],<span class="number">0</span>) | <span class="number">4</span>);   <span class="comment">//第3个有的在二进制第3位上至1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> ((v &amp; (v-<span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">                al.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二hashmap排序数量记录">方法二、HashMap+排序+数量记录</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626835.png" alt="Pasted image 20221229122416" /><figcaption aria-hidden="true">Pasted image 20221229122416</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">twoOutOfThree</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;(); </span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">al</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line">        Arrays.sort(nums3);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums1.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums1[i]==nums1[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums1[i], hash.getOrDefault(nums1[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums2[i]==nums2[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums2[i], hash.getOrDefault(nums2[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums3.length;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums3[i]==nums3[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(nums3[i], hash.getOrDefault(nums3[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()&gt;=<span class="number">2</span>) &#123;</span><br><span class="line">                al.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> al;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使每位学生都有座位的最少移动次数">2037. 使每位学生都有座位的最少移动次数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626836.png" alt="Pasted image 20221231002356" /><figcaption aria-hidden="true">Pasted image 20221231002356</figcaption></figure><p>简单题，只要将 seat 和 student 两个数组排序，然后对应相减取绝对值，最后相加即可。</p><h1 id="检查句子中的数字是否递增">2042. 检查句子中的数字是否递增</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626837.png" alt="Pasted image 20230103025153" /><figcaption aria-hidden="true">Pasted image 20230103025153</figcaption></figure><p>简单题，大脑清晰且认真即可。</p><h1 id="统计各位数字之和为偶数的整数个数">2180. 统计各位数字之和为偶数的整数个数</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626838.png" alt="Pasted image 20230106174004" /><figcaption aria-hidden="true">Pasted image 20230106174004</figcaption></figure><p>简单题，直接判断操作即可。</p><h1 id="统计包含给定前缀的字符串">2185. 统计包含给定前缀的字符串</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626839.png" alt="Pasted image 20230108010634" /><figcaption aria-hidden="true">Pasted image 20230108010634</figcaption></figure><p>简单题，没啥意思~</p><h1 id="按位与结果大于零的最长组合">2275、按位与结果大于零的最长组合</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626774.png" alt="image-20221009154203464" /><figcaption aria-hidden="true">image-20221009154203464</figcaption></figure><p>本题考到位运算，但是实际上思路很简单，就看能不能想到。</p><p><strong>a&amp;b什么情况下不为0？只有在某一位中全都是1的时候，他们一定是部位0的。</strong></p><p>因此，我们可以拓展到本题。</p><p>首先建立一个数组，用来记录所有数再某一位中为1的个数。（<strong>1e7&lt;2^25</strong>）</p><p>对每一个数进行遍历，如何找到这个数的每一位呢？</p><p>可以通过与00000001、00000010、00000100......进行与操作，如果结果不是0，那么就说明这一位为1。</p><p>这是一种思路，我们也可以对每个数每次与1与操作，然后右移一位，再与1与操作......（也就是题解的方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> candidates[i];</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//提取数字的每一位</span></span><br><span class="line"><span class="keyword">while</span> (num!=<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//将 1 位存起来</span></span><br><span class="line">    <span class="keyword">if</span> ((num &amp; <span class="number">1</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">        times[j]++;</span><br><span class="line">    &#125; </span><br><span class="line">    num = num &gt;&gt; <span class="number">1</span>;   <span class="comment">//每次num的二进制向右移动一位</span></span><br><span class="line">    j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后取1最多的那个值，即为次数。如果某一位的1有y个，那么说明在这n个数中一定会有y个数，他们'且'后这一位为1（即结果不为0）。</p><h1 id="判断一个数的数字计数是否等于数位的值">2283. 判断一个数的数字计数是否等于数位的值</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626840.png" alt="Pasted image 20230111004354" /><figcaption aria-hidden="true">Pasted image 20230111004354</figcaption></figure><p>简单题，利用 hash 表进行处理即可。但是要注意 int 转为 char 的相关操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+i)</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">digitCount</span><span class="params">(String num)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] nc = num.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.length();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            hash.put(nc[i], hash.getOrDefault(nc[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// hash.forEach((key,value)-&gt; &#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println(key);</span></span><br><span class="line">        <span class="comment">//     System.out.println(value);</span></span><br><span class="line">        <span class="comment">// &#125;);  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash.getOrDefault((<span class="type">char</span>)(<span class="string">&#x27;0&#x27;</span>+i),<span class="number">0</span>)!=(nc[i]-<span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重排字符形成目标字符串">2287. 重排字符形成目标字符串</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626841.png" alt="Pasted image 20230113170949" /><figcaption aria-hidden="true">Pasted image 20230113170949</figcaption></figure><p>虽然是简单题，但是本题的解题过程不简单。需要清楚的是：题目中只是要求用过的字符不能再次用，并没有说每次匹配好的那段所有的其他字符都不能用。因此只需要构造两个 hashmap，一个是用来记录 target 的每个字符出现的次数，另一个是记录 s 中在 target 的字符出现的次数，然后对应字符的次数相除，取最小值即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rearrangeCharacters</span><span class="params">(String s, String target)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tc = target.toCharArray();</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        HashMap&lt;Character,Integer&gt; hash2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> t : tc) &#123;</span><br><span class="line">            hash2.put(t,hash2.getOrDefault(t,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash2.containsKey(c)) &#123;</span><br><span class="line">                hash1.put(c,hash1.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hash1.size()!=hash2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character,Integer&gt; entry : hash2.entrySet()) &#123;  </span><br><span class="line">            <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            sum = Math.min(sum, hash1.get(key)/entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="极大极小游戏">2293、极大极小游戏</h1><p>简单题，方法很多。</p><h2 id="方法一list-操作">方法一、list 操作</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626842.png" alt="Pasted image 20230115012636" /><figcaption aria-hidden="true">Pasted image 20230115012636</figcaption></figure><p>将 nums 转为 list，之后再操作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMaxGame</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.stream(nums).boxed().collect(Collectors.toList());</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">while</span> (size!=<span class="number">1</span>) &#123;      <span class="comment">//多行的循环处理</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (size!=<span class="number">0</span>) &#123;       <span class="comment">//每一行的循环处理</span></span><br><span class="line">                <span class="keyword">if</span> (t%<span class="number">2</span>==<span class="number">1</span>) &#123;</span><br><span class="line">                    list.add(Math.min(list.get(<span class="number">0</span>),list.get(<span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(Math.max(list.get(<span class="number">0</span>),list.get(<span class="number">1</span>)));</span><br><span class="line">                &#125;</span><br><span class="line">                t++;</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">                size = size-<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            size = list.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二数组原地操作">方法二、数组原地操作</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626843.png" alt="Pasted image 20230115012800" /><figcaption aria-hidden="true">Pasted image 20230115012800</figcaption></figure><p>利用 <code>/2</code> 的特性，在原数组进行操作。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMaxGame</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">                    nums[i] = Math.min(nums[i*<span class="number">2</span>],nums[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums[i] = Math.max(nums[i*<span class="number">2</span>],nums[i*<span class="number">2</span>+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            n = n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="强密码检验器-ii">2299. 强密码检验器 II</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626844.png" alt="Pasted image 20230119130843" /><figcaption aria-hidden="true">Pasted image 20230119130843</figcaption></figure><p>简单题。注意：判断一个字符是否包含在字符串内：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.indexOf(pc[i])!=-<span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="计算应缴税款总额">2303. 计算应缴税款总额</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626846.png" alt="Pasted image 20230123154310" /><figcaption aria-hidden="true">Pasted image 20230123154310</figcaption></figure><p>简单题~遍历即可。</p><h1 id="兼具大小写的最好英文字母">2309. 兼具大小写的最好英文字母</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626847.png" alt="Pasted image 20230127125026" /><figcaption aria-hidden="true">Pasted image 20230127125026</figcaption></figure><p>虽然是简单题，但是涉及很多 java 的基础知识。比如：小写转为大写需要 <strong>-32</strong>。 详细代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greatestLetter</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Character&gt;();</span><br><span class="line">        <span class="type">char</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;sc.length;i++) &#123; </span><br><span class="line">            set.add(sc[i]);</span><br><span class="line">            <span class="keyword">if</span> (sc[i]&lt;=<span class="string">&#x27;z&#x27;</span> &amp;&amp; sc[i]&gt;=<span class="string">&#x27;a&#x27;</span>) &#123;    <span class="comment">//小写</span></span><br><span class="line">                <span class="keyword">if</span> (set.contains((<span class="type">char</span>)(sc[i]-<span class="number">32</span>))) &#123;    <span class="comment">//存在它的大写</span></span><br><span class="line">                    <span class="keyword">if</span> (res==<span class="string">&#x27; &#x27;</span> || res&lt;(<span class="type">char</span>)(sc[i]-<span class="number">32</span>)) &#123;</span><br><span class="line">                        res = (<span class="type">char</span>)(sc[i]-<span class="number">32</span>);    <span class="comment">//对比的是大写</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;     <span class="comment">//大写</span></span><br><span class="line">                <span class="keyword">if</span> (set.contains((<span class="type">char</span>)(sc[i]+<span class="number">32</span>))) &#123;    <span class="comment">//存在它的小写</span></span><br><span class="line">                    <span class="keyword">if</span> (res==<span class="string">&#x27; &#x27;</span> || res&lt;sc[i]) &#123;</span><br><span class="line">                        res = sc[i];  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res==<span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="统计星号">2315. 统计星号</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626848.png" alt="Pasted image 20230129003138" /><figcaption aria-hidden="true">Pasted image 20230129003138</figcaption></figure><p>简单题。</p><h1 id="判断矩阵是否是一个-x-矩阵">2319. 判断矩阵是否是一个 X 矩阵</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626849.png" alt="Pasted image 20230131093415" /><figcaption aria-hidden="true">Pasted image 20230131093415</figcaption></figure><p>简单题。</p><h1 id="解密消息">2325. 解密消息</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626850.png" alt="Pasted image 20230201104134" /><figcaption aria-hidden="true">Pasted image 20230201104134</figcaption></figure><p>简单题。唯一需要注意的是普通的动态数组用 ArrayList，字符动态数组用 StringBuilder。</p><h1 id="计算布尔二叉树的值">2331. 计算布尔二叉树的值</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302061731815.png" /></p><p>简单题，考察树的<strong>后序遍历</strong>，并存入栈中（使用双端队列）。</p><p>核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode root, Deque&lt;Integer&gt; dq)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">PostOrder(root.left,dq);</span><br><span class="line">PostOrder(root.right,dq);</span><br><span class="line"><span class="keyword">if</span> (root.val == <span class="number">2</span> || root.val == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> dq.pollLast();</span><br><span class="line"><span class="keyword">if</span> (root.val == <span class="number">2</span>) &#123;    <span class="comment">//or</span></span><br><span class="line">dq.addLast(x|y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dq.addLast(x&amp;y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">dq.addLast(root.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装满杯子需要的最短总时长">2335. 装满杯子需要的最短总时长</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302121048252.png" /></p><p>本题只要将最大的两个值同时-1，当只剩下最后一个温度的杯子没有装满时，再直接加上即可。</p><h1 id="数组能形成多少数对">2341. 数组能形成多少数对</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302162153619.png" /></p><p>简单题，没有意义。</p><h1 id="最好的扑克手牌">2347. 最好的扑克手牌</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302200856699.png" /></p><p>简单题，快排即可。</p><h1 id="第一个出现两次的字母">2351. 第一个出现两次的字母</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626851.png" alt="Pasted image 20230101002426" /><figcaption aria-hidden="true">Pasted image 20230101002426</figcaption></figure><p>简单题，利用位运算判断字符是否已经判断过。</p><h1 id="使数组中所有元素都等于零">2357. 使数组中所有元素都等于零</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302241543738.png" /></p><p>简单题。</p><h1 id="合并相似的物品">2363. 合并相似的物品</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302280901635.png" /></p><p>简单题，但是涉及到很多知识点。</p><ol type="1"><li><p>hash 的添加操作<br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash.put(i[<span class="number">0</span>],hash.getOrDefault(i[<span class="number">0</span>],<span class="number">0</span>)+i[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p></li><li><p>hash 的遍历 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">list.add(entry.getKey());</span><br><span class="line">list.add(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>list 的自定义遍历（注意是 <code>Collections</code>，不是 <code>Arrays</code>） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(res,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;List&lt;Integer&gt;&gt;() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(List&lt;Integer&gt; l1, List&lt;Integer&gt; l2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l1.get(<span class="number">0</span>)-l2.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p></li></ol><h1 id="算术三元组的数目">2367. 算术三元组的数目</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303310835410.png" /></p><p>简单题。</p><h1 id="矩阵中的局部最大值">2373. 矩阵中的局部最大值</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303010824823.png" /></p><p>简单题，意义不大。</p><h1 id="得到-k-个黑块的最少涂色次数">2379. 得到 K 个黑块的最少涂色次数</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303090848394.png" /></p><p>简单题，滑动窗口基础题！</p><h1 id="赢得比赛需要的最少训练时长">2383、赢得比赛需要的最少训练时长</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626775.png" /></p><p>本题思路比较简单：</p><p>首先要求训练后的experience值要比对手的experience之和多1；</p><p>因为是依次挑战（按顺序挑战），所以一个个计算，如果因为energy打不过当前，那就要额外训练一段时间，让他刚好能打过，依次类推，最后能算出energy的额外训练时间。</p><p>将两个训练时间相加即可。</p><h1 id="和有限的最长子序列">2389. 和有限的最长子序列</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303170816108.png" /></p><p>简单题，先排序，然后计算前缀和即可。</p><h1 id="和相等的子数组">2395. 和相等的子数组</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303261026706.png" /></p><p>简单题，求和即可。</p><h1 id="检查相同字母间的距离">2399. 检查相同字母间的距离</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304091111895.png" /></p><p>简单题。</p><h1 id="出现最频繁的偶数元素">2404. 出现最频繁的偶数元素</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304130837105.png" /></p><p>简单题，无脑 hash 存储即可。</p><h1 id="统计共同度过的日子数">2409. 统计共同度过的日子数</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304171610755.png" /></p><p>简单题，但是恶心人。只要找到两个人的出发日期的最大值和离开日期的最小值，它们之间的时间差就是我们要求得得。</p><h1 id="最小偶倍数">2413. 最小偶倍数</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304210854632.png" /></p><p>简单题，一行结束，优雅。</p><h1 id="按身高排序">2418. 按身高排序</h1><blockquote><p>考察： #数组排序</p></blockquote><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304251542535.png" /></p><p>简单题， #模板题 。但是注意：<strong>根据一个数组的结果排序另一个数组的</strong>，这是模板题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] sortPeople(String[] names, <span class="type">int</span>[] heights) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> names.length;</span><br><span class="line">        Integer[] idx = <span class="keyword">new</span> <span class="title class_">Integer</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            idx[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(idx, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> heights[b]-heights[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            res[i] = names[idx[i]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除字符使频率相同">2423. 删除字符使频率相同</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304292317566.png" /></p><p>简单模拟题。但是要考虑的东西特别多。</p><h1 id="公因子的数目">2427. 公因子的数目</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202304051652694.png" /></p><p>简单题。</p><h1 id="温度转换">2469. 温度转换</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303210819183.png" /></p><p>简单题，没有意义。</p><h1 id="统计中位数为-k-的子数组">2488. 统计中位数为 K 的子数组⭐</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303160938313.png" /></p><blockquote><p>Tags： #前缀和 #后缀和 #哈希</p></blockquote><p>困难题，思路很难！是前缀和的超级灵活考察，它不是简单的前缀相加再处理，而是用相对大小进行处理，最后记录大于 k 和小于 k 的个数之间的关系。</p><p><strong>思路：</strong></p><p>首先注意，由于 nums 长度为 n，且是 1~n 的不同整数组成，数组只能是一个 1 到 n 的排列。同时 k≤n，则 k 一定在数组中出现过。</p><p>那么可以在数组中先找到 k，考虑一个数组的中位数如果是 k，那么这个排序后的 k 就在中间或中间偏左。</p><p>因此可以将 k 及其右侧所有数字到 k 这个位置上的“前缀和”统计出来（这里“前缀和”并不是常规上的“前缀和”），k 位置上的 sum=0，大于 k 的位置是 sum+1，小于的是 sum-1，并都存入哈希表。哈希表的 key 就是 sum，value 就是 sum 出现的次数。不难发现 key=0 一定会出现 1 次，也就表示整个数组至少会出现一个只有 k 单独元素组成的符合条件的子数组。</p><p>接下来对 k 左侧进行相反处理，从 k 位置向左端点进行遍历，即求到 k 的“后缀和”。等于 k 就 sum=0，小于 k 是 sum+1，大于 k 是 sum-1。但是本次遍历不需要存入 hash，而是直接不断 hash. get (sum)+hash. get (sum+1) 求出结果了。</p><p><strong>举个例子：</strong></p><p>假设数组为[3, 2, 1, 5, <strong>4</strong>, 7, 6]。</p><p>先处理右端：[0, 0, 0, 0, <strong>0</strong>, 1, 2]。</p><p>再处理左端：[2, 1, 0, -1, <strong>0</strong> , 1, 2]。我们可以看出当左边遍历到 2 的时候 sum=1，意味着<strong>左边小于 k 的比大于 k 的多 1 个</strong>，如果要使得子数组成立，我需要再右边找到<strong>右边大于 k 的比小于 k 的多 1 个</strong>，或者<strong>右边找到大于 k 的比小于 k 的多 2 个</strong>（因为中位数靠左），所以本题下标为 1~5 可以为一个结果，1~6 也可以为一个结果。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubarrays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 找k的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//记录k的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==k) &#123;</span><br><span class="line">                loc = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 计算以k为起点的前缀和以k为终点的后缀</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2.1 以k为起点，等于k的也就是起点设置为0，比k大的sum+1，比k小的sum-1，每次结果都存在hash中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=loc;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==k) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&gt;k) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            hash.put(sum, hash.getOrDefault(sum,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2 以k为终点，但是遍历的时候k仍然是起点，只是从右往左遍历，等于k的也就是最初时候sum=0，比k大的sum-1，比k小的sum+1，每次结果直接和hash中的进行对比。</span></span><br><span class="line">        <span class="comment">// 依赖的原则是：k左边的sum一定比k右边的sum相等或者大1，那么这段就是正确的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=loc;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]==k) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i]&lt;k) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            res += hash.getOrDefault(sum,<span class="number">0</span>);</span><br><span class="line">            res += hash.getOrDefault(sum+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面试题-01.02.-判定是否互为字符重排">面试题 01.02. 判定是否互为字符重排⭐</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626776.png" alt="image-20220928215225321" /><figcaption aria-hidden="true">image-20220928215225321</figcaption></figure><p>本题可以使用将字符串转为字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] sa1 = s1.toCharArray();</span><br></pre></td></tr></table></figure><p>再对字符数组进行排序，一样可以使用Arrays.sort()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(sa1);     <span class="comment">//对sa1原地排序</span></span><br></pre></td></tr></table></figure><p>判断两个字符数组是否相同，可以先将字符数组转为字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(sa1);</span><br></pre></td></tr></table></figure><p>字符串的比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2);    <span class="comment">//返回true或者false</span></span><br></pre></td></tr></table></figure><h1 id="剑指-offer-47.-礼物的最大价值">剑指 Offer 47. 礼物的最大价值</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303080826979.png" /></p><p>经典动态规划~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">                dp[j+<span class="number">1</span>] = Math.max(dp[j]+grid[i][j],dp[j+<span class="number">1</span>]+grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面试题01.05.一次编辑">面试题01.05.一次编辑</h1><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626777.png" alt="image-20221014091320312" /><figcaption aria-hidden="true">image-20221014091320312</figcaption></figure><p>比较简单的一题，类似于<code>1913题</code>的思路.</p><h1 id="面试题-01.08零矩阵">面试题 01.08、零矩阵</h1><h2 id="方法一两次遍历">方法一、两次遍历</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626778.png" alt="image-20220930094258272" /><figcaption aria-hidden="true">image-20220930094258272</figcaption></figure><p>对二维数组遍历两遍，第一遍是为了找到受影响的行和列，第二遍是针对这些行和列做处理。</p><p>List查找某个元素是否在其中，可以用：（List其他操作见15题）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.contains(s);    <span class="comment">//查找s这个元素是否在list中</span></span><br></pre></td></tr></table></figure><h2 id="方法二两个标记变量">方法二、两个标记变量</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626779.png" alt="image-20220930101828955" /><figcaption aria-hidden="true">image-20220930101828955</figcaption></figure><p>这个思路就是将第一行第一列作为标签，如果matrix中i行j列为0，则将第一行的j列和第一列的i行置为0即可。但是为了保存第一行和第一列的信息，我需要先判断如果第一行中没有0，但是由于matrix[i][j]为0，所以第一行的第j列必然为0。所以在操作之前先判断第一行和第一列是否有0，如果有则在最后一步将其全置为0。接下来的操作是分析除去第一行和第一列的元素，如果为0，则其对应的第一行的元素和第一列的元素变为0。遍历完之后，根据第一行和第一列的情况对内部元素操作。最后按照上面刚说的那样对第一行和第一列处理。</p><h1 id="面试题-01.09字符串轮转">面试题 01.09、字符串轮转</h1><h2 id="方法一利用子串匹配">方法一、利用子串匹配</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626780.png" alt="image-20220929224340027" /><figcaption aria-hidden="true">image-20220929224340027</figcaption></figure><p>java中有内置的判断字符串是否在另一个字符串的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.contains(s2);    <span class="comment">//如果s2包含在s1中，则返回true，否则返回false</span></span><br></pre></td></tr></table></figure><p>只需要将其中的一个字符串连续两个相同的拼接上，如果可以循环成为它，则另一个字符串就一定包含在这个拼接的字符串中。</p><h2 id="方法二指针移动关系">方法二、指针移动关系</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626781.png" alt="image-20220929225202308" /><figcaption aria-hidden="true">image-20220929225202308</figcaption></figure><p>如果s1向左循环移动i位得到s2，那么对于s2的下标为j的元素有这样的关系：<code>s2[j] = s1[(i+j)%j]</code>。其实很好理解，因为如果是s1向左移动i位，相当于s2相对s1向右移动i位，所以对于s2的i位，实际就是s1的0位，这样就能得到这样的关系。注意的是对于字符串，提取下标为i的字符需要用<code>s1.charAt(i)</code>。</p><h1 id="面试题-05.02.-二进制数转字符串">面试题 05.02. 二进制数转字符串</h1><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303020957917.png" /></p><p>常规中等题，考察 StringBuilder 和除法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">printBin</span><span class="params">(<span class="type">double</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">1.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        sb.append(<span class="string">&quot;0.&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="number">0.5</span>;</span><br><span class="line">        <span class="keyword">while</span> (num!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sb.length() &gt; <span class="number">32</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= cs*<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= cs) &#123;</span><br><span class="line">                num -= cs;</span><br><span class="line">                cs = cs / <span class="number">2</span>;</span><br><span class="line">                sb.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cs = cs / <span class="number">2</span>;</span><br><span class="line">                sb.append(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num==<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ERROR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面试题-17.05.-字母与数字">面试题 17.05. 字母与数字</h1><h2 id="方法一前缀和定长">方法一、前缀和+定长</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303111105673.png" /></p><p>先计算前缀和，因为要找最长子串，所以定长遍历，从最长的长度开始，遍历起点，再依次缩小长度，继续遍历起点。直到找到一个长度下满足条件的起点，这个起点和长度就是满足条件的最长且靠左的。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="type">int</span>[] pren = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] prec = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> array[i].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) || (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                    prec[i] = <span class="number">1</span>;</span><br><span class="line">                    pren[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    prec[i] = <span class="number">0</span>;</span><br><span class="line">                    pren[i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) || (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;</span><br><span class="line">                    prec[i] = prec[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    pren[i] = pren[i-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    prec[i] = prec[i-<span class="number">1</span>];</span><br><span class="line">                    pren[i] = pren[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFind</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> n; len &gt; <span class="number">0</span>; len--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> start=<span class="number">0</span>;start&lt;=n-len;start++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start==<span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prec[start+len-<span class="number">1</span>] == pren[start+len-<span class="number">1</span>]) &#123;</span><br><span class="line">                        left = start;</span><br><span class="line">                        right = start+len-<span class="number">1</span>;</span><br><span class="line">                        isFind = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prec[start+len-<span class="number">1</span>] - prec[start-<span class="number">1</span>] == pren[start+len-<span class="number">1</span>] - pren[start-<span class="number">1</span>]) &#123;</span><br><span class="line">                        left = start;</span><br><span class="line">                        right = start+len-<span class="number">1</span>;</span><br><span class="line">                        isFind = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFind) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right==left) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[right-left+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;right-left+<span class="number">1</span>;i++) &#123;</span><br><span class="line">            res[i] = array[i+left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二前缀和哈希">方法二、前缀和+哈希⭐</h2><p><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202303111219097.png" /></p><p>我们设遇到字母+1，遇到数字-1，所以满足条件的子串的和就是为 0。但是找到一个和为 0 的子串实际上操作和方法一一致，没有达到优化的效果，所以需要转换思路。</p><p>假设以下标为 i 结尾的前缀和为 k，以下标为 j 结尾的前缀和也为 k，那么可以知道 i~j 之间部分的和为 0，实际上是 <strong><code>[i+1, j]</code> 区间的和为 0，这个区间长度为 <code>j-i</code></strong>。</p><p>哈希表 hash 记录每个前缀和第一次出现的位置，max 记录最大子数组的长度，start 记录最大子数组时的起点位置。</p><blockquote><p>关于数组的深拷贝，使用方法见：<a href="LeetCode总结笔记.md#数组##拷贝###深拷贝">数组深拷贝</a></p></blockquote><p>详细代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findLongestSubarray(String[] array) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">        hash.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;array.length;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> array[i].charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> ((c&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;Z&#x27;</span>) || (c&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;z&#x27;</span>)) &#123;      <span class="comment">// 字母+1</span></span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;       <span class="comment">// 数字-1</span></span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(sum)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i-hash.get(sum) &gt; max) &#123;       <span class="comment">// 表示以hash.get(sum)为尾的前缀和 和 以i为尾的前缀和是相等的，所以他们中间部分就是满足条件的子串</span></span><br><span class="line">                    max = i - hash.get(sum);</span><br><span class="line">                    start = hash.get(sum)+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hash.put(sum,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] res = <span class="keyword">new</span> <span class="title class_">String</span>[max];</span><br><span class="line">        System.arraycopy(array,start,res,<span class="number">0</span>,max);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面试题17.09第k个数">面试题17.09、第k个数</h1><h2 id="方法一硬算">方法一、硬算</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626782.png" alt="image-20220928204023119" /><figcaption aria-hidden="true">image-20220928204023119</figcaption></figure><p>使用方法三的手法进行优化</p><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626783.png" alt="image-20220928214832520" /><figcaption aria-hidden="true">image-20220928214832520</figcaption></figure><p>List本质上就是动态数组</p><p>创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.get(<span class="number">0</span>);     <span class="comment">// 通过下标查询</span></span><br></pre></td></tr></table></figure><h2 id="方法二小根堆">方法二、小根堆</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626784.png" alt="image-20220928211555288" /><figcaption aria-hidden="true">image-20220928211555288</figcaption></figure><h3 id="小根堆">小根堆</h3><p>小根堆的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Long&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>小根堆添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.add(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>小根堆判断是否为空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q.isEmpty()    <span class="comment">//如果是空则返回true</span></span><br></pre></td></tr></table></figure><p>小根堆弹出操作（弹出最小的数，并返回此数）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">t</span> <span class="operator">=</span> q.poll();</span><br></pre></td></tr></table></figure><h3 id="set集合">Set集合</h3><p>Set 表示唯一对象的集合。集合中元素的排序是不相关的。</p><h4 id="hashset">HashSet</h4><p>HashSet 基于 HashMap 来实现的，是一个<strong>不允许有重复元素的集合</strong>。</p><p>HashSet 允许有 null 值。</p><p>HashSet <strong>是无序的，即不会记录插入的顺序</strong>。</p><p>HashSet 实现了 Set 接口。（这就是为什么这个解法可以使用<code>Set&lt;Long&gt; set = new HashSet&lt;&gt;();</code>）</p><p>Set对象的创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Long&gt; set = new HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>Set对象的添加操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.add(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>Set对象的判断是否存在操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.contains(k)     <span class="comment">//判断k这个值在set中是否存在，存在则返回true</span></span><br></pre></td></tr></table></figure><p>Set对象删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set.remove(&quot;book&quot;);</span><br></pre></td></tr></table></figure><h2 id="方法三多路归并多指针方法一优化">方法三、多路归并（多指针）（方法一优化）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626785.png" alt="image-20220928214035095" /><figcaption aria-hidden="true">image-20220928214035095</figcaption></figure><p>设置3个指针，分别是对于*3、*5、*7的，每次比较选择最小的加入到数组中。</p><h3 id="注意-6">注意</h3><p>在使用两个数比大小时，尽量使用<code>Math.min(a,b)</code>。如果时三个数，使用<code>Math.min(a,Math.min(b,c))</code>。</p><h1 id="面试题-17.19消失的两个数字">面试题 17.19、消失的两个数字</h1><h2 id="方法一硬算不合规矩">方法一、硬算（不合规矩）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626786.png" alt="image-20220926152844119" /><figcaption aria-hidden="true">image-20220926152844119</figcaption></figure><h2 id="方法二异或官方">方法二、异或（官方）</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626787.png" alt="image-20220926205020657" /><figcaption aria-hidden="true">image-20220926205020657</figcaption></figure><blockquote><ol type="1"><li><p><strong>负数的补码:</strong></p><p>对于正数9：0000 1001</p><p>对于负数-9：先-1：0000 1000；再全部取反：1111 0111。</p></li></ol><p>​ 或者先变成：1000 1001；再除了符号位取反：1111 0110；再末位+1：1111 0111。</p><p>​ 所以: 9 = 0000 1001</p><p>​ -9 = 1111 0111</p><pre><code>          9 &amp; -9 = 0000 0001（能生成二进制中为1的最小位） </code></pre><p>​ 拓展: 10 = 0000 1010</p><p>​ -10 = 1111 0110</p><pre><code>           10 &amp; -10 = 0000 0010 </code></pre><ol start="2" type="1"><li><p><strong>异或</strong></p><p>Java中异或用<code>^</code>表示</p><p>1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 4 =&gt; 0 ^ 0 ^ 3 ^ 4 =&gt; 0 ^ 3 ^ 4（x = 3^4）=&gt; 0 ^ x =&gt; x</p><p>即 a ^ a ^ b = b</p></li><li><p><code>Integer.MIN_VALUE</code> = 1000 0000 0000 0000 0000 0000 0000 0000，-2 147 483 648</p><p><code>Integer.MAX_VALUE</code> = 0111 1111 1111 1111 1111 1111 1111 1111， 2 147 483 647</p></li></ol></blockquote><p>逻辑：</p><p>这是考察异或和且的位运算算法题。我们想要找到n个数中没有出现的2个数，也就是再n个数中找出除了<code>nums</code>中存在的n-2个数的另外2个数。</p><p>如果先将这n个数和<code>nums</code>中n-2个数异或，也就是这2n-2（n-2 + n-2 + 2）个数异或，根据上面异或的相关知识，能得到结果<code>x = x1 ^ x2</code>（x为异或结果，x1、x2为我们想要求得的两个不在nums的数）。</p><p>得到<code>x = x1 ^ x2</code>，如何提取出x1和x2成为了最大的难题。我们发现x1和x2不可能相同，所以<code>x1&amp;x2! = 0</code>，根据上面且的相关知识，对于x而言，它二进制最低位的1（假设是第k位）所代表的含义是x1的第k位和x2的第k位是不相同的（因为相同为0、不同为1），因此我们可以将<code>nums</code>分为两类，一类是第k位为0的，一类是第k位为1的。筛选出<code>nums</code>这两类很简单，只需要与<code>x&amp;-x</code>（<code>x&amp;-x</code>的结果是除了第k位为1，其他位都是0）进行且操作，如果结果是0，表示<code>nums</code>中的这个数的第k位是0；如果是1，表示<code>nums</code>中的这个数的第k位是1。这里需要进行防溢出操作，即判断<code>x == Integer.MIN_VALUE</code>，如果成立，说明-x已经越界，就直接将x与nums中每个数进行比较筛选。</p><p>经过上一步就已经将<code>nums</code>分为两部分了<code>type1</code>、<code>type2</code>，这时候只需要将n个数分为两部分，两部分分别是<code>type1</code>多一个x1、<code>type2</code>多一个x2。只需要再用一次异或，结果就分别是x1和x2了。</p><p>返回结果直接用<code>new int[]&#123;type1,type2&#125;</code>即可。</p><h2 id="方法三求和">方法三、求和</h2><figure><img src="https://cdn.staticaly.com/gh/Wang-Ruiyang/pic_bed@main/img/202302041626788.png" alt="image-20220926213157385" /><figcaption aria-hidden="true">image-20220926213157385</figcaption></figure><p>本方法使用数学基础运算。先求出n个数之和，再求出nums中n-2个数之和，则这两个和之差就是<code>x1+x2</code>。我们可以通过<code>x = x1+x2</code>，算出x1和x2的中位数t，即<strong>x1一定小于t，x2一定大于t</strong>，求出1~t的和truenum，可以将nums遍历一遍，筛选每一个值小于等于t的num，再用truenum减去这个值，得到的结果就是x1。用<code>x2 = x - x1</code>得到结果。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据库的一些易混淆的概念</title>
      <link href="/2022/03/08/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/03/08/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E4%BA%9B%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li><p>当<strong>A-&gt;B</strong>在R上成立，关系R(A, B, C)等于其投影R1(A, B)和R2(A, C)的连接，反之则不然。</p><p>当且仅当多值依赖<strong>A-&gt;-&gt;B</strong>在R上成立，关系R(A, B, C)等于其投影R1(A, B)和R2(A, C)的连接。</p></li><li><p>A-&gt;B, A-&gt;C 则 A-&gt;(B, C)</p><p>B-&gt;A, C-&gt;A 则 (B, C)-&gt;A，反之不成立（例：(学号，课程号)-&gt;成绩，但是不能推出学号-&gt;成绩和课程号-&gt;成绩）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小函数依赖集的判断</title>
      <link href="/2022/03/07/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E7%9A%84%E5%88%A4%E6%96%AD/"/>
      <url>/2022/03/07/%E6%9C%80%E5%B0%8F%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E7%9A%84%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="方法">方法</h1><ol type="1"><li><p>将F右侧全部分解为只有一个属性；</p></li><li><p>去掉冗余项：从第一个函数依赖X-&gt;Y开始，假设将其<strong>从F中去掉</strong>，在剩下的函数依赖中求X的闭包，<strong>看Y是属于X的闭包中</strong>。<strong>如果属于，则去掉X-&gt;Y</strong>；如果不属于，则保留。依次扫描......</p></li><li><p>去掉冗余属性：选取左边属性个数&gt;1的所有依赖，假设XY-&gt;A。先将XY-&gt;A换成Y-&gt;A，<strong>判断A是否还属于Y的闭包</strong>。<strong>如果属于，则删掉此X</strong>，否则保留。依次测试每个依赖的每个左边属性......</p></li></ol><p>　<strong>（如果3中改变了函数依赖F，则需要重新来一次2）</strong></p><h1 id="例题">例题</h1><blockquote><p><strong>R={A, B, C, D, E, F}，F={ABD-&gt;AC, C-&gt;BE, AD-&gt;BF, B-&gt;E}，求最小函数依赖集</strong></p></blockquote><ol type="1"><li><p>化简右侧。F={ABD-&gt;A, ABD-&gt;C, C-&gt;B, C-&gt;E, AD-&gt;B, AD-&gt;F, B-&gt;E}。</p></li><li><p>去掉冗余项。</p></li></ol><p>　　如果删去ABD-&gt;A，F={ ABD-&gt;C, C-&gt;B, C-&gt;E, AD-&gt;B, AD-&gt;F, B-&gt;E}。ABD+={ABDCEF}，A包含在其中，因此删掉。</p><p>　　如果删去ABD-&gt;C，F={C-&gt;B, C-&gt;E, AD-&gt;B, AD-&gt;F, B-&gt;E}。ABD+={ABDEF}，C不包含在其中，不能删除。</p><p>　　如果删掉C-&gt;B，F={ ABD-&gt;C, C-&gt;E, AD-&gt;B, AD-&gt;F, B-&gt;E}。C+={C, E}，B不包含在其中，不能删除。</p><p>　　如果删掉C-&gt;E，F={ ABD-&gt;C, C-&gt;B, AD-&gt;B, AD-&gt;F, B-&gt;E}。C+={C, B, E}，E包含在其中，因此删掉。</p><p>　　如果删掉AD-&gt;B，F={ ABD-&gt;C, C-&gt;B, AD-&gt;F, B-&gt;E}。AD+={A, D, F}，B不包含在其中，不能删除。</p><p>　　如果删掉AD-&gt;F，F={ ABD-&gt;C, C-&gt;B, AD-&gt;B, B-&gt;E}。AD+={A, D, B, E, C}，F不包含在其中，不能删除。</p><p>　　如果删掉B-&gt;E, F={ ABD-&gt;C, C-&gt;B, AD-&gt;B, AD-&gt;F}。B+={B}，E不包含在其中，不能删除。</p><p>　　<strong>综上：F={ ABD-&gt;C, C-&gt;B, AD-&gt;B, AD-&gt;F, B-&gt;E}</strong></p><ol start="3" type="1"><li>去掉冗余属性。</li></ol><p>　　将ABD-&gt;C去掉A，变成BD-&gt;C，BD+={B, D, E}，C不包含在其中，不能删掉</p><p>　　将ABD-&gt;C去掉B，变成AD-&gt;C，AD+={A, D, B, E, F, C}，C包含在其中，可以删掉B</p><p>　　将ABD-&gt;C去掉D，变成AB-&gt;C，AC+={A, B, E}，C不包含在其中，不能删掉</p><p>　　因此ABD-&gt;C化简为AD-&gt;C</p><p>　　将AD-&gt;C去掉A，变成D-&gt;C，D+={D}，C不包含在其中，不能删掉</p><p>　　将AD-&gt;C去掉D，变成A-&gt;C，A+={A}，C不包含在其中，不能删掉</p><p>　　因此AD-&gt;C不变</p><p>　　将AD-&gt;B去掉A，变成D-&gt;B，D+={D}，B不包含在其中，不能删除</p><p>　　将AD-&gt;B去掉D，变成A-&gt;B，A+={A}，B不包含在其中，不能删除</p><p>　　因此AD-&gt;B不变</p><p>　　将AD-&gt;F去掉A，变成D-&gt;F，D+={D}，F不包含在其中，不能删除</p><p>　　将AD-&gt;F去掉D，变成A-&gt;F，A+={A}，F不包含在其中，不能删除</p><p>　　因此AD-&gt;F不变</p><p>　　此时<strong>F={ AD-&gt;C, C-&gt;B, AD-&gt;B, AD-&gt;F, B-&gt;E}</strong></p><ol start="4" type="1"><li>重复2</li></ol><p>　　将AD-&gt;C删掉，F={C-&gt;B, AD-&gt;B, AD-&gt;F, B-&gt;E}，AD+={A,D,B,E,F}，C不包含在其中，不能删</p><p>　　将C-&gt;B删掉，F={ AD-&gt;C, AD-&gt;B, AD-&gt;F, B-&gt;E}，C+={C}，B不包含在其中，不能删</p><p>　　将AD-&gt;B删掉，F={ AD-&gt;C, C-&gt;B, AD-&gt;F, B-&gt;E}，AD+={ADCBEF}，C包含在其中，删AD-&gt;B</p><p>　　将AD-&gt;F删掉，F={ AD-&gt;C, C-&gt;B, B-&gt;E}，AD+={A, D, C, B, E}，F不包含其中，不能删</p><p>　　将B-&gt;E删掉，F={ AD-&gt;C, C-&gt;B, AD-&gt;F}，B+={B}，E不包含在其中，不能删除</p><p><strong>综上：Fm={ AD-&gt;C, C-&gt;B, AD-&gt;F, B-&gt;E}</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模式分解——无损连接分解</title>
      <link href="/2022/03/06/%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E2%80%94%E2%80%94%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%88%86%E8%A7%A3/"/>
      <url>/2022/03/06/%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E2%80%94%E2%80%94%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>练习：已知R&lt;U,F&gt;，U={A, B, C, D, E}，F={AB-&gt;C, C-&gt;D, D-&gt;E}，R的一个分解为R1(A, B, C)，R2(C, D)，R3(D, E)，判断是否为无损分解</strong></p></blockquote><p>1. 构造表（根据分解的R进行构造，和F无关）</p><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr class="odd"><td>ABC</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="even"><td>CD</td><td></td><td></td><td></td><td></td><td></td></tr><tr class="odd"><td>DE</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>2. 初始化，根据表中行号中的元素，填上对应的ai</p><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr class="odd"><td>ABC</td><td>a1</td><td>a2</td><td>a3</td><td></td><td></td></tr><tr class="even"><td>CD</td><td></td><td></td><td>a3</td><td>a4</td><td></td></tr><tr class="odd"><td>DE</td><td></td><td></td><td></td><td>a4</td><td>a5</td></tr></tbody></table><p>对空白部分补上bij</p><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr class="odd"><td>ABC</td><td>a1</td><td>a2</td><td>a3</td><td>b14</td><td>b15</td></tr><tr class="even"><td>CD</td><td>b21</td><td>b22</td><td>a3</td><td>a4</td><td>b25</td></tr><tr class="odd"><td>DE</td><td>b31</td><td>b32</td><td>b33</td><td>a4</td><td>a5</td></tr></tbody></table><p>3. 由AB-&gt;C，找AB列（注意不是A、B列），发现每一行（元组）中AB组合没有相同的，跳过</p><p>　由C-&gt;D，找C列，发现1、2行相同，因此将D列的1、2行改为a4</p><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr class="odd"><td>ABC</td><td>a1</td><td>a2</td><td>a3</td><td>a4</td><td>b15</td></tr><tr class="even"><td>CD</td><td>b21</td><td>b22</td><td>a3</td><td>a4</td><td>b25</td></tr><tr class="odd"><td>DE</td><td>b31</td><td>b32</td><td>b33</td><td>a4</td><td>a5</td></tr></tbody></table><p>　由D-&gt;E，找到D列，发现1、2、3行全部相同，因此将E列的1、2、3行都改为a5</p><table><thead><tr class="header"><th></th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th></tr></thead><tbody><tr class="odd"><td>ABC</td><td>a1</td><td>a2</td><td>a3</td><td>a4</td><td>a5</td></tr><tr class="even"><td>CD</td><td>b21</td><td>b22</td><td>a3</td><td>a4</td><td>a5</td></tr><tr class="odd"><td>DE</td><td>b31</td><td>b32</td><td>b33</td><td>a4</td><td>a5</td></tr></tbody></table><p>4. 全部处理完了，发现第一行出现a1、a2、a3、a4、a5，因此本次分解为无损连接分解</p><hr /><p><strong>2022.3.21更新</strong></p><p>如果对于X-&gt;Y，对于相同的X，所有的Y都不相同，则取行号最小的Y覆盖所有的Y（本例题没有体现）</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>候选码、主码、主属性辨析与练习</title>
      <link href="/2022/03/05/%E5%80%99%E9%80%89%E7%A0%81%E3%80%81%E4%B8%BB%E7%A0%81%E3%80%81%E4%B8%BB%E5%B1%9E%E6%80%A7%E8%BE%A8%E6%9E%90%E4%B8%8E%E7%BB%83%E4%B9%A0/"/>
      <url>/2022/03/05/%E5%80%99%E9%80%89%E7%A0%81%E3%80%81%E4%B8%BB%E7%A0%81%E3%80%81%E4%B8%BB%E5%B1%9E%E6%80%A7%E8%BE%A8%E6%9E%90%E4%B8%8E%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="辨析">辨析</h1><ol type="1"><li><p><strong>候选码：</strong>其闭包为整个U，也就是说U是完全依赖于候选码的（大多数情况存在传递依赖），候选码可能有多个。</p></li><li><p><strong>超码：</strong>U是部分依赖于超码的，简单来说就是超码是候选码中加了一些可有可无的东西。</p></li><li><p><strong>主码：</strong>如果<strong>候选码多于一个，则选择其中一个作为主码</strong>（因为随便哪个都能能被U完全依赖）。</p><p><strong>（主码、候选码都称为码，要自己分析）</strong></p></li><li><p><strong>主属性：</strong>包含在任何一个候选码中的属性为主属性，意思就是所有候选码的<strong>并集</strong>的组合拆分为一个一个属性（主属性不可能什么都没有，有可能是整个U），这些属性就是主属性。（可以在候选码练习中看到）</p></li></ol><h1 id="方法">方法</h1><ol type="1"><li><p>划分类型</p><blockquote><p>L类：只在左边出现</p><p>R类：只在右边出现</p><p>LR类：同时在左边和右边出现</p><p>NULL类：左边右边都没有出现</p></blockquote></li><li><p>先化简，将右边全部拆为1个值。</p></li></ol><p>　属于L类的都是候选码的一部分，并且都是主属性。如果此类已经可以直接推出U，则表示候选码就是L类的了，无需继续后面的操作</p><p>　属于R类的都一定不在候选码里</p><p>　属于LR类的：1. 如果L类有，且只有L类无法推出U，就依次拿单个LR类与L类的组合，看是不是码</p><p>　　　　　　　 2. 如果经过与第一轮与一个LR匹配后，剩下的不能匹配的LR则两两组合，再与L全体组合看能不能推出U，如果可以，也是候选码。</p><p>　　　　 　　　3. 以此类推......</p><h1 id="例题">例题</h1><blockquote><p><strong>R&lt;U,F&gt;,U=(A,B,C,D,E,G),F={AB--&gt;C,CD--&gt;E,E--&gt;A,A--&gt;G}</strong></p></blockquote><ol type="1"><li><p>左边集合为{ABCDE}，右边集合为{ACEG}。可知BD只在左边出现，一定为候选码的一部分，BD+-&gt;BD；G只在右边出现，一定不在候选码中。</p></li><li><p><strong>BD与A组合，求ABD的闭包：ABD+-&gt;ABD</strong></p><p>　AB-&gt;C =&gt; ABD+-&gt;ABCD</p><p>　CD-&gt;E =&gt; ABD+-&gt;ABCDE</p><p>　A-&gt;G =&gt; ABD+-&gt;ABCDEG=U，因此ABD为候选码</p><p>　<strong>BD与C组合，求BCD的闭包：BCD+-&gt;BCD</strong></p><p>　CD-&gt;E =&gt; BCD+-&gt;BCDE</p><p>　E-&gt;A =&gt; BCD+-&gt;ABCDE</p><p>　A-&gt;G =&gt; BCD+-&gt;ABCDEG=U，因此BCD也为候选码</p><p>　<strong>BD与E组合，求BDE的闭包：BDE+-&gt;BDE</strong></p><p>　E-&gt;A =&gt; BDE+-&gt;ABDE</p><p>　AB-&gt;C =&gt; BDE+-&gt;ABCDE</p><p>　A-&gt;G =&gt; BDE+-&gt;ABCDEG=U，因此BDE也为候选码</p></li><li><p>因此ABD、BCD、BDE皆为候选码，主属性为A、B、C、D、E。</p></li></ol><blockquote><p><strong>R(A, B, C, D), F={B-&gt;D, AB-&gt;C}</strong></p></blockquote><ol type="1"><li>左边={AB}，右边={CD}，候选码为AB，主属性为A、B。</li></ol><blockquote><p><strong>R(A, B, C, D), F={A-&gt;B, A-&gt;C, D-&gt;A}</strong></p></blockquote><ol type="1"><li>左边={AD}，右边={ABC}，因此候选码不可能有B、C；必然有D，D+-&gt;DABC=U。因此D为候选码，主属性为D。</li></ol><blockquote><p><strong>R(A, B, C, D), F={BCD-&gt;A, A-&gt;C}</strong></p></blockquote><ol type="1"><li><p>左边={ABCD}，右边={AC}。BD是左边独有的，一定是候选码的一部分，BD+-&gt;BD。</p></li><li><p>BD与A组合，ABD+ -&gt; ABDC=U，因此ABD为候选码。BD与C组合，BCD+ -&gt; ABCD=U，因此BCD为候选码。</p></li><li><p>ABD、BCD皆为候选码，主属性为A、B、C、D。</p></li></ol><blockquote><p><strong>R(A, B, C, D), F={B-&gt;C, B-&gt;D, CD-&gt;A}</strong></p></blockquote><ol type="1"><li>左边={BCD}，右边={ACD}，A不可能是候选码，B是候选码一部分，B+-&gt;BCDA=U，因此候选码为B，主属性为B</li></ol><blockquote><p><strong>R(A, B, C, D, E, F), F={A-&gt;BC, CD-&gt;E, B-&gt;D, BE-&gt;F, EF-&gt;A}</strong></p></blockquote><ol type="1"><li><p>L类：无；R类：无；LR类：A、B、C、D、E、F；NULL类：无</p></li><li><p>先将右边全部化简为1个，F={A-&gt;B, A-&gt;C, CD-&gt;E, B-&gt;D, BE-&gt;F, EF-&gt;A}</p></li><li><p>A+ -&gt; {A, B, C, D, E, F}，A是候选码</p><p>　B+ -&gt; {BD}</p><p>　C+ -&gt; {C}</p><p>　D+ -&gt; {D}</p><p>　E+ -&gt; {E}</p></li><li><p>BC+ -&gt; {B, C, D, E, F, A}，BC是候选码</p><p>　BD+ -&gt; {B, D}</p><p>　BE+ -&gt; {B, E, D, F, A, C}，BE是候选码</p><p>　BF+ -&gt; {B, F, D}</p><p>　CD+ -&gt; {C, D, E}</p><p>　CE+ -&gt; {C, E}</p><p>　CF+ -&gt; {C, F}</p><p>　DE+ -&gt; {D, E}</p><p>　DF+ -&gt; {D, F}</p><p>　EF+ -&gt; {E, F, A, B, C, D}，EF是候选码</p></li><li><p>不能有A，BC，BE，EF</p><p>　BDF+ -&gt; {B, D, F}</p><p>　CDE+ -&gt; {C, D, E}</p><p>　CDF+ -&gt; {C, D, F, E, A, B}，CDF是候选码</p></li><li><p>综上，<strong>A、BC、BE、EF、CDF为候选码；主属性为A、 B、C、D、E、F。</strong></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库范式判断1NF~4NF</title>
      <link href="/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/"/>
      <url>/2022/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近复习范式属实是恶心到我了，书本看着看着就迷，晦涩难懂。看完了华中科技大学的数据库PPT、《数据库系统概论（第五版）》，在结合B站众多牛逼的UP主的讲解视频，我终于理解了1F到BCNF的定义和判断。接下来，我将用最小白的语句讲一讲范式是怎么回事。</p><h1 id="定义">定义</h1><p>范式难就难在涉及几个定义，这几个定义极容易混淆。</p><p><strong>1NF：</strong>不可分割。这个简单，数据库创建的表都是1NF，总不能像EXCEL上创建的那种花里胡哨的表一样吧。</p><p><strong>2NF：</strong>不存在非主属性对候选码的部分依赖。OK，这里涉及几个知识点。</p><p>　　1. 什么是非主属性。首先需要知道什么是主属性，在此之前必须要说一下啥是候选码。</p><p>　　<strong>候选码：</strong>候选码能推出所有的属性（候选码一定能推出自身的属性），候选码之间带不带逗号意义完全不同。例如，在U(A,B,C,D)中AB是候选码，表示AB可以推出ABCD所有属性，这里说的ABCD并不是一定要右边完完整整的ABCD，而是他们推出的右边的属性的并集，比如AB-&gt;CD，或者AB-&gt;C、AB-&gt;D这都可以说AB推出ABCD。怎么求等会会说到。（候选码不唯一，但主码唯一）</p><p>　　<strong>主属性：</strong>候选码中的某些属性为主属性，注意“某些”，当然主属性也可能没有。上个例子说到AB为候选码，则可能经过后面的判断A、B都是主属性。怎么判断后面也会说。</p><p>　　（候选码、主属性、主码辨析）</p><p>　　<strong>非主属性：</strong>属性中除了主属性，剩下的都是非主属性咯。</p><p>　　2. 什么是<strong>部分依赖</strong>。举个栗子，AB-&gt;C、A-&gt;C，这中间A能单独推出C，所以C依赖于A，但是C又依赖于AB，所以C部分依赖于AB。</p><p><strong>3NF：</strong>不存在非主属性到候选码的传递依赖。</p><p>　3. <strong>传递依赖</strong>顾名思义啦，A-&gt;B、B-&gt;C，所以C对A是传递依赖。当然如果A-&gt;B、B-&gt;A这可不算传递依赖哦，因为这里A、B都是候选码，都不存在非主属性，那有传递依赖呀。</p><p>　　　注意定义：X-&gt;Y (Y⊈X), Y↛ X, Y-&gt;Z (Z⊈Y)，则称Z对X传递函数依赖。</p><p><strong>BCNF：</strong>已经完全消除了非主属性对于候选码的部份依赖和传递依赖，不存在主属性对候选码的部份依赖和传递依赖。判断方式很简单，就看所有关系式的左边是否包含全部候选码（候选码AB就是看左边是不是AB，而不是A、B）(可以这么回答：因为所有函数依赖的决定因素？、？、？包含所有候选码，因此是BCNF)，如果是就是BCNF，否则就是3NF。</p><p><strong>4NF：</strong>在BCNF的基础上，一个表中有A-&gt;B,A-&gt;C（即A-&gt;BC），但是BC之间没关系，因此这里存在多值依赖，将此表拆分为两个表，分别是(A,B)和(A,C)即可，成为了4NF。（相关概念很多，也有很多性质，建议结合书本理解）</p><p>（任何一个二目关系都是属于4NF（R(X, Y)如果X-&gt;-&gt;Y，即X、Y之间存在平凡的多值依赖，R属于4NF），因此也属于BCNF、3NF......）</p><h1 id="判断步骤">判断步骤</h1><ol type="1"><li><p>求出闭包。什么是求出闭包，简单来说就是左边元素的组合能推出右边的所有元素，这个左边元素的组合就是闭包。</p></li><li><p>求出候选码 =》求出主属性 =》求出非主属性。（关于闭包、候选码练习，点击）</p></li><li><p>从1NF、2NF、3NF、BCNF依次判断。</p></li></ol><h1 id="例题">例题</h1><h2 id="例1.-r-a-b-cf-ab-c">例1. R( A, B, C)，F= { AB-&gt;C}</h2><p>　　1. 判断闭包。AB-&gt;AB、AB-&gt;C，所有AB-&gt;ABC（这与AB-&gt;AB、AB-&gt;C是等价的）。</p><p>　　2. 所以AB是候选码（注意不是A、B），所以A、B都是主属性，C是非主属性。</p><p>　　3. 判断范式。肯定是1NF了；判断是否有部分依赖，看是否有A-&gt;C或者B-&gt;C，没有则表示是2NF；判断是否有传递依赖，很明显没有，表示是3NF；判断是否有主属性对候选码的部分依赖和传递依赖，依然没有（因为左边（AB）全为候选码（AB）），因此是BCNF。</p><h2 id="例2.-r-a-b-cf-b-c-b-a-a-bc">例2. R( A, B, C)，F= { B-&gt;C, B-&gt;A, A-&gt;BC}</h2><p>　　1. 因为B能推出C和A，因此B-&gt;AC，所以B是候选码；因为A-&gt;BC，所以A也是候选码。</p><p>　　2. A、B是主属性，C为非主属性。</p><p>　　3. 很明显，左侧都为一个属性，所以不可能有部分依赖；观察关系也没有传递依赖，因此至少为3NF；因为A、B之间也不存在部分依赖和传递依赖（A-&gt;B、B-&gt;A这不算哦）(因为左边（B、A）全为候选码（A、B）)，所以为BCNF。</p><h2 id="例3.-r-a-b-cf-b-c-ac-b">例3. R( A, B, C)，F= {B-&gt;C, AC-&gt;B}</h2><p>　　1. 因为B-&gt;C表示B能推出C，所以AB+推出ABC；AC-&gt;B，所以AC+能推出ABC。</p><p>　　2. 因此AB、AC为候选码，A、B、C为主属性，不存在非主属性。</p><p>　　3. 没有非主属性，不存在部分依赖、传递依赖，至少为3NF；因为左边（B、AC）不全为候选码（AB、AC）（因为主属性C对候选码AB为部分依赖（B-&gt;C）），所以不为BCNF。</p><h2 id="例4.-r-a-b-cf-a-c-a-b">例4. R( A, B, C)，F= {A-&gt;C, A-&gt;B}</h2><p>　　1. 因为A-&gt;C、A-&gt;B，所以A-&gt;BC，所以A为候选码。</p><p>　　2. A为主属性，B、C为非主属性</p><p>　　3. 左边都只有一个，不存在部分依赖；也不存在传递依赖；左边（A）全为候选码（A），所以为BCNF。</p><h2 id="例5.-r-a-b-c-df-a-c-ad-b">例5. R( A, B, C, D)，F= {A-&gt;C, AD-&gt;B}</h2><p>　　1. A-&gt;C，得到AD+-&gt;AC，因为AD-&gt;B，所以AD可以得到ABCD，因此AD为候选码。</p><p>　　2. A、D为主属性，B、C为非主属性</p><p>　　3. 存在非主属性C对主属性A依赖，即A-&gt;C，但是对于候选码AD而言，C部分依赖于AD，所以只有1NF。</p><h2 id="例6.-r-a-b-c-df-a-c-bc-d">例6. R( A, B, C, D)，F= {A-&gt;C, BC-&gt;D}</h2><p>　　1. A-&gt;C，BC-&gt;D可以得到ABC+(-&gt;AD)-&gt;BCDA，因为A-&gt;C，所以AB+-&gt;ABCD（A-&gt;C，可以得到AB-&gt;BC，因为BC-&gt;D，所以AB-&gt;BCD，所以AB+-&gt;ABCD）。</p><p>　　2. 候选码为AB，主属性为A、B，非主属性为C、D</p><p>　　3. 非主属性C依赖于主属性A（A-&gt;C），所以对于候选码AB而言，非主属性C部分依赖于候选码AB，所以为1NF。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
